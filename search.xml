<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis集群]]></title>
    <url>%2F2018%2F12%2F28%2Fredis%E7%BC%93%E5%AD%982%2F</url>
    <content type="text"><![CDATA[redis集群、架构 一： redis 集群 上一个步骤的主从架构无法实现master和slave角色的自动切换，即当master出现redis服务异常、主机断电、磁盘损坏等问题导致master无法使用，而redis高可用无法实现自故障转移(将slave提升为master)，需要手动改环境配置才能切换到slave redis服务器，另外也无法横向扩展Redis服务的并行写入性能，当单台Redis服务器性能无法满足业务写入需求的时候就必须需要一种方式解决以上的两个核心问题，即：1.master和slave角色的无缝切换，让业务无感知从而不影响业务使用 2.可以横向动态扩展Redis服务器，从而实现多台服务器并行写入以实现更高并发的目的。 Redis 集群实现方式：客户端分片 代理分片 Redis Cluster（做集群一般使用奇数台服务器做集群，3、5、7,损坏的节点剩余要大于总节点的一半） Sentinel(哨兵)：测试主从是否正常通讯：ping GONG(集群实现的前提是要使主从的版本相同) Sentinel 进程是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。一般在生产环境也建议使用Redis的2.8版本的以后版本。哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行多个哨兵(sentinel) 进程，这些进程使用流言协议(gossipprotocols)来接收关于Master主服务器是否下线的信息，并使用投票协议(Agreement Protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。每个哨兵(Sentinel)进程会向其它哨兵(Sentinel)、Master、Slave定时发送消息，以确认对方是否”活”着，如果发现对方在指定配置时间(可配置的)内未得到回应，则暂时认为对方已掉线，也就是所谓的”主观认为宕机” ，英文名称：Subjective Down，简称SDOWN。有主观宕机，肯定就有客观宕机。当“哨兵群”中的多数Sentinel进程在对Master主服务器做出 SDOWN 的判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，这种方式就是“客观宕机”，英文名称是：Objectively Down， 简称 ODOWN。通过一定的vote算法，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。Sentinel 机制可以解决master和slave角色的切换问题。 1234Sentinel(哨兵)：哨兵判断服务器是否存活的方式 [root@centos7 redis]# redis-cli -h 127.0.0.1 -p 6379 127.0.0.1:6379&gt; ping PONG 实现哨兵默认端口26379(在生产中建议哨兵是一台独立的服务器，这里演示的时redis服务器上实现哨兵，哨兵判断节点的存活状态机制：ping :pang)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475实验准备： 三台主机：全部编译安装，为了避免实验出现差别，尽量使用相同版本 主节点：172.18.135.1 从节点1：172.18.135.2 从节点2：172.18.135.3实验目的如果主节点挂了，自动其中一个从节点上选择一个自动升级为主节点第一步：编辑所有主机的配置文件 修改本机的监听地址 76行 bind 0.0.0.0 修改主从结构的配置 286 replicaof 192.168.7.103 6379 293 masterauth 123456 #master如果密码需要设置 [root@centos7 ~]# systemctl restart redis.service 第二步：首先实现一主两从架构 从节点1： 127.0.0.1:6379&gt; info [ # Replication role:slave master_host:172.18.135.1 master_port:6379 master_link_status:up 从节点2： 127.0.0.1:6379&gt; info [ # Replication role:slave master_host:172.18.135.1 master_port:6379 master_link_status:up第三步：哨兵可以不和Redis服务器部署在一起配置哨兵：编辑配置文件sentinel.conf： master 、slave1、slave2 配置： [root@centos7 ~]# cp /usr/local/src/redis-5.0.3/sentinel.conf /usr/local/redis/etc [root@centos7 ~]# vim /usr/local/redis/etc/sentinel.conf port 26379 daemonize yes pidfile /usr/local/redis/data/redis-sentinel_26379.pid logfile "/usr/local/redis/logs/sentinel_26379.log" dir /usr/local/redis/data sentinel monitor mymaster 172.18.131.1 6379 2 sentinel auth-pass mymaster 123456 sentinel down-after-milliseconds mymaster 15000 #15秒 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 180000第四步：启动哨兵 每个节点上都启动哨兵 [root@centos7 ~]# /usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf [root@centos7 etc]# ss -tnl LISTEN 0 511 *:26379 查看哨兵的日志文件第五步：哨兵验证 [root@centos7 ~]# redis-cli -p 26379 127.0.0.1:26379&gt; info Sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=mymaster,status=ok,address=172.18.135.1:6379,slaves=2,sentinels=3已经实现哨兵 可以创建值，并停用主节点，哨兵自动选举新的主节点 哨兵配置文件详情12345678910111213[root@redis-s1 etc]# grep "^[a-Z]" /usr/local/redis/etc/sentinel.conf bind 0.0.0.0port 26379daemonize yes #守护进程运行pidfile "/usr/local/redis/redis-sentinel.pid"logfile "/usr/local/redis/sentinel_26379.log"dir "/usr/local/redis" # 哨兵运行产生的数据目录sentinel monitor mymaster 192.168.7.101 6379 2 #这里的2表示，多少个哨兵决定主节点挂掉则提升新的主,此实验的哨兵有三个sentinel auth-pass mymaster 123456 #主节点的密码，为了安全建议添加密码sentinel down-after-milliseconds mymaster 30000 #(SDOWN)主观下线的时间，主节点多长时间没有反应则代表下线，根据生产需求设置sentinel parallel-syncs mymaster 1 #发生故障转移时候同时向新master同步数据的slave数量，数字越小总同步时间越长sentinel failover-timeout mymaster 180000 #所有slaves指向新的master所需的超时时间（单位秒）sentinel deny-scripts-reconfig yes #代表没有调用其他脚本 应用程序如何连接redis？： java客户端连接redis是通过jedis来实现的，java代码用的时候只要创建jedis对象就可以建多个jedis连接池来连接redis，应用程序再直接调用连接池即可连接Redis。 而Redis为了保障高可用,服务一般都是Sentinel部署方式，当Redis服务中的主服务挂掉之后,会仲裁出另外一台Slaves服务充当Master。这个时候,我们的应用即使使用了Jedis连接池,Master服务挂了,我们的应用奖还是无法连接新的Master服务，为了解决这个问题,Jedis也提供了相应的Sentinel实现,能够在Redis Sentinel主从切换时候,通知我们的应用,把我们的应用连接到新的Master服务。 Jedis Sentinel的使用也是十分简单的,只是在JedisPool中添加了Sentinel和MasterName参数，Jedis Sentinel底层基于Redis订阅实现Redis主从服务的切换通知，当Reids发生主从切换时，Sentinel会发送通知主动通知Jedis进行连接的切换，JedisSentinelPool在每次从连接池中获取链接对象的时候,都要对连接对象进行检测,如果此链接和Sentinel的Master服务连接参数不一致,则会关闭此连接,重新获取新的Jedis连接对象。 二： Redis Cluster部署 Redis cluster之前的分布式方案： 1) 客户端分区：由客户端程序决定key写分配和写入的redis node，但是需要客户端自己处理写入分配、高可用管理和故障转移等 2)代理方案：基于三方软件实现redis proxy，客户端先连接之代理层，由代理层实现key的写入分配，对客户端来说是有比较简单，但是对于集群管节点增减相对比较麻烦，而且代理本身也是单点和性能瓶颈。 在哨兵sentinel机制中，可以解决redis高可用的问题，即当master故障后可以自动将slave提升为master从而可以保证redis服务的正常使用，但是无法解决redis单机写入的瓶颈问题，即单机的redis写入性能受限于单机的内存大小、并发数量、网卡速率等因素，因此redis官方在redis 3.0版本之后推出了无中心架构的redis cluster机制，在无中心的redis集群汇中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接，特点如下： 1：所有Redis节点使用(PING-PING机制)互联 2：集群中某个节点的实效是整个集群中超过半数的节点监测都实效才算真正的实效 3：客户端不需要proxy即可直接连接redis，且客户端不需要连接集群中的所有节点，只要连接集群中的任何一个节点即可。 4：redis cluster把所有的redisnode映射到 0-16383个槽位(slot)上，读写需要到指定的redis node上进行操作，因此有多少个reids node相当于redis 并发扩展了多少倍。 5：Redis集群预先分配16384个(slot)槽位，当需要在redis集群中写入一个key -value的时候，会使用CRC16(key) mod 16384之后的值，决定将key写入值哪一个槽位从而决定写入哪一个Redis节点上，从而有效解决单机瓶颈。 Redis cluster基本架构 假如三个主节点分别是：A, B, C 三个节点，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是： 节点A覆盖0－5460 节点B覆盖5461－10922 节点C覆盖10923－16383 此结构缺点是主节点之间无法数据同步 Redis cluster主从架构： Redis cluster的架构虽然解决了并发的问题，但是又引入了一个新的问题，每个Redis master的高可用如何解决？ 部署redis集群：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#####################环境准备####################三台服务器，每台服务器启动6379和6380两个redis 服务，生产环境建议直接6台服务器。另外预留一台服务器做集群添加节点测试。实验方式：基于端口的不同实现（生产环境中最好使用6台主机实现）172.18.135.1:6379/6380 172.18.135.5:6379/6380172.18.135.2:6379/6380 ##############创建redis cluster集群的前提####目前仅有三台节点####1.每个redis node节点采用相同的硬件配置、相同的密码2.每个节点必须开启参数(确保每台节点都是主节点) #编辑配置文件507 requirepass 123456 # 建议每个节点都设置密码，但是保证每个节点的密码保持一致838 cluster-enabled yes #必须开启集群状态，开启后redis 进程会有cluster显示846 cluster-config-file nodes-6380.conf #此文件有redis cluster集群自动创建和维护，不需要任何手动操作################模拟一台节点上创建第二个节点###################每台节点上模拟创建第二台节点实现一台机器上两个节点[root@centos77 ~]# cp /usr/local/redis/etc/redis.conf /usr/local/redis/etc/redis6380.conf #对原配置文件拷贝进行简单修改bind 0.0.0.0port 6380pidfile "/var/run/redis_6380.pid"logfile "/usr/local/redis/logs/6380.log"cluster-config-file nodes-6380.conf创建启动脚本[root@centos77 ~]# cp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis6380.service[root@centos77 ~]# vim !$vim /usr/lib/systemd/system/redis6380[Unit]Description=Redis persistent key-value databaseAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis6380.conf --supervised systemdExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDType=notifyUser=redisGroup=redisRuntimeDirectory=redisRuntimeDirectoryMode=0755[Install]WantedBy=multi-user.target######################## 启动############################[root@centos77 etc]# scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/[root@centos77 etc]# scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/[root@centos77 etc]# scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/[root@centos77 etc]# scp /usr/local/redis/etc/redis6380.conf root@172.18.135.2:/usr/local/redis/etc/[root@centos77 ~]# scp /usr/lib/systemd/system/redis6380.service root@172.18.135.2:/usr/lib/systemd/system/[root@centos77 ~]# scp /usr/lib/systemd/system/redis6380.service root@172.18.135.1:/usr/lib/systemd/system/启动查看端口[root@centos77 etc]# ss -tnl 6379 6380 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657######################创建集群#####################[root@redis-s1 ~]# redis-cli -a 123456 --cluster create 192.168.7.101:6379 192.168.7.101:6380 192.168.7.102:6379 192.168.7.102:6380 192.168.7.103:6379 192.168.7.103:6380 --cluster-replicas 1 Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 192.168.7.102:6380 to 192.168.7.101:6379Adding replica 192.168.7.101:6380 to 192.168.7.102:6379Adding replica 192.168.7.103:6380 to 192.168.7.103:6379&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity[OK] Perfect anti-affinity obtained!M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 #带M的为master slots:[0-5460] (5461 slots) master #当前master的槽位起始和结束位S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380 #带S的slave replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379 slots:[5461-10922] (5462 slots) master #当前master的槽位起始和结束位S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380 replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fdaM: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379 slots:[10923-16383] (5461 slots) master #当前master的槽位起始和结束位S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380 replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64afCan I set the above configuration? (type 'yes' to accept): yes #输入yes自动创建集群&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.101:6379)M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 #master的ID及端口 slots:[0-5460] (5461 slots) master #已经分配的槽位 1 additional replica(s) #分配了一个slaveS: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380 slots: (0 slots) slave #slave没有分配槽位 replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fdaM: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380 slots: (0 slots) slave replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380 slots: (0 slots) slave replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af[OK] All nodes agree about slots configuration. #所有节点槽位分配完成&gt;&gt;&gt; Check for open slots... #检查打开的槽位&gt;&gt;&gt; Check slots coverage... #检查插槽覆盖范围[OK] All 16384 slots covered. #所有槽位(16384个)分配完成#########################检查状态######################由于未设置masterauth认证密码，所以主从未建立起来，但是集群已经运行，所以需要在每个slave控制台使用config set设置masterauth密码，或者写在每个redis配置文件中，最好是在控制点设置密码之后再写入配置文件当中。 123456789101112131415#######################分别设置masterauth密码#############[root@redis-s1 ~]# redis-cli -h 192.168.7.101 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.101:6380&gt; CONFIG SET masterauth 123456OK[root@redis-s1 ~]# redis-cli -h 192.168.7.102 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.102:6380&gt; CONFIG SET masterauth 123456OK[root@redis-s1 ~]# redis-cli -h 192.168.7.103 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.103:6380&gt; CONFIG SET masterauth 123456OK#######################确认slave状态为up################## 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465########################验证master状态###################[root@redis-s1 ~]# redis-cli -h 192.168.7.101 -p 6379 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.101:6379&gt; INFO Replication# Replicationrole:masterconnected_slaves:1slave0:ip=192.168.7.102,port=6380,state=online,offset=840,lag=0master_replid:0aa3281030eb29bf268f3317d4afe401f661a917master_replid2:0000000000000000000000000000000000000000master_repl_offset:840second_repl_offset:-1repl_backlog_active:1repl_backlog_size:4026531840repl_backlog_first_byte_offset:1repl_backlog_histlen:840192.168.7.101:6379&gt;###################管理要用集群的命令管理#######################################验证集群状态#################192.168.7.101:6379&gt; CLUSTER INFOcluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:1474cluster_stats_messages_pong_sent:1507cluster_stats_messages_sent:2981cluster_stats_messages_ping_received:1502cluster_stats_messages_pong_received:1474cluster_stats_messages_meet_received:5cluster_stats_messages_received:2981########################查看集群node对应关系################使用命令cluster nodes：192.168.7.103:6380&gt; cluster nodes7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545659135000 4 connected7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 myself,slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545659135000 6 connectedf4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545659135000 1 connected 0-5460116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545659136000 3 connected 5461-1092270de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545659134000 5 connected 10923-163832b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545659135946 5 connected##########################验证集群写入key##################192.168.7.101:6379&gt; SET key1 value1 #经过算法计算，当前key的槽位需要写入指定的node (error) MOVED 9189 192.168.7.102:6379 #槽位不在当前node所以无法写入192.168.7.103:6379&gt; SET key1 value1 (error) MOVED 9189 192.168.7.102:6379 192.168.7.102:6379&gt; SET key1 value1 #指定的node就可以写入OK192.168.7.102:6379&gt; KEYS *1) "key1"192.168.7.101:6379&gt; KEYS *(empty list or set)192.168.7.103:6379&gt; KEYS *(empty list or set)#############################集群状态监控#################### redis-cli -a 123456 --cluster check 192.168.7.101:6379 Redis cluster集群节点维护 集群运行时间长久之后，难免由于硬件故障、网络规划、业务增长等原因对已有集群进行相应的调整， 比如增加Redis node节点、减少节点、节点迁移、更换服务器等。增加节点和删除节点会涉及到已有的槽位重新分配及数据迁移。 集群维护之动态添加节点： 增加Redis node节点，需要与之前的Redis node版本相同、配置一致，然后分别启动两台Redis node，因为一主一从。 案例： 因公司业务发展迅猛，现有的三主三从redis cluster架构可能无法满足现有业务的并发写入需求，因此公司紧急采购一台服务器192.168.7.104，需要将其动态添加到集群当中其不能影响业务使用和数据丢失，则添加过程如下: 1234567891011121314为了满足生产需求创建新的服务器##同步之前Redis node的配置文件到192.168.7.104 Redis编译安装目录，注意配置文件的监听 IP##scp redis.conf 192.168.7.104:/usr/local/redis/etc/scp redis_6380.conf 192.168.7.104:/usr/local/redis/etc/##################分别启动redis服务##########################systemctl daemon-reloadsystemctl restart redis/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis_6380.conf################将新创建的新的服务器添加节点到集群############在新创建的节点上配置（新加入的节点是没有槽位的）要添加的redis节点IP和端口 添加到的集群中的master IP:端口# redis-cli -a 123456 --cluster add-node 192.168.7.104:6379 192.168.7.101:6379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#############################分配槽位######################添加主机之后需要对添加至集群种的新主机重新分片否则其没有分片在新创建的节点上配置（分配的槽位是从以前每个节点上瓜分槽位来给新加入的服务器）使用命令重新分配槽位:[root@redis-s1 ~]# redis-cli -a 123456 --cluster reshard 192.168.7.104:6379[root@redis-s1 ~]# redis-cli -a 123456 --cluster reshard 192.168.7.104:6379 Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.104:6379)M: 886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379 slots: (0 slots) masterM: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380 slots: (0 slots) slave replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380 slots: (0 slots) slave replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fdaM: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380 slots: (0 slots) slave replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64afM: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.How many slots do you want to move (from 1 to 16384)? 4096 #分配多少个槽位192.168.7.104:6379What is the receiving node ID? 886338acd50c3015be68a760502b239f4509881c #手动输入192.168.7.104的node IDPlease enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs.Source node #1: all #将哪些源主机的槽位分配给192.168.7.104:6379，all是自动在所有的redis node选择划分，如果是从redis cluster删除主机可以使用此方式将主机上的槽位全部移动到别的redis主机……………………………….. Moving slot 6823 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af Moving slot 6824 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af Moving slot 6825 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af Moving slot 6826 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af Moving slot 10923 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 Moving slot 10924 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 Moving slot 10925 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 Moving slot 10926 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62………………………………….. Moving slot 1364 from f4cfc5cf821c0d855016488d6fbfb62c03a14fdaDo you want to proceed with the proposed reshard plan (yes/no)? yes #确认分配##################验证重新分配槽位之后的集群状态#############重新分配槽位是自动从每个Redis node上移动一些槽位到新的master上 123456789101112131415161718192021222324252627282930313233###################为新的master添加slave节点################master节点必须有salvae一但挂掉损失惨重命令格式：(这样加入的192.168.7.104:6380 默认为master)# redis-cli -a 123456 --cluster add-node 192.168.7.104:6380 192.168.7.104:6379###################更改新节点更改状态为slave###############需要手动将其指定为某个master 的slave，否则其默认角色为master[root@redis-s1 ~]# redis-cli -h 192.168.7.104 -p 6380 -a 123456 #登录到新添加节点Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.104:6380&gt; CLUSTER NODES #查看当前集群节点，找到目标master 的ID7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545700464964 3 connected116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545700470516 3 connected 6827-109222b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545700468498 5 connectedb9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 myself,master - 0 1545700464000 0 connected886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 master - 0 1545700465468 7 connected 0-1364 5461-6826 10923-1228770de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545700467489 5 connected 12288-16383f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545700464461 1 connected 1365-54607186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545700469508 1 connected192.168.7.104:6380&gt; CLUSTER REPLICATE 886338acd50c3015be68a760502b239f4509881c #将其设置slave，设置为192.168.7.104:6379的slave #命令格式为cluster replicate MASTERIDOK192.168.7.104:6380&gt; CLUSTER NODES #再次查看集群节点状态，验证节点是否已经更改为指定master 的slave7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545700517970 3 connected116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545700514942 3 connected 6827-109222b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545700518979 5 connectedb9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 myself,slave 886338acd50c3015be68a760502b239f4509881c 0 1545700509000 0 connected886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 master - 0 1545700516456 7 connected 0-1364 5461-6826 10923-1228770de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545700519988 5 connected 12288-16383f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545700515953 1 connected 1365-54607186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545700516962 1 connected192.168.7.104:6380&gt;#########################验证当前集群状态######################## 集群维护之动态删除节点 添加节点的时候是先添加node节点到集群，然后分配槽位，删除节点的操作与添加节点的操作正好相反，是先将被删除的Redis node上的槽位迁移到集群中的其他Redis node节点上，然后再将其删除。如果一个Redis node节点上的槽位没有被完全迁移，删除该node的时候会提升有数据且无法删除。 案例： 由于192.168.7.101服务器使用年限已经超过三年，已经超过厂商质保期而且硬盘出现异常报警，经运维部架构师提交方案并同开发同事开会商议，决定将现有Redis集群的4台服务器分别是192.168.7.101/192.168.7.102/192.168.7.103/192.168.7.104中的192.168.7.101临时下线，三台服务器的并发写入性能足够支出未来1-2年的业务需求，则删除Redis node 192.168.7.101的操作如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748##############迁移master 的槽位之其他master##################[root@redis-s1 ~]# redis-cli -a 123456 --cluster reshard 192.168.7.102:6379Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.102:6379)M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379 slots:[6827-10922] (4096 slots) master 1 additional replica(s)M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379 slots:[12288-16383] (4096 slots) master 1 additional replica(s)M: 886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379 slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master 1 additional replica(s)S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380 slots: (0 slots) slave replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64afS: b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380 slots: (0 slots) slave replicates 886338acd50c3015be68a760502b239f4509881cS: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380 slots: (0 slots) slave replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fdaS: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380 slots: (0 slots) slave replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 slots:[1365-5460] (4096 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.How many slots do you want to move (from 1 to 16384)? 4096 #迁移master上的多少个槽位What is the receiving node ID? 886338acd50c3015be68a760502b239f4509881c #接收槽位的服务器IDPlease enter all the source node IDs. Type 'all' to use all the nodes as source nodes for the hash slots. Type 'done' once you entered all the source nodes IDs.Source node #1: f4cfc5cf821c0d855016488d6fbfb62c03a14fda #从哪个服务器迁移4096个槽位Source node #2: done #写done，表示没有其他master了 Moving slot 5457 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda Moving slot 5458 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda Moving slot 5459 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda Moving slot 5460 from f4cfc5cf821c0d855016488d6fbfb62c03a14fdaDo you want to proceed with the proposed reshard plan (yes/no)? yes #是否继续迁移完成！######################验证槽位迁移完成######################## 123456789101112131415161718192021####################从集群删除服务器##########################虽然槽位已经迁移完成，但是服务器IP信息还在集群当中，因此还需要将IP信息从集群删除命令格式： redis-cli -a 123456 --cluster del-node IP:Port ID#删除master：[root@redis-s1 ~]# redis-cli -a 123456 --cluster del-node 192.168.7.101:6379 f4cfc5cf821c0d855016488d6fbfb62c03a14fdaWarning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Removing node f4cfc5cf821c0d855016488d6fbfb62c03a14fda from cluster 192.168.7.101:6379&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node.#删除slave：该节点上如果还有其他节点上master 的slave，但是由于服务器下架也要一并删除，因此要提前把保证每个master至少有一个slave。[root@redis-s1 ~]# redis-cli -a 123456 --cluster del-node 192.168.7.101:6380 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.&gt;&gt;&gt; Removing node 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 from cluster 192.168.7.101:6380&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node.####################验证node 是否删除######################发现192.168.7.101已经被删除，但是由于192.168.7.101:6380之前是192.168.7.103:6379的slave，所以删除后会导致相应的master缺少slave，需要重新为没有slave的master分配slave。可以发现下图的192.168.7.104有两个slave，分别是192.168.7.102:6380和192.168.7.104:6380，因此需要将其中一个slave转移为192.168.7.103的slave。 12345678910111213141516####################重新分配slave#########################将192.168.7.104:6380 转移为192.168.7.103的slave[root@redis-s1 ~]# redis-cli -h 192.168.7.104 -p 6379 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.104:6379&gt; CLUSTER NODES116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545708439000 3 connected 6827-10922b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 slave 886338acd50c3015be68a760502b239f4509881c 0 1545708440717 7 connected7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave 886338acd50c3015be68a760502b239f4509881c 0 1545708437682 7 connected886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 myself,master - 0 1545708439000 7 connected 0-6826 10923-1228770de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545708440000 5 connected 12288-163837eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545708438697 3 connected192.168.7.104:6380&gt; CLUSTER REPLICATE 70de3821dde4701c647bd6c23b9dd3c5c9f24a62OK##################验证集群Master与Slave对应关系#################Redis Slave节点一定不能个master在一个服务器，必须为跨主机交叉备份模式，避免主机故障后主备全部挂掉，如果出现Redis Slave与Redis master在同一台Redis node的情况，则需要安装以上步骤重新进行slave分配，直到不相互交叉备份为止。 集群维护之模拟Master宕机123456789101112131415161718192021目前的架构为三主三从，互为跨主机master slave模式。#####################测试数据写入###########################测试在master写入数据，并在其对应的slave验证数据：192.168.7.102:6379&gt; SET key1 value1OK192.168.7.102:6379&gt; get key1"value1"#######################slave验证数据########################192.168.7.103:6380&gt; KEYS *1) "key1"192.168.7.103:6380&gt; get key1(error) MOVED 9189 192.168.7.102:6379 #slave不提供读写，只提供数据备份即master选举####################停止master并验证故障转移################Redis Master服务停止之后，其对应的slave会被选举为master继续处理数据的读写操作。# systemctl stop redis######################验证slave 日志######################## tail -f /usr/local/redis/redis_6380.log 1#####################验证slave状态######################## 123456789101112######################验证数据读写#########################确认slave 192.168.7.103:6380切换为master之后可以继续为业务提供读写业务且数据没有丢失。192.168.7.103:6380&gt; KEYS *1) "key1"192.168.7.103:6380&gt; SET aaa bbbOK192.168.7.103:6380&gt; get key1"value1"192.168.7.103:6380&gt; get aaa"bbb"192.168.7.103:6380&gt;注：服务恢复之后重新验证各master的slave。 集群维护之导入现有Redis数据 导入数据需要redis cluster不能与被导入的数据有重复的key名称，否则导入不成功或中断。 案例： 公司将redis cluster部署完成之后，需要将之前的数据导入之Redis cluster集群，但是由于Redis cluster使用的分片保存key的机制，因此使用传统的AOF文件或RDB快照无法满足需求，因此需要使用集群数据导入命令完成。1234567891011121314151617181920212223242526272829303132333435363738394041#########################基础环境准备#####################导入数据之前需要关闭各redis 服务器的密码，包括集群中的各node和源Redis server，避免认证带来的环境不一致从而无法导入，但是可以加参数--cluster-replace 强制替换Redis cluster已有的key。[root@redis-s1 ~]# redis-cli -h 192.168.7.102 -p 6379 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.102:6379&gt; CONFIG SET requirepass ""OK192.168.7.104:6379&gt; exit[root@redis-s1 ~]# redis-cli -h 192.168.7.102 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.102:6380&gt; CONFIG SET requirepass ""OK192.168.7.104:6379&gt; exit[root@redis-s1 ~]# redis-cli -h 192.168.7.103 -p 6379 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.103:6379&gt; CONFIG SET requirepass ""OK192.168.7.103:6379&gt; exit[root@redis-s1 ~]# redis-cli -h 192.168.7.103 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.103:6380&gt; CONFIG SET requirepass ""OK192.168.7.104:6379&gt; exit[root@redis-s1 ~]# redis-cli -h 192.168.7.104 -p 6379 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.104:6379&gt; CONFIG SET requirepass ""OK192.168.7.104:6379&gt; exit[root@redis-s1 ~]# redis-cli -h 192.168.7.104 -p 6380 -a 123456Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.192.168.7.104:6380&gt; CONFIG SET requirepass ""OK192.168.7.104:6379&gt; exit#######################执行数据导入###########################将源Redis server的数据直接导入之redis cluster。命令格式：#redis-cli --cluster import 集群服务器IP:PORT --cluster-from 外部Redis node-IP:PORT --cluster-copy --cluster-replace[root@redis-s2 redis]# redis-cli --cluster import 192.168.7.103:6379 --cluster-from 192.168.7.101:6379 --cluster-copy 1#####################edis cluster验证数据#################### redis扩展集群方案 除了Redis 官方自带的Redis cluster集群之外，还有一写开源的集群解决方案可供参考使用 codis： Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有显著区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务。 codis-proxy相当于redis，即连接codis-proxy和连接redis是没有任何区别的，codis-proxy无状态，不负责记录是否在哪保存，数据在zookeeper记录，即codis proxy向zookeeper查询key的记录位置，proxy 将请求转发到一个组进行处理，一个组里面有一个master和一个或者多个slave组成，默认有1024个槽位，redis cluster 默认有16384个槽位，其把不同的槽位的内容放在不同的group。 Github 地址：https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md twemproxy 由Twemproxy代替客户端实现分片，即代替用户将数据分片并到不同的后端服务器进行读写，其还支持memcached，可以为proxy配置算法，缺点为twemproxy是瓶颈，不支持数据迁移 官方github地址https://github.com/twitter/twemproxy/ Github 地址：https://github.com/twitter/twemproxy]]></content>
      <categories>
        <category>linux服务</category>
      </categories>
      <tags>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis缓存]]></title>
    <url>%2F2018%2F12%2F26%2Fredis%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[redis缓存及架构 一： 缓存概念： 缓存概念 缓存是为了调节速度不一致的两个或多个不同的物质的速度，在中间对速度较快的一方起到一个加速访问速度较慢的一方的作用，比如CPU的一级、二级缓存是保存了CPU最近经常访问的数据，内存是保存CPU经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的raid 卡有也缓存，都是为了起到加速CPU 访问硬盘数据的目的，因为CPU的速度太快了，CPU需要的数据硬盘往往不能在短时间内满足CPU的需求，因此PCU缓存、内存、Raid 卡以及硬盘缓存就在一定程度上满足了CPU的数据需求，即CPU 从缓存读取数据可以大幅提高CPU的工作效率。 系统缓存 1.buffer与cache：buffer：缓冲也叫写缓冲，一般用于写操作，可以将数据先写入内存在写入磁盘，buffer 一般用于写缓冲，用于解决不同介质的速度不一致的缓冲，先将数据临时写入到里自己最近的地方，以提高写入速度，CPU会把数据线写到内存的磁盘缓冲区，然后就认为数据已经写入完成看，然后内核的线程在后面的时间在写入磁盘，所以服务器突然断电会丢失内存中的部分数据。cache：缓存也叫读缓存，一般用于读操作，CPU读文件从内存读，如果内存没有就先从硬盘读到内存再读到CPU，将需要频繁读取的数据放在里自己最近的缓存区域，下次读取的时候即可快速读取。 2.cache的保存位置： 客户端：浏览器 内存：本地服务器、远程服务器 硬盘：本机硬盘、远程服务器硬盘 速度对比： 客户端浏览器-内存-远程内存-硬盘-远程硬盘。 3.cache的特性： 过期时间 强制过期，源网站更新图片后CDN是不会更新的，需要强制是图片缓存过期 命中率，即缓存的读取命中率 用户层缓存： 1.DNS缓存： 默认为60秒，即60秒之内在访问同一个域名就不在进行 DNS解析： 查看chrome浏览器的DNS缓存： chrome://net-internals/#dns 浏览器缓存过期机制： 最后修改时间： 系统调用会获取文件的最后修改时间，如果没有发生变化就返回给浏览器304的状态码，表示没有发生变化，然后浏览器就使用的本地的缓存展示资源， Etag标记： 基于Etag标记是否一致做判断页面是否发生过变化 过期时间： 以上两种都需要发送请求，即不管资源是否过期都要发送请求进行协商，这样会消耗不必要的时间，因此有了缓存的过期时间，即第一次请求资源的时候带一个资源的过期时间，默认为30天，当前这种方式使用的比表较多，但是无法保证客户的时间都是准确并且一致的，因此假如一个最大生存周期，使用用户本地的时间计算缓存数据是否超过多少天，下面的过期时间为2027年，但是缓存的最大生存周期计算为天等于3650天即10年，过期时间如下： CDN缓存： 什么是CND： 内容分发网络（Content Delivery Network），通过将服务内容分发至全网加速节点，利用全球调度系统使用户能够就近获取，有效降低访问延迟，提升服务可用性，CDN 第一降低机房的使用带宽，因为很多资源通过CDN就直接返回用户了，第二解决不同运营商之间的互联，因为可以让联通的网络访问联通让电信的网络访问电信，起到加速用户访问的目的， 第三：解决用户访问的地域问题，就近返回用户资源。 百度CDN：https://cloud.baidu.com/product/cdn.html 阿里CDN：https://www.aliyun.com/product/cdn?spm=5176.8269123.416540.50.728y8n 腾讯CDN：https://www.qcloud.com/product/cdn 用户请求CDN流程： 提前对静态内容进行预缓存，避免大量的请求回源，导致主站网络带宽被打满而导致数据无法更新，另外CDN可以将数据根据访问的热度不同而进行不同级别的缓存，例如访问量最高的资源访问CDN 边缘节点的内存，其次的放在SSD或者SATA，再其次的放在云存储，这样兼顾了速度与成本。 CDN主要优势： 提前对静态内容进行预缓存，避免大量的请求回源，导致主站网络带宽被打满而导致数据无法更新，另外CDN可以将数据根据访问的热度不通而进行不通级别的缓存，例如访问量最高的资源访问CDN 边缘节点的内存，其次的放在SSD或者SATA，再其次的放在云存储，这样兼顾了速度与成本。缓存-缓存到最快的地方如内存，缓存的数据准确命中率高，访问速度就快 调度准确-将用户调度到最近的边缘节点 性能优化-CDN 专门用于缓存响应速度快 安全相关-抵御攻击 节省带宽：由于用户请求由边缘节点响应，因此大幅降低到源站带宽。 应用层缓存： Nginx、PHP等web服务可以设置应用缓存以加速响应用户请求，另外有些解释性语言比如PHP/Python不能直接运行，需要先编译成字节码，但字节码需要解释器解释为机器码之后才能执行，因此字节码也是一种缓存，有时候会出现程序代码上线后字节码没有更新的现象。 其他层面缓存： CPU缓存(L1的数据缓存和L1的指令缓存)、二级缓存、三级缓存 磁盘缓存 RAID卡 分布式缓存：redis、memcache # MegaCli64 -LDinfo -Lall -aAll 二： redis部署与使用： redis基础： 官网地址：https://redis.io/ Redis和Memcached是非关系型数据库也成为NoSQL，MySQL、Mariadb、SQL Server、PostgreSQL、Oracle 数据库属于关系型数据(RDBMS, Relational Database Management System) redis简介： Redis(Remote Dictionary Server)在2009年发布，开发者Salvatore Sanfilippo是意大利开发者，他本想为自己的公司开发一个用于替换MySQL的产品Redis，但是没有想到他把Redis开源后大受欢迎，短短几年，Redis就有了很大的用户群体，目前国内外使用的公司有知乎网、新浪微博、GitHub等 redis是一个开源的、遵循BSD协议的、基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis提供将内存通过网络远程共享的一种服务，提供类似功能的还有memcache，但相比memcache，redis还提供了易扩展、高性能、具备数据持久性等功能。Redis在高并发、低延迟环境要求比较高的环境使用量非常广泛，目前redis在DB-Engine月排行榜https://db-engines.com/en/ranking 中一直比较靠前，而且一直是键值型存储类的首位。 redis对比memcached： 支持数据的持久化：可以将内存中的数据保持在磁盘中，重启redis服务或者服务器之后可以从备份文件中恢复数据到内存继续使用。 支持更多的数据类型：支持string(字符串)、hash(哈希数据)、list(列表)、set(集合)、zet(有序集合) 支持数据的备份：可以实现类似于数据的master-slave模式的数据备份，另外也支持使用快照+AOF。 支持更大的value数据：memcache单个key value最大，支持1MB，而redis最大支持512MB。 Redis 是单线程，而memcache是多线程，所以单机情况下没有memcache并发高，但redis 支持分布式集群以实现更高的并发，单Redis实例可以实现数万并发。 支持集群横向扩展：基于redis cluster的横向扩展，可以实现分布式集群，大幅提升性能和数据安全性。 都是基于C语言开发。 redis 典型应用场景： Session 共享：常见于web集群中的Tomcat或者PHP中多web服务器session共享 消息队列：ELK的日志缓存、部分业务的订阅发布系统 计数器：访问排行榜、商品浏览数等和次数相关的场景 缓存：数据查询、电商网站商品信息、新闻内容 微博/微信社交场合：共同好友、点赞评论等 Redis安装及使用： 官方下载地址：http://download.redis.io/releases/ yum安装redis 123456789[root@centos7 ~]# yum list redisLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileAvailable Packagesredis.x86_64 3.2.12-2.el7 [root@centos7 ~]# yum install redis -y[root@centos7 ~]# systemctl start redis &amp;&amp; systemctl enable redis[root@centos7 ~]# redis-cli127.0.0.1:6379&gt; 编译安装redis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101官方的安装命令： https://redis.io/download 创建一个适合自己程序防止路径 [root@centos7 ~]# mkdir -pv /usr/local/src [root@centos7 ~]# cd !$ cd /usr/local/src [root@centos7 src]# pwd /usr/local/src [root@centos7 src]# ls redis-5.0.3.tar.gz解压 [root@centos7 src]# tar xvf redis-5.0.3.tar.gz 安装开发包组 [root@centos7 redis-5.0.3]# yum groupinstall "Development Tools"编译安装（大小写敏感） [root@centos7 redis-5.0.3]# make PREFIX=/usr/local/redis install [root@centos7 redis]# cd /usr/local/redis/bin/ [root@centos7 bin]# ls redis-benchmark redis-check-rdb redis-sentinel redis-check-aof redis-cli redis-server创建主配置文件以及程序文件 [root@centos7 ~]# cd /usr/local/redis/ [root@centos7 redis]# ls bin [root@centos7 redis]# mkdir etc logs run data root@centos7 redis]# cp /usr/local/src/redis-5.0.3/redis.conf /usr/local/redis/etc/ [root@centos7 redis]# ln -sv /usr/local/redis/bin/* /usr/bin/初次启动解决当前警报启动 [root@centos7 redis]# redis-server /usr/local/redis/etc/redis.conf 34186:C 26 Dec 2018 22:10:01.659 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 34186:C 26 Dec 2018 22:10:01.659 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=34186, just started 34186:C 26 Dec 2018 22:10:01.659 # Configuration loaded 34186:M 26 Dec 2018 22:10:01.660 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.3 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 34186 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 34186:M 26 Dec 2018 22:10:01.662 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 34186:M 26 Dec 2018 22:10:01.662 # Server initialized 34186:M 26 Dec 2018 22:10:01.662 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect. 34186:M 26 Dec 2018 22:10:01.662 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. 34186:M 26 Dec 2018 22:10:01.662 * Ready to accept connections解决第一次启动出现的三个报警 [root@centos7 ~]# vim /etc/sysctl.conf net.core.somaxconn = 512 vm.overcommit_memory = 1 [root@centos7 ~]# sysctl -p net.core.somaxconn = 512 vm.overcommit_memory = 1 [root@centos7 ~]# echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 永久生效写进配置文件间，开机自动加载 vim /etc/rc.d/rc.local echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled chmod a+x /etc/rc.d/rc.local再次启动则无报警 [root@centos7 ~]# /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf 35112:C 27 Dec 2018 10:17:12.662 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 35112:C 27 Dec 2018 10:17:12.662 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=35112, just started 35112:C 27 Dec 2018 10:17:12.662 # Configuration loaded 35112:M 27 Dec 2018 10:17:12.663 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.3 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 35112 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 35112:M 27 Dec 2018 10:17:12.667 # Server initialized 35112:M 27 Dec 2018 10:17:12.667 * Ready to accept connections 解决当前的警告提示： 警报：tcp-backlog： backlog参数控制的是三次握手的时候server端收到client ack确认号之后的队列值。 net.core.somaxconn = 512 警报：vm.overcommit_memory： 0、表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1、表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2、表示内核允许分配超过所有物理内存和交换空间总和的内存 vm.overcommit_memory = 1 警报：transparent hugepage： 开启大页内存动态分配，需要关闭让redis 负责内存管理。 临时生效 echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 永久生效写进配置文件间，开机自动加载 vim /etc/rc.d/rc.local echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled chmod a+x /etc/rc.d/rc.local123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051redis启动默认使再前台工作，编写启动脚本将服务的启动送往后台执行服务启动对应的端口已经默认监听的端口 [root@centos7 ~]# ss -tnl LISTEN 0 511 127.0.0.1:6379 编辑redis服务启动脚本 服务的配置文件放在了/usr/local/redis/bin/redis-servier 服务的主配置文件放在了/usr/local/redis/etc/redis.conf [root@centos7 ~]# vim /usr/lib/systemd/system/redis.service [Unit] Description=Redis persistent key-value database After=network.target After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf --supervised systemd ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID Type=notify User=redis Group=redis RuntimeDirectory=redis RuntimeDirectoryMode=0755 [Install] WantedBy=multi-user.target编辑主配置文件 vim /usr/local/redis/etc/redis.conf daemonize yes #让redis作为守护进程运行创建redis 用户和数据目录： [root@centos7 ~]# useradd redis -s /sbin/nologin [root@centos7 ~]# chown -R redis.redis /usr/local/redis/ [root@centos7 ~]# systemctl daemon-reload [root@centos7 ~]# systemctl start redis.service [root@centos7 ~]# ss -tnl LISTEN 0 511 127.0.0.1:6379 创建命令软连接 [root@centos7 ~]# ln -sv /usr/local/redis/bin/* /usr/bin/修改服务器的监听端口，默认监听在本机的127.0.0.1 [root@centos7 ~]# vim /usr/local/redis/etc/redis.conf bind 127.0.0.1 172.18.135.1 (bind 地址绑定到本机哪个地址供谁可以访问0.0.0.0代表本机监听在本机的所有的地址)使用客户端连接本机的redis服务器 [root@centos7 ~]# redis-cli -h 172.18.135.1 -p 6379 172.18.135.1:6379&gt; info 编译安装后的命令： [root@redis-s1 ~]# ll /usr/local/redis/bin/total 32656 -rwxr-xr-x 1 redis redis 4365488 Dec 13 09:21 redis-benchmark #redis性能测试工具 -rwxr-xr-x 1 redis redis 8088920 Dec 13 09:21 redis-check-aof #AOF文件检查工具 -rwxr-xr-x 1 redis redis 8088920 Dec 13 09:21 redis-check-rdb #RDB文件检查工具 -rwxr-xr-x 1 redis redis 4800752 Dec 13 09:21 redis-cli #redis #客户端工具 lrwxrwxrwx 1 redis redis 12 Dec 13 09:21 redis-sentinel -&gt; redis-server #哨兵，软连接到 使用客户端连接redis： #/usr/local/redis/bin/redis-cli -h IP/HOSTNAME -p PORT -a PASSWORD redis配置文件： redis主要配置项： bind 0.0.0.0 #监听地址，可以用空格隔开后多个监听IP protected-mode yes #redis3.2 之后加入的新特性，在没有设置bind IP和密码的时候只允许访问127.0.0.1:6379 port 6379 #监听端口 tcp-backlog 511 #三次握手的时候server端收到client ack确认号之后的队列值。 timeout 0 #客户端和Redis服务端的连接超时时间，默认是0，表示永不超时。 tcp-keepalive 300 #tcp 会话保持时间 daemonize no #认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes,当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面 supervised no #和操作系统相关参数，可以设置通过upstart和systemd管理Redis守护进程，centos 7以后都使用systemd pidfile /var/run/redis_6379.pid #pid文件路径,确定生成的日志目录是有权限的，实际上存放的就是进程号。 loglevel notice #日志级别 logfile “” #日志路径 databases 16 #设置db 库数量，默认16个库，可以连接到redis后使用select # ,切换库 always-show-logo yes #在启动redis 时是否显示log save 900 1 #在900秒内有一个键内容发生更改就出就快照机制 save 300 10 save 60 10000 stop-writes-on-bgsave-error yes #快照出错时是否禁止redis 写入操作（默认为yes，建议使用no，出错的原因，磁盘满了，权限问题，改为no的原因是系统是由监控的，所以不会等磁盘满了防止数据丢失） rdbcompression yes #持久化到RDB文件时，是否压缩，”yes”为压缩，”no”则反之 rdbchecksum yes #是否开启RC64校验，默认是开启（检查RDB文件是否完整） dbfilename dump.rdb #快照文件名 dir ./ #快照文件保存路径 replica-serve-stale-data yes #当从库同主库失去连接或者复制正在进行，从机库有两种运行方式：1) 如果replica-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果replica-serve-stale-data设置为no，除去指定的命令之外的任何请求都会返回一个错误”SYNC with master in progress”。 replica-read-only yes #是否设置从库只读 repl-diskless-sync no #是否使用socket方式复制数据，目前redis复制提供两种方式，disk和socket，如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件，有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave，socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave，disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件，socket的方式就是一个个slave顺序复制，只有在磁盘速度缓慢但是网络相对较快的情况下才使用socket方式，否则使用默认的disk方式 repl-diskless-sync-delay 5 #diskless复制的延迟时间，设置0为关闭，一旦复制开始还没有结束之前，master节点不会再接收新slave的复制请求，直到下一次开始 repl-ping-slave-period 10 #slave根据master指定的时间进行周期性的PING 监测 repl-timeout 60 #复制链接超时时间，需要大于repl-ping-slave-period，否则会经常报超时 repl-disable-tcp-nodelay no #在socket模式下是否slave套接字发送SYNC之后禁用 TCP_NODELAY，如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒，如果你选择了 “no” 数据传输到salve的延迟将会减少但要使用更多的带宽 repl-backlog-size 1mb #复制缓冲区大小，只有在slave连接之后才分配内存。 repl-backlog-ttl 3600 #多次时间master没有slave连接，就清空backlog缓冲区。 replica-priority 100 #当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。 requirepass foobared #设置redis 连接密码 rename-command #重命名一些高危命令 maxclients 10000 #最大连接客户端（根据生产进行调整） maxmemory #最大内存，单位为bytes字节，8G内存的计算方式8(G)1024(MB)1024(KB)*1024(Kbyte)，需要注意的是slave的输出缓冲区是不计算在maxmemory内。（如果不限制，则redis无限使用物理内存，最后将服务器的进程kill掉，最好给予系统内存的一半，生产使用redis建议服务器16G给redis服务器8G） appendonly no #是否开启AOF日志记录，默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。 appendfilename “appendonly.aof” #AOF文件名 appendfsync everysec #aof持久化策略的配置,no表示不执行fsync,由操作系统保证数据同步到磁盘,always表示每次写入都执行fsync，以保证数据同步到磁盘,everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。 no-appendfsync-on-rewrite no在aof rewrite期间,是否对aof新记录的append暂缓使用文件同步策略,主要考虑磁盘IO开支和请求阻塞时间。默认为no,表示”不暂缓”,新的aof记录仍然会被立即同步，Linux的默认fsync策略是30秒，如果为yes 可能丢失30秒数据，但由于yes性能较好而且会避免出现阻塞因此比较推荐。 auto-aof-rewrite-percentage 100 # 当Aof log增长超过指定比例时，重写log file， 设置为0表示不自动重写Aof 日志，重写是为了使aof体积保持最小，而确保保存最完整的数据。 auto-aof-rewrite-min-size 64mb #触发aof rewrite的最小文件尺寸 aof-load-truncated yes #是否加载由于其他原因导致的末尾异常的AOF文件(主进程被kill/断电等) aof-use-rdb-preamble yes #redis4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，这样Redis就可以同时兼有RDB持久化和AOF持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。 lua-time-limit 5000 #lua脚本的最大执行时间，单位为毫秒 cluster-enabled yes #是否开启集群模式，默认是单机模式 cluster-config-file nodes-6379.conf #由node节点自动生成和的集群配置文件 cluster-node-timeout 15000 #集群中node节点连接超时时间 cluster-replica-validity-factor 10 #在执行故障转移的时候可能有些节点和master断开一段时间数据比较旧，这些节点就不适用于选举为master，超过这个时间的就不会被进行故障转移 cluster-migration-barrier 1 #一个主节点拥有的至少正常工作的从节点，即如果主节点的slave节点故障后会将多余的从节点分配到当前主节点成为其新的从节点。 cluster-require-full-coverage yes #集群槽位覆盖，如果一个主库宕机且没有备库就会出现集群槽位不全，那么yes情况下redis集群槽位验证不全就不再对外提供服务，而no则可以继续使用但是会出现查询数据查不到的情况(因为有数据丢失)。 cluster-replica-no-failover no#Slow log 是 Redis 用来记录查询执行时间的日志系统，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。 slowlog-log-slower-than 10000 #以微秒为单位的慢日志记录，为负数会禁用慢日志，为0会记录每个命令操作。 slowlog-max-len 128 #记录多少条慢日志保存在队列，超出后会删除最早的，以此滚动删除 三： redis持久化： redis 虽然是一个内存级别的缓存程序，即redis 是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的，redis支持两种不同方式的数据持久化保存机制，分别是RDB和AOF RDB模式： RDB：基于时间的快照，只保留当前最新的一次快照，特点是执行速度比较快，缺点是可能会丢失从上次快照到当前快照未完成之间的数据。 RDB实现的具体过程Redis从主进程先fork出一个子进程，使用写时复制机制，子进程将内存的数据保存为一个临时文件，比如dump.rdb.temp，当数据保存完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保存每一次做RDB快照的时候保存的数据都是完整的，因为直接替换RDB文件的时候可能会出现突然断电等问题而导致RDB文件还没有保存完整就突然关机停止保存而导致数据丢失的情况，可以手动将每次生成的RDB文件进程备份，这样可以最大化保存历史数据。 RDB模式的优缺点： 优点： RDB快照保存了某个时间点的数据，可以通过脚本执行bgsave(非阻塞)或者save(阻塞)命令自定义时间点北备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本。 可以最大化o的性能，因为父进程在保存RDB 文件的时候唯一要做的是fork出一个子进程，然后的-操作都会有这个子进程操作，父进程无需任何的IO操作 RDB在大量数据比如几个G的数据，恢复的速度比AOF的快 缺点： 不能时时的保存数据，会丢失自上一次执行RDB备份到当前的内存数据 数据量非常大的时候，从父进程fork的时候需要一点时间，可能是毫秒或者秒 AOF模式： AOF:按照操作顺序依次将操作添加到指定的日志文件当中，特点是数据安全性相对较高，缺点是即使有些操作是重复的也会全部记录。 AOF和RDB一样使用了写时复制机制，AOF默认为每秒钟fsync一次，即将执行的命令保存到AOF文件当中，这样即使redis服务器发生故障的话顶多也就丢失1秒钟之内的数据，也可以设置不同的fsync策略，或者设置每次执行命令的时候执行fsync，fsync会在后台执行线程，所以主线程可以继续处理用户的正常请求而不受到写入AOF文件的IO影响 AOF模式优缺点： AOF的文件大小要大于RDB格式的文件 根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec即每秒执行一次fsync 四： redis 数据类型： 1.字符串(string)： 字符串是所有编程语言中最常见的和最常用的数据类型，而且也是redis最基本的数据类型之一，而且redis中所有的key的类型都是字符串。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182连接redis [root@centos7 ~]# redis-cli -h 172.18.135.1 -p 6379 172.18.135.1:6379&gt; 添加一个key 172.18.135.1:6379&gt; set key1 value1 （后面可以添加过期时间，如果不加则永不过期） OK查看key对应的值 172.18.135.1:6379&gt; get key1 "value1"查看key的类型 172.18.135.1:6379&gt; type key1 string（字符串）删除key的值 （DEL可以删除任何类型的key） 172.18.135.1:6379&gt; DEL key1 (integer) 1 (返回值为1，则表示成功，0表示不成功) 172.18.135.1:6379&gt; get key1 (nil)批量创建多个key 172.18.135.1:6379&gt; mset key1 value1 key2 value2 .... OK批量获取多个key的值 172.18.135.1:6379&gt; mget key1 key2 1) "value1" 2) "value2"批量删除多个key 172.18.135.1:6379&gt; del key1 key2 (integer) 2 172.18.135.1:6379&gt; mget key1 key2 1) (nil) 2) (nil)清空当前库的所有数据 172.18.135.1:6379&gt; flushdb OK查看当前数据库的所有key值 172.18.135.1:6379&gt; keys * (empty list or set)清空所有数据库的key 172.18.135.1:6379&gt; FLUSHALL数值递增：（必须是数字且数个整数） 172.18.135.1:6379&gt; SET num 0 OK 172.18.135.1:6379&gt; INCR num (integer) 1 172.18.135.1:6379&gt; GET num "1"数值递减 172.18.135.1:6379&gt; INCR num (integer) 2 172.18.135.1:6379&gt; GET num "2" 172.18.135.1:6379&gt; DECR num (integer) 1 172.18.135.1:6379&gt; GET num "1"向列表追加数据： 127.0.0.1:6379&gt; LPUSH list1 tom (integer) 2 127.0.0.1:6379&gt; RPUSH list1 jack (integer) 3获取列表长度： 127.0.0.1:6379&gt; LLEN list1 (integer) 3移除列表数据： 127.0.0.1:6379&gt; RPOP list1 #最后一个 "jack" 127.0.0.1:6379&gt; LPOP list1 #第一个 "tom" 2.集合(set)： Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455生成集合key:SADD：无序集合 127.0.0.1:6379&gt; SADD set1 v1 (integer) 1 127.0.0.1:6379&gt; SADD set2 v2 v4 (integer) 2 127.0.0.1:6379&gt; TYPE set1 set 127.0.0.1:6379&gt; TYPE set2 set查看集合中的所有值 127.0.0.1:6379&gt; SMEMBERS set1追加数值：追加的时候不能追加已经存在的数值 127.0.0.1:6379&gt; SADD set1 v2 v3 v4 (integer) 3 127.0.0.1:6379&gt; SADD set1 v2 #没有追加成功 (integer) 0 127.0.0.1:6379&gt; TYPE set1 set 127.0.0.1:6379&gt; TYPE set2 set查看集合的所有数据：同set的值不可重复，不同 set的值可以相同 127.0.0.1:6379&gt; SMEMBERS set1 1) "v4" 2) "v1" 3) "v3" 4) "v2" 127.0.0.1:6379&gt; SMEMBERS set2 1) "v4" 2) "v2"获取集合的差集：差集：已属于A而不属于B的元素称为A与B的（差集） 127.0.0.1:6379&gt; SDIFF set1 set2 1) "v1" 2) "v3"获取集合的交集：交集：已属于A且属于B的元素称为A与B的(交集） 127.0.0.1:6379&gt; SINTER set1 set2 1) "v4" 2) "v2"获取集合的并集：并集：已属于A或属于B的元素为称为A与B的(并集） 127.0.0.1:6379&gt; SUNION set1 set2 1) "v2" 2) "v4" 3) "v1" 4) "v3" 3.sorted set(有序集合): Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double(双精度浮点型)类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序，序集合的成员是唯一的,但分数(score)却可以重复，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)， 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950生成有序集合： 127.0.0.1:6379&gt; ZADD zset1 1 v1 (integer) 1 127.0.0.1:6379&gt; ZADD zset1 2 v2 (integer) 1 127.0.0.1:6379&gt; ZADD zset1 2 v3 (integer) 1 127.0.0.1:6379&gt; ZADD zset1 3 v4 (integer) 1 127.0.0.1:6379&gt; TYPE zset1 zset 127.0.0.1:6379&gt; TYPE zset2 zset排行案例： 192.168.7.104:6379&gt; ZADD paihangbang 10 key1 20 key2 30 key3 (integer) 3 192.168.7.104:6379&gt; ZREVRANGE paihangbang 0 -1 withscores 1) "key3" 2) "30" 3) "key2" 4) "20" 5) "key1" 6) "10"批量添加多个数值： 127.0.0.1:6379&gt; ZADD zset2 1 v1 2 v2 4 v3 5 v5 (integer) 4获取集合的长度数： 127.0.0.1:6379&gt; ZCARD zset1 (integer) 4 127.0.0.1:6379&gt; ZCARD zset2 (integer) 4基于索引返回数值： 127.0.0.1:6379&gt; ZRANGE zset1 1 3 1) "v2" 2) "v3" 3) "v4" 127.0.0.1:6379&gt; ZRANGE zset1 0 2 1) "v1" 2) "v2" 3) "v3"返回某个数值的索引： 127.0.0.1:6379&gt; ZRANK zset1 v2 (integer) 1 127.0.0.1:6379&gt; ZRANK zset1 v3 (integer) 2 4.哈希(hash)： hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象,Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。12345678910111213141516171819202122232425262728生成hash key： 127.0.0.1:6379&gt; HSET hset1 name tom age 18 (integer) 1 127.0.0.1:6379&gt; TYPE hset1 hash获取hash key字段值： 127.0.0.1:6379&gt; HGET hset1 name "tom" 127.0.0.1:6379&gt; HGET hset1 age "18"删除一个hash key的字段： 127.0.0.1:6379&gt; HDEL hset1 age (integer) 1获取所有hash表中的字段： 127.0.0.1:6379&gt; HSET hset1 name tom age 19 (integer) 1 127.0.0.1:6379&gt; HKEYS hset1 1) "name" 2) "age"设定key的过期时间 127.0.0.1:6379&gt; set test1 value1 ex 5 #设定这个key的过期时间，43200半天时间，g根据用户需求设定查看key的过期时长 127.0.0.1:6379&gt; TTL key1 五： 消息队列：消息队列主要分为两种，分别是生产者消费者模式和发布者订阅者模式，这两种模式Redis都支持 生产者消费者模式： 1.在生产者消费者(Producer/Consumer)模式下，上层应用接收到的外部请求后开始处理其当前步骤的操作，在执行完成后将已经完成的操作发送至指定的频道(channel)当中，并由其下层的应用监听该频道并继续下一步的操作，如果其处理完成后没有下一步的操作就直接返回数据给外部请求，如果还有下一步的操作就再将任务发布到另外一个频道，由另外一个消费者继续监听和处理。 2.模式介绍： 生产者消费者模式下，多个消费者同时监听一个队里，但是一个消息只能被最先抢到消息的消费者消费，即消息任务是一次性读取和处理，此模式在分布式业务架构中非常常用，比较常用的软件还有 RabbitMQ、Kafka、RocketMQ、ActiveMQ等 3.队列介绍： 队列当中的 消息由不同的生产者写入也会有不同的消费者取出进行消费处理，但是买一个消息一定是只能被取出一次也就是被消费一次。 12345678910111213141516171819202122232425262728293031323334353637383940生产者发布消息： [root@redis-s4 ~]# redis-cli 127.0.0.1:6379&gt; AUTH 123456 OK 127.0.0.1:6379&gt; LPUSH channel1 msg1 #从管道的左侧写入 (integer) 1 127.0.0.1:6379&gt; LPUSH channel1 msg2 (integer) 2 127.0.0.1:6379&gt; LPUSH channel1 msg3 (integer) 3 127.0.0.1:6379&gt; LPUSH channel1 msg4 (integer) 4 127.0.0.1:6379&gt; LPUSH channel1 msg5 (integer) 5切换终端模拟消费者，查看队列所有消息：#（0，-1代表查看所有的消息） 127.0.0.1:6379&gt; LRANGE channel1 0 -1 #切换其他客户端查看则已经看不到此条消息队列，因为已经被当前客户端取走 1) "msg5" 2) "msg4" 3) "msg3" 4) "msg2" 5) "msg1"消费者消费消息： 127.0.0.1:6379&gt; RPOP channel1 #从管道的右侧消费 "msg1" 127.0.0.1:6379&gt; RPOP channel1 "msg2" 127.0.0.1:6379&gt; RPOP channel1 "msg3" 127.0.0.1:6379&gt; RPOP channel1 "msg4" 127.0.0.1:6379&gt; RPOP channel1 "msg5" 127.0.0.1:6379&gt; RPOP channel1 (nil)切换主机模拟消费者，再次验证队列消息： 127.0.0.1:6379&gt; LRANGE channel1 0 -1 (empty list or set) #队列中的消息已经被已全部消费完毕 发布者订阅模式： 1.模式简介： 在发布者订阅者模式下，发布者将消息发布到指定的channel里面，凡是监听该channel的消费者都会收到同样的一份消息，这种模式类似于是收音机模式，即凡是收听某个频道的听众都会收到主持人发布的相同的消息内容。 此模式常用语群聊天、群通知、群公告等场景。 Subscriber：订阅者 Publisher：发布者 Channel：频道 1234567891011121314151617181920212223242526订阅者监听频道： [root@redis-s4 ~]# redis-cli 127.0.0.1:6379&gt; AUTH 123456 OK 127.0.0.1:6379&gt; SUBSCRIBE channel1 #订阅者订阅指定的频道,也就是客户端监听服务端的频道，此时可以模拟多个客户端监听服务端的此频道 Reading messages... (press Ctrl-C to quit) 1) "subscribe" 2) "channel1" 3) (integer) 1发布者发布消息：#服务端在此频道发布消息，此时客户端监听在服务端的此频道，都会接受到消息 127.0.0.1:6379&gt; PUBLISH channel1 test1 #发布者发布消息 (integer) 2 127.0.0.1:6379&gt; PUBLISH channel1 test2 (integer) 2 127.0.0.1:6379&gt;订阅多个频道：订阅指定的多个频道 127.0.0.1:6379&gt; SUBSCRIBE channel1 channel2 订阅所有频道： 127.0.0.1:6379&gt; PSUBSCRIBE *订阅匹配的频道： 127.0.0.1:6379&gt; PSUBSCRIBE chann* #匹配订阅多个频道 六： redis其他命令：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CONFIG： config 命令用于查看当前redis配置、以及不重启更改redis配置等 127.0.0.1:6379&gt;config get * #获取config的命令配置帮助,或当前配置更改最大内存： 127.0.0.1:6379&gt; CONFIG set maxmemory 8589934592 OK 127.0.0.1:6379&gt; CONFIG get maxmemory #获取此配置项的值 1) "maxmemory" 2) "8589934592"设置连接密码：(可以先修改配置文件再动态命令行设置，这样避免重启服务生效) 127.0.0.1:6379&gt; CONFIG SET requirepass 123456 OK #通过CONFIG设置密码后立即生效 重现连接测试 172.18.135.1:6379&gt; CONFIG SET requirepass 123456 OK 172.18.135.1:6379&gt; exit [root@centos7 ~]# redis-cli -h 172.18.135.1 -p 6379 172.18.135.1:6379&gt; keys * (error) NOAUTH Authentication required. 172.18.135.1:6379&gt; auth 123456 #auth认证连接 OK 172.18.135.1:6379&gt; keys * 1) "key1"编辑配置文件设置连接redis的密码永久生效 #可以先在redis动态控制台设置完再在配置文件中修改这样会避免重启服务器代来不必要的损失 [root@centos7 ~]# vim /usr/local/redis/etc/redis.conf 507行 requirepass 123456info：显示当前节点redis运行状态信息 172.18.135.1:6379&gt; info SELECT：切换数据库 172.18.135.1:6379&gt; keys:查看当前库下的所有key：#keys * 慎用，相当于将数据库中的所有数据拿出，如果数据较多全部显示则会把机器卡死BGSAVE：手动在后台执行RDB持久化操作 172.18.135.1:6379&gt; BGSAVEDBSIZE：返回当前库下的所有key 数量 172.18.135.1:6379&gt; DBSIZEFLUSHDB：强制清空当前库中的所有key 172.18.135.1:6379&gt; FLUSHDBFLUSHALL：强制清空当前redis服务器所有数据库中的所有key，即删除所有数据 172.18.135.1:6379&gt; FLUSHALL 七： redis高可用于集群——配置redis主从 虽然Redis可以实现单机的数据持久化，但无论是RDB也好或者AOF也好，都解决不了单点宕机问题，即一旦redis服务器本身出现系统故障、硬件故障等问题后，就会直接造成数据的丢失，因此需要使用另外的技术来解决单点问题。 配置reids 主从： 主备模式，可以实现Redis数据的跨主机备份。 程序端连接到高可用负载的VIP，然后连接到负载服务器设置的Redis后端real server，此模式不需要在程序里面配置Redis服务器的真实IP地址，当后期Redis服务器IP地址发生变更只需要更改redis 相应的后端real server即可，可避免更改程序中的IP地址设置。 Slave主要配置： Redis Slave 也要开启持久化（RDB\AOF）并设置和master同样的连接密码，因为后期slave会有提升为master的可能,Slave端切换master同步后会丢失之前的所有数据。（最好将slave的配置于master相同，密码相同为了master宕机提升slave为新的主，如果开始同步，从节点上的原有的值则被清空，所以最好是要当从节点的服务器为干净的redis服务系统，后期如果将从节点强制和主节点断开的话则从节点的数据不会丢失） 一旦某个Slave成为一个master的slave，Redis Slave服务会清空当前redis服务器上的所有数据并将master的数据导入到自己的内存，但是断开同步关系后不会删除当前已经同步过的数据。 命令行配置12345678910方法1：从节点命令行方式将称为主节点的slave 当前状态为master，需要转换为slave角色并指向master服务器的IP+PORT+Password 192.168.7.104:6379&gt; SLAVEOF 192.168.7.103 6379 OK 192.168.7.104:6379&gt; CONFIG SET masterauth 123456 OK 关闭从节点的从属性 127.0.0.1:6379&gt; SLAVEOF NO ONE 在终端配置文件主从选项在重启服务后失效 保存在配置文件中123456789方法2:此配置文件是编译安装的配置文件vim /usr/local/redis/etc/redis.conf replicaof 192.168.7.103 6379masterauth 123456 #master如果密码需要设置，这里设置的密码为主节点的密码从节点查看 重启服务查看 127.0.0.1:6379&gt; info 1234567891011验证slave数据：确定slave的数据是不是从主节点的数据同步来的，可以一致观察这从节点的日志 127.0.0.1:6379&gt; KEYS * 1) "num" 2) "hset1" 3) "key1" 4) "name1" 5) "zset2" 6) "key2" 7) "zset1" 8) "set2"slave 状态只读无法写入数据， 主从复制过程： Redis支持主从复制分为全量同步和增量同步，首次同步是全量同步，主从同步可以让从服务器从主服务器备份数据，而且从服务器还可与有从服务器，即另外一台redis服务器可以从一台从服务器进行数据同步，redis 的主从同步是非阻塞的，其收到从服务器的sync(2.8版本之前是PSYNC)命令会fork一个子进程在后台执行bgsave命令，并将新写入的数据写入到一个缓冲区里面，bgsave执行完成之后并生成的将RDB文件发送给客户端，客户端将收到后的RDB文件载入自己的内存，然后主redis将缓冲区的内容在全部发送给从redis，之后的同步从服务器会发送一个offset的位置(等同于MySQL的binlog的位置)给主服务器，主服务器检查后位置没有错误将此位置之后的数据包括写在缓冲区的积压数据发送给redis从服务器，从服务器将主服务器发送的挤压数据写入内存，这样一次完整的数据同步，再之后再同步的时候从服务器只要发送当前的offset位 置给主服务器，然后主服务器根据响应的位置将之后的数据发送给从服务器保存到其内存即可。 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 1）从服务器连接主服务器，发送SYNC命令； 2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB快照文件并使用缓冲区记录此后执行的所有写命令； 3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 7）后期同步会先发送自己slave_repl_offset位置，只同步新增加的数据，不再全量同步。 主从同步优化： Redis在2.8版本之前没有提供增量部分复制的功能，当网络闪断或者slave Redis重启之后会导致主从之间的全量同步，即从2.8版本开始增加了部分复制的功能。repl-diskless-sync no #yes为支持disk，master将RDB文件先保存到磁盘在发送给slave，no为maste直接将RDB文件发送给slave，默认即为使用no，Master RDB文件不需要与磁盘交互。 repl-diskless-sync-delay 5 #Master准备好RDB文件后等等待传输时间 repl-ping-slave-period 10 #slave端向server端发送pings的时间区间设置，默认为10秒 repl-timeout 60 #设置超时时间 repl-disable-tcp-nodelay no #是否启用TCP_NODELAY，如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致，假如设置成no，则redis master会立即发送同步数据，没有延迟，前者关注性能，后者关注一致性 repl-backlog-size 1mb #master的写入数据缓冲区，用于记录自上一次同步后到下一次同步过程中间的写入命令，计算公式：b repl-backlog-size = 允许从节点最大中断时长 主实例offset每秒写入量，比如master每秒最大写入64mb，最大允许60秒，那么就要设置为64mb60秒=3840mb(3.8G)= repl-backlog-ttl 3600 #如果一段时间后没有slave连接到master，则backlog size的内存将会被释放。如果值为0则表示永远不释放这部份内存。 slave-priority 100 #slave端的优先级设置，值是一个整数，数字越小表示优先级越高。当master故障时将会按照优先级来选择slave端进行恢复，如果值设置为0，则表示该slave永远不会被选择。 #min-slaves-to-write 0 # #min-slaves-max-lag 10 #设置当一个master端的可用slave少于N个，延迟时间大于M秒时，不接收写操作。 \Master的重启会导致master_replid发生变化，slave之前的master_replid就和master不一致从而会引发所有slave的全量同步。 Slave同步过程日志：master同步日志： slave切换master：123456789101112131415161718192021222324252627282930313233当前状态： 从节点的状态信息 192.168.7.101:6379&gt; info Replication # Replication role:slave master_host:192.168.7.103 master_port:6379 master_link_status:up master_last_io_seconds_ago:8 master_sync_in_progress:0停止slave同步并查看当前状态： 192.168.7.101:6379&gt; SLAVEOF no one OK 192.168.7.101:6379&gt; info Replication # Replication role:master connected_slaves:0 master_replid:ac3475e5e4fae8c5f47711a643e465b9520c4182 master_replid2:8ee6bc1ac452fd4d2ccbaa660a219f78d218399a master_repl_offset:8840 second_repl_offset:8841 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:8547 repl_backlog_histlen:294测试能从节点否写入数据： 192.168.7.101:6379&gt; set key1 value1 #从节点停止主从结构时就是本机的自己的主，所以自然可以都自己的值进行写入 OK 192.168.7.101:6379&gt;虽然从节点脱离了主从结构，但是从节点的数据，依然保留着主节点同步时的数据。 Slave节点再有Slave： 在有slave的”master”查看状态： # Replication role:slave master_host:192.168.7.102 master_port:6379 master_link_status:up master_last_io_seconds_ago:9 #最近一次与master通信已经过去多少秒。 master_sync_in_progress:0 #是否正在与master通信。 slave_repl_offset:5334 #当前同步的偏移量。 slave_priority:100 #slave优先级，master故障后值越小越优先同步，一半设置相同的数值让它同时同步。 slave_read_only:1 connected_slaves:1 slave0:ip=192.168.7.104,port=6379,state=online, offset=5334,lag=1 master_replid:0f0318c25a022add7fd51d4438c470cf608631f9 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:5334 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:5334 常见问题汇总： master密码不对： 即配置的master密码不对，导致验证不通过而无法建立主从同步关系。 Redis版本不一致： 不同的redis 版本之间存在兼容性问题，因此各master和slave之间必须保持版本一致。 无法远程连接： 在开启了安全模式情况下，没有设置bind地址和密码]]></content>
      <categories>
        <category>linux服务</category>
      </categories>
      <tags>
        <tag>redis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM.virsh命令使用入门]]></title>
    <url>%2F2018%2F12%2F25%2FKVM-virsh%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[KVM-virsh命令使用入门 虚拟化技术 主机级虚拟化：infrastructure 容器级虚拟化（用户空间虚拟化即容器）：Container 内核名称空间： NET Mount PID UTS IPC User 程序级虚拟化： JVM PVM 云计算环境： SaaS：软件即服务 CaaS:容器即服务 FWaaS:防火墙即服务 LBaaS:负载均衡即服务 DBaaS:数据库即服务 IaaS:基础设施即服务 PaaS:平台即服务 虚拟主机通讯： 物理桥：主机过多，主机间交换报文发生瓶颈 隧道、叠加网络 virsh家族的虚拟机创建后，即使物理机重启了虚拟机也还在。 12345678910- 所有的虚拟机创建完成后，/etc/libvirt作为的配置文件的工作目录 [root@centos7 ~]# ls /etc/libvirt/ libvirt-admin.conf lxc.conf qemu.conf storage libvirt.conf nwfilter qemu-lockd.conf virtlockd.conf libvirtd.conf qemu secrets virtlogd.conf使用qemu+kvm创建虚拟服务时，配置文件保存在qemu文件中（每个创建的虚拟机都表现为一个.xml文件，立案包含了所有创建虚拟机的所有的相关配置） [root@centos7 vms]# ls /etc/libvirt/qemu altlinux7.0.xml 虚拟的主机中虚拟cpu核心，仅表现为宿主机中线程 virsh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122列创建的虚拟机 [root@centos7 vms]# virsh list Id Name State ---------------------------------------------------- 12 altlinux7.0 running## virsh list帮助 [root@centos7 vms]# virsh list --help OPTIONS --inactive 列出不活跃的域 --all 不活跃和活跃的域列表 --transient 列出临时域 --persistent 列出持久域 --with-snapshot 列出现有的快照的域 --without-snapshot 列出没有快照的域 --state-running 运行状态的域列表 --state-paused 列出暂停状态的域 --state-shutoff 列出关闭状态的域 --state-other 列出其他状态的域 --autostart 列出启用antostart的域 --no-autostart 列出禁用antostart的域 --with-managed-save 列出有管理的保存状态的域 --without-managed-save 列出没有管理的保存状态的域 --uuid 只列出 uuid --name 只列出域名 --table 列出表格（默认） --managed-save 标记有管理的保存状态的域 --title show domain title [root@centos7 vms]# virsh list --all Id Name State ---------------------------------------------------- 12 altlinux7.0 running [root@centos7 vms]# virsh list --name altlinux7.0查看虚拟机的详细信息（实际上看的就是此虚拟机的xml的配置文件） [root@centos7 vms]# virsh dumpxml altlinux7.0可以将查看虚拟机的详细信息保存在/etc/libvirt作为的配置文件的工作目录中，加以修改实现创建一台新的虚拟系统 [root@centos7 ~]# virsh dumpxml altlinux7.0 &gt; /etc/libvirt/qemu/c1.xml 编辑c1.xml 必须修改项（行）： 2：名字 3：删除uuid，启动自动生成 38：修改本地对应镜像文件 71：网卡MAC创建虚拟机（此实现的前提时建立在上一章kvm虚拟机基础应用的实验的，下一执行命令是在kvm服务器上） virsh help create :查看创建虚拟机并且启动的帮助 virsh help define :查看仅创建但不启动的帮助 virsh help start :查看启动的帮助 virsh define &lt;xmlfile&gt; --validate : 检查xml文件格式是否有误 启动虚拟机，并指顶xml文件 检查语法 [root@centos7 ~]# virsh define /etc/libvirt/qemu/c1.xml --validate Domain c1 defined from /etc/libvirt/qemu/c1.xml 创建 [root@centos7 ~]# virsh define /etc/libvirt/qemu/c1.xml Domain c1 defined from /etc/libvirt/qemu/c1.xml 查看是否创建成功 [root@centos7 ~]# virsh list --all Id Name State ---------------------------------------------------- 12 altlinux7.0 running - c1 shut off 启动 [root@centos7 ~]# virsh start c1 Domain c1 started [root@centos7 ~]# virsh list Id Name State ---------------------------------------------------- 12 altlinux7.0 running 13 c1 running 查看创建的虚拟机的地址 [root@centos7 ~]# virsh domifaddr c1 ## 查看virsh控制台 virsh help console 使用连接控制台连接虚拟机 [root@centos7 ~]# virsh console c1 login as 'cirros' user. default password: 'cubswin:)'. use 'sudo' for root. 退出当前连接 ctrl + ] kvm虚拟机的暂停：所有的占用内存，仍然在内存中，只是不响应任何请求。定在内存中，如果宿主机掉电，则虚拟机的所有数据将会丢失 kvm虚拟机的挂起:是将宿主机上的所有的虚拟机的使用内存抽取掉，保存成二进制文件，放在磁盘上，下次再次开启虚拟机可以将磁盘中的二进制文件读出来恢复至内存中 暂停kvm虚拟机c1 [root@centos7 vms]# virsh suspend c1 恢复kvm虚拟机c1 [root@centos7 vms]# virsh resume c1 挂起kvm虚拟机c1（建议挂起虚拟机的时候将虚拟机先暂停） [root@centos7 vms]# virsh save c1 /tmp/c1.bin --paused 取消挂起kvm虚拟机c1 [root@centos7 vms]# virsh restore /tmp/c1.bin --running 重启kvm虚拟机c1（热重启） virsh reboot c1 重启kvm虚拟机c1（冷重启,如同使用电源按钮重新设定目标） virsh reset c1 关机 virsh shutdown c1 /相当于在主虚拟机内部shutdown -0 暴力拨电，销毁虚拟机的运行状态(销毁的只是虚拟机的运行状态并非是虚拟机的系统程序文件) virsh destroy c1 删除虚拟机（取消定义一个域或者持久转换为临时） vrish undefine c1 将虚拟机设置为随宿主机启动开启 [root@centos7 vms]# virsh autostart c1]]></content>
      <categories>
        <category>linux服务</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kvm虚拟机基础应用]]></title>
    <url>%2F2018%2F12%2F25%2Fkvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[kvm虚拟机基础应用 kvm: Kernel-based Virtual Machine Qumranet公司 –&gt; RedHat (1) X86_64 (2) HVM: Intel VT AMD AMD-v KVM的组件： 两类组件： (kvm.ko)/dev/kvm：工作为hypervisor，在用户空间可通过系统调用ioctl()与内核中的kvm模块交互，从而完成虚拟机的创建、启动、停止、删除等各种管理功能； qemu-kvm进程：工作于用户空间，用于实现IO设备模拟；用于实现一个虚拟机实例； KVM模块load进内存之后，系统的运行模式： 内核模式：GuestOS执行IO类的操作时，或其它的特殊指令操作时的模式；它也被称为“Guest-Kernel”模式；用户模式：Host OS的用户空间，用于代为GuestOS发出IO请求； 来宾模式：GuestOS的用户模式；所有的非IO类请求； 运行中的一个kvm虚拟机就是一个qemu-kvm进程，运行qemu-kvm程序并传递给它合适的选项及参数即能完成虚拟机启动，终止此进程即能关闭虚拟机； 安装使用KVM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131安装kvm的主机上：判断CPU是否支持硬件虚拟化： [root@centos7 ~]# grep -i -E '(vmx|svm|lm)' /proc/cpuinfo cpu型号： vmx：Intel VT-x svm：AMD AMD-v lm:64位cpu加载kvm模块使得内核支持kvm,并判断是否成功加载此模块 [root@centos7 ~]# modprobe kvm [root@centos7 ~]# lsmod | grep kvm kvm_intel 174841 0 kvm 578518 1 kvm_intel irqbypass 13503 1 kvm [root@centos7 ~]# file /dev/kvm （字符设备） /dev/kvm: character special安装qemu-kvm,使用户空间具有控制工具 [root@centos7 ~]# yum install qemu-kvm -y [root@centos7 ~]# rpm -ql qemu-kvm /usr/libexec/qemu-kvm 命令行工具被放在了非PATH变量中，红帽防止用户手动创建虚拟主机。此工具很底层使用virt-manager管理kvm(libvirt-daemon-kvm守护进程工具 qemu-kvm virt-manager图形化工具 libvirt库) [root@centos7 ~]# yum install libvirt-daemon-kvm qemu-kvm virt-manager libvirt -y （因为已经安装图形化界面的管理工具，确保宿主机上已经安装图像化相关的库 yum groupinstall GNOME Desktop）如果宿主机上已经安装有图像化相关的库则启动libvirt守护进程 [root@centos7 ~]# systemctl start libvirtdlibvirtd安装好默认仅提供了一个net网络创建桥接网络 将物理网卡当交换及使用 将软交换机当物理网卡使用创建物理桥（交换机） [root@centos7 ~]# cd /etc/sysconfig/network-scripts/ [root@centos7 network-scripts]# cp ifcfg-ens37 ifcfg-br0配置网卡的配置文件，使br0当网卡使用，将ens37当交换机使用 [root@centos7 network-scripts]# vim ifcfg-ens37 HWADDR=00:0C:29:14:4D:6C TYPE=Ethernet BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=no NAME=ens37 DEVICE=ens37 BRIDGE=br0 ONBOOT=yes [root@centos7 network-scripts]# vim ifcfg-br0 NAME=br0 DEVICE=br0 TYPE=Bridge PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none IPADDR=172.18.135.1 PREFIX=24 GATEWAY=172.18.0.1 DNS1=8.8.8.8 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6_FAILURE_FATAL=no IPV6_PRIVACY=no ONBOOT=yes [root@centos7 network-scripts]# systemctl restart network 此时br0已经是网卡了，ens37变成了交换机 [root@centos7 network-scripts]# ifconfig br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.18.135.1 netmask 255.255.255.0 broadcast 172.18.135.255 inet6 fe80::20c:29ff:fe14:4d6c prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:14:4d:6c txqueuelen 1000 (Ethernet) RX packets 590 bytes 75531 (73.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 53 bytes 8801 (8.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:14:4d:6c txqueuelen 1000 (Ethernet) RX packets 7333 bytes 809500 (790.5 KiB) RX errors 0 dropped 2 overruns 0 frame 0 TX packets 1275 bytes 194949 (190.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0------------------------------------------------------------------------------------------------------------------------远程连接安装kvm的主机一下操作在远程连接的主机上操作 查看网卡已经多了一个virbr0b设备，次接口是libvirtd自动生成的net模式类型的接口 [root@centos7 ~]# ssh -X 安装kvm的主机地址 [root@centos7 ~]# systemctl start libvirtd [root@centos7 ~]# ifconfig br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.18.135.1 netmask 255.255.255.0 broadcast 172.18.135.255 inet6 fe80::20c:29ff:fe14:4d6c prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:14:4d:6c txqueuelen 1000 (Ethernet) RX packets 3006 bytes 1312927 (1.2 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 412 bytes 58640 (57.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:14:4d:6c txqueuelen 1000 (Ethernet) RX packets 18644 bytes 3281398 (3.1 MiB) RX errors 0 dropped 28 overruns 0 frame 0 TX packets 1827 bytes 281257 (274.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 312 bytes 32472 (31.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 312 bytes 32472 (31.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:ff:0b:1f txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0检查libvirtd程序是否启动，级运行virt-manager图形化 [root@centos7 ~]# systemctl status libvirtd [root@centos7 ~]# virt-manager 以下操作在远程远程连接的主机上使用pxe安装环境 使用本地的镜像（导入现有磁盘映像）123456789[root@centos7 ~]# lscirros-0.3.0-x86_64-disk.img[root@centos7 ~]# mkdir /vms[root@centos7 ~]# mv cirros-0.3.0-x86_64-disk.img /vms/[root@centos7 ~]# cd /vms/[root@centos7 vms]# lscirros-0.3.0-x86_64-disk.img[root@centos7 vms]# cp cirros-0.3.0-x86_64-disk.img pc1.img[root@centos7 vms]# cp cirros-0.3.0-x86_64-disk.img pc2.img 点击Browse Local本地浏览 本机客户端访问外部网络 SNAT源地址转换适用于隐藏客户端地址 主要原因是ipv4地址不够用，私网的地址在互联网没办法被路由。 本机服务端，放在互联网被客户访问。 DNET目标地址转换，仅考虑请求报文，不考虑响应报文，适用于隐藏服务端的地址]]></content>
      <categories>
        <category>linux服务</category>
      </categories>
      <tags>
        <tag>kvm虚拟机基础应用</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F22%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[企业网络架构介绍 网络: 多个终端设备 网络传输介质设备实现通讯 局域网：最小的网络、本地、公司 广域网：不通的局域网连接 城域网：比广域网小，例如：一个城市 无线网（AP） CCNA CCNP 企业网络远程互联 企业网络组网不受地域限制，可以通过各种远程互联技术把分布在不同的地域的网络的网络连接在一起 ipsu mpls vpn 专线 广域网：逻辑的层次划分 小型企业组网：扁平 大型网络组网：层次 思想： 业务 冗余 层次-安全 传输介质介绍 通讯网络除了包含通讯设备的本身之外，还包含连接这些设备的传输介质，如同线缆、双绞线、和光纤等，不同的传输介质具有不用的特征，这些特性直接影响到通讯诸多方面，如线路编码方式、传输速度和传输距离等。 路由 交换机 传输介质：连接设备的线缆 网线 光线 两个终端，用一条能承载数据传输的物理介质（也成为传输介质），连接起来，组成了一个最简单的网络。 介质 光猫：光纤设置转换为网络设备进入网络 白色：单模光纤 黄色：多模光纤 共享式网络中可能会出现信号冲突现象 CSMA/CD: 载波侦听多路访问/冲突检测技术 工作原理：先听先发，边听边发，冲突避让，等待重发。 以太网的最大包长和最小包长 最大包长1518byte,其中三层数据1500byte（称为MTU）只是一个规定而言 最小包长64byte 原因：如果A主机发送的帧很小，很快完成帧的发送，而两台冲突主机相差很远，在主机A发送的帧传输到B的前一刻，B开始发送帧，这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已经发送成功，因此必须有最小包长的限制。 两种双工模式都支持双向数据传输 冲突与：半双工模式 分层模型及以太网帧结构 不同的协议栈用于定义和管理不同的网络的数据转发规则 什么是协议 为了使数据可以在网络上从源传递到目标地址，网络上所有设备需要“讲”相同的语言 数据通讯协议的定义 决定数据的格式和传输的一组规则和一组惯例 网络通讯的过程很复杂 数据以电子信号的形式穿越介质到达正确的计算机，然后转换为最初的形式，以便接收者可以阅读 为了降低网络设计的复杂性，将协议进行了分层设计 分层设计的意义 通讯服务层的模块设计可相对独立于具有的通讯路线和通讯接口的差别 而通信服务层的模块设计又可相对独立具体用户应用的要求不同 简化了相关的网络操作，提供了不不同的厂商之间的兼容性；促进了标准化工作，结构上进行了分层；易于学习和操作 各个层次独立，一层的变化不会影响到邻层 OSI参考模型 国际标准化组织ISO于1984年提出了OSI RM 。OSI参考模型很快成了计算机网络的基础模型 OSI参考模型具有的优点：简化了相关的网络操作，提供了不同的厂商之间的兼容性；促进了标准化工作；结构上进行了分层；易于学习和操作 OSI参考模型各个层次的功能如下： 网络层：在设备之间传输比特流，规定了电平、速度和断缆针脚 数据链路层：将比特流组合成了字节，再将字节组合成帧，使用链路层地址（以太网使用MAC地址）来访问介质，并进行排差错检测 网络层：提供逻辑地址，供路由确定路径 传输层：提供面向连接或者非面向连接的数据传递以及进行排差错检测 会话层：负责建、管理和终止表示层实体之间的通讯会话。该层的通信由不同的设备中的应用程序之间的服务请求和响应组成（通信设备可能存在多个会话） 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能够被另一个系统的应用层识别（数据表、加密、图片、文档、文字） 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务 OSI层次设计的理念 建立七层模型的主要目的使为解决异种网络互连时所遇到的兼容性问题 它的优点：将服务、接口和协议这三个概念明确地区分开来 服务：某一层为上一层提供什么功能 接口：上层如何使用下层的服务 协议：如何实现本层的服务 这样各层之间具有很强的独立性，互联网络中各尸体采用什么样的协议时没有限制的，只要向上提供形同的服务并且不改变相邻层的接口就可以了]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F19%2Fnfs%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[title: ftptags: linux服务categories: NFS服务器date: top: NFS服务 NFS：Network File System 网络文件系统，基于内核的文件系统。Sun公司 开发，通过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的 文件，基于RPC（Remote Procedure Call Protocol远程过程调用）实现 RPC采用C/S模式。客户机请求程序调用进程发送一个有进程参数的调用信息 到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用 信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发 送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信 息，获得进程结果，然后调用执行继续进行 NFS优势：节省本地存储空间，将常用的数据,如home目录,存放在NFS服务 器上且可以通过网络访问，本地终端将可减少自身存储空间的使用 12345678910111213常用系统的驱动查看模块[root@centos7 ~]# locate xfs.ko/usr/lib/modules/3.10.0-862.el7.x86_64/kernel/fs/xfs/xfs.ko.xz[root@centos7 ~]# ls /usr/lib/modules/3.10.0-862.el7.x86_64/kernel/fs/binfmt_misc.ko.xz cifs ext4 gfs2 mbcache.ko.xz nls udfbtrfs cramfs fat isofs nfs overlayfs xfscachefiles dlm fscache jbd2 nfs_common pstoreceph exofs fuse lockd nfsd squashfslinux内核默认已经安装nfs文件系统，已经加载驱动模块[root@centos7 ~]# locate nfs.ko/usr/lib/modules/3.10.0-862.el7.x86_64/kernel/drivers/xen/xenfs/xenfs.ko.xz/usr/lib/modules/3.10.0-862.el7.x86_64/kernel/fs/nfs/nfs.ko.xz NFS文件系统 NFS工作原理 NFS各个版本的对比s NFS服务介绍软件包：nfs-utils（并非服务器包时文件系统即工具）Kernel支持:nfs.ko端口：2049(nfsd), 其它端口由portmap(111)分配配置文件：/etc/exports,/etc/exports.d/*.exportsCentOS7不支持同一目录同时用nfs和samba共享，因为使用锁机制不同相关软件包:rpcbind（必须rpcbind， 服务如果不可用则nfs服务也不可用），tcp_wrappersCentOS6开始portmap进程由rpcbind代替NFS服务主要进程：&ensp;&ensp;rpc.nfsd 最主要的NFS进程，管理客户端是否可登录&ensp;&ensp;rpc.mountd 挂载和卸载NFS文件系统，包括权限管理&ensp;&ensp;rpc.lockd 非必要，管理文件锁，避免同时写出错&ensp;&ensp;rpc.statd 非必要，检查文件一致性，可修复文件日志：/var/lib/nfs/ 范例：查看nfs对应的端口123456[root@centos7 ~]# rpcinfo -p program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper此服务使用的随机端口比较多，所以此服务一般不会跨网络使用，最好在局域网内使用 范例：配置防火墙，将随机端口绑死，实现跨网络12345678910配置防火墙，开放NFS服务 配置NFS使用固定端口 vim /etc/sysconfig/nfs RQUOTAD_PORT=875 LOCKD_TCPPORT=32803 LOCKD_UDPPORT=32769 MOUNTD_PORT=892 STATD_PORT=662 STATD_OUTGOING_PORT=2020 防火墙除开放上述端口，还需开放TCP和UDP的111和2049共4个端 范例：实现共享文件夹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677服务端：创建共享的目录 [root@centos7 ~]# mkdir /data/a [root@centos7 ~]# mkdir /data/b编辑服务器的配置文件（此配置配置文件是系统的基本文件，此文件可以定义共享的目录的策略） [root@centos7 ~]# rpm -qf /etc/exports setup-2.8.71-9.el7.noarch [root@centos7 ~]# vim /etc/exports （*代表所有人可以访问） /data/a * 生效配置文件（提示我们没有配置策略使用默认的配置策略，sync直接写磁盘，不放buffer） [root@centos7 ~]# exportfs -r exportfs: No options for /data/a *: suggest *(sync) to avoid warning客户端： 创建挂载点，使用服务端共享的目录进行挂载 [root@centos7 ~]# mkdir /data/nfs1 /data/nfs2 [root@centos7 ~]# showmount -e 192.168.52.179 Export list for 192.168.52.179: /data/a * 挂载指向服务端的地址 [root@centos7 ~]# mount 192.168.52.179:/data/a /data/nfs1 [root@centos7 ~]# df 192.168.52.179:/data/a 20961280 33024 20928256 1% /data/nfs1服务端在共享的目录中创建文件，客户端查看是否同步 [root@centos7 ~]# touch /data/a/a.txt [root@centos7 ~]# ls /data/nfs1/ a.txt 查看共享默认的权限：只读属性 [root@centos7 ~]# touch /data/nfs1/b.txt touch: cannot touch ‘/data/nfs1/b.txt’: Read-only file system 客户端查看挂载属性：默认使用的挂载版本为vers=4 [root@centos7 ~]# mount 192.168.52.179:/data/a on /data/nfs1 type nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=192.168.52.179,local_lock=none,addr=192.168.52.179) 客户端挂载指定版本挂载 [root@centos7 ~]# mount -o vers=3 192.168.52.179:/data/a /data/nfs1 [root@centos7 ~]# mount | tail -n1 192.168.52.179:/data/a on /data/nfs1 type nfs (rw,relatime,vers=3,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.52.179,mountvers=3,mountport=20048,mountproto=udp,local_lock=none,addr=192.168.52.179)服务端修改挂载的目录权限 [root@centos7 ~]# vim /etc/exports /data/a *(sync,ro) 同步，只读 /data/b *(rw) 可读可写 生效并查看权限 [root@centos7 ~]# exportfs -r [root@centos7 ~]# exportfs -v （root_squash压榨root权限 no_all_squash普通用户不压榨） /data/a &lt;world&gt;(ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) /data/b &lt;world&gt;(rw,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash)客户端挂载:挂载也是有读写权限的但是还是不可以创建文件 [root@centos7 ~]# mkdir /data/nfs2/ [root@centos7 ~]# mount 192.168.52.179:/data/b /data/nfs2/ [root@centos7 ~]# touch /data/nfs2/a.txt touch: cannot touch ‘/data/nfs2/a.txt’: Permission denied 因为客户端访问服务端的共享目录的身份默认的是以nfsnoboby身份服务端授权设置acl [root@centos7 ~]# setfacl -m u:nfsnobody:rwx /data/b/客户端测试 [root@centos7 ~]# touch /data/nfs2/a.txt [root@centos7 ~]# ll !$ ll /data/nfs2/a.txt -rw-r--r--. 1 nfsnobody nfsnobody 0 Dec 19 20:17 /data/nfs2/a.tx客户端使用客户端的普通用户，在服务端共享的目录中创建文件显示权限不足（因为客户端创建的用户为普通用户，如果有同名用户则显示相同的用户，如果没有则显示客户端的用户的id）(映射成id相同的人，普通用户不压榨) 导出的文件系统的格式：&ensp;&ensp;/dir 主机1(opt1,opt2) 主机2(opt1,opt2)… #开始为注释 主机格式：&ensp;&ensp;/单个主机：ipv4，ipv6，FQDN&ensp;&ensp;/IP networks：两种掩码格式均支持&ensp;&ensp;/&ensp;&ensp;/172.18.0.0/255.255.0.0&ensp;&ensp;/&ensp;&ensp;/172.18.0.0/16&ensp;&ensp;/wildcards：主机名通配，例如.magedu.com，IP不可以&ensp;&ensp;/netgroups：NIS域的主机组，@group_name&ensp;&ensp;/anonymous：表示使用通配所有客户端 nfs配置文件每个条目指定目录导出到的哪些主机，及相关的权限和选项&ensp;&ensp;默认选项：(ro,sync,root_squash,no_all_squash)&ensp;&ensp;ro,rw 只读和读写 • async 异步，数据变化后不立即写磁盘，性能高&ensp;&ensp;sync（1.0.0后为默认）同步，数据在请求时立即写入共享&ensp;&ensp;no_all_squash （默认）保留共享文件的UID和GID&ensp;&ensp;all_squash 所有远程用户(包括root)都变成nfsnobody&ensp;&ensp;root_squash （默认）远程root映射为nfsnobody,UID为65534，早期版本 是4294967294 (nfsnobody)&ensp;&ensp;no_root_squash 远程root映射成root用户&ensp;&ensp;anonuid和anongid 指明匿名用户映射为特定用户UID和组GID，而非 nfsnobody,可配合all_squash使用 1234567不压榨远程root用户的权限 [root@centos7 ~]# vim /etc/exports /data/a *(sync,ro) /data/b *(rw,no_root_squash) [root@centos7 ~]# exportfs -v /data/a &lt;world&gt;(ro,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) /data/b &lt;world&gt;(rw,sync,wdelay,hide,no_subtree_check,sec=sys,secure,root_squash,no_all_squash) NFS工具rpcinfo&ensp;&ensp;rpcinfo -p hostname&ensp;&ensp;rpcinfo –s hostname 查看RPC注册程序 exportfs&ensp;&ensp;–v 查看本机所有NFS共享&ensp;&ensp;–r 重读配置文件，并共享目录&ensp;&ensp;–a 输出本机所有共享&ensp;&ensp;–au 停止本机所有共享 showmount -e hostnamemount.nfs 挂载工具NFSv4支持通过挂载NFS服务器的共享“根”，从而浏览NFS服务器上的共享 目录列表&ensp;&ensp;mount nfsserver:/ /mnt/nfs 客户端NFS挂载基于安全考虑，建议使用nosuid,nodev,noexec挂载选项NFS相关的挂载选项：&ensp;&ensp;fg（默认）前台挂载，bg后台挂载&ensp;&ensp;hard（默认）持续请求，soft 非持续请求&ensp;&ensp;intr 和hard配合，请求可中断&ensp;&ensp;rsize和wsize 一次读和写数据最大字节数，rsize=32768&ensp;&ensp;_netdev 无网络不挂载示例：&ensp;&ensp;mount -o rw,nosuid,fg,hard,intr 172.16.0.1:/testdir /mnt/nfs/开机挂载:/etc/fstab&ensp;&ensp;172.16.0.1:/public /mnt/nfs nfs defaults 0 0 自动挂载可使用autofs按需要挂载NFS共享，在空闲时自动卸载由autofs包提供系统管理器指定由/etc/auto.master自动挂载器守护进程控制的挂载点自动挂载监视器访问这些目录并按要求挂载文件系统文件系统在失活的指定间隔5分钟后会自动卸载为所有导出到网络中的NFS启用特殊匹配 -host 至“browse”参看帮助：man 5 autofs支持含通配符的目录名&ensp;&ensp;* server:/export/&amp; 直接匹配直接匹配包括绝对路径名称不会影响本地目录结构示例：&ensp;&ensp;/etc/auto.master:&ensp;&ensp;/- /etc/auto.direct &ensp;&ensp;/etc/auto.direct:&ensp;&ensp;/foo server1:/export/foo&ensp;&ensp;/user/local/ server1:/usr/local]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux防火墙]]></title>
    <url>%2F2018%2F03%2F06%2Flinux%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[linux防火墙 本章内容安全技术 入侵检测与管理系统（Intrusion Detection Systems）：特点是不阻断任何网络 访问，量化、定位来自内外网络的威胁情况，主要以提供报告和事后监督为主， 提供有针对性的指导措施和安全决策依据。一般采用旁路部署方式 入侵防御系统（Intrusion Prevention System）：以透明模式工作，分析数据包 的内容如：溢出攻击、拒绝服务攻击、木马、蠕虫、系统漏洞等进行准确的分析 判断，在判定为攻击行为后立即予以阻断，主动而有效的保护网络的安全，一般 采用在线部署方式 防火墙（ FireWall ）：隔离功能，工作在网络或主机边缘，对进出网络或主机的 数据包基于一定的规则检查，并在匹配某规则时由规则定义的行为进行处理的一 组功能的组件，基本上的实现都是默认情况下关闭所有的通过型访问，只开放允 许访问的策略(防范非授权网络) linux操作系统的空间：内核空间和用户空间端口：进程地址 防火墙的分类防火墙的分类 主机防火墙：服务范围为当前主机 网络防火墙：服务范围为防火墙一侧的局域网 硬件防火墙：在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件 实现，Checkpoint,NetScreen 软件防火墙：运行于通用硬件平台之上的防火墙的应用软件 网络层防火墙：OSI模型下四层 应用层防火墙/代理服务器：代理网关，OSI模型七层 网络型防火墙网络层防火墙 包过滤防火墙 网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制 列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议 状态等因素，或他们的组合来确定是否允许该数据包通过 优点：对用户来说透明，处理速度快且易于维护 缺点：无法检查应用层数据，如病毒等 应用层防火墙应用层防火墙/代理服务型防火墙（Proxy Service） 将所有跨越防火墙的网络通信链路分为两段 内外网用户的访问都是通过代理服务器上的“链接”来实现 优点：在应用层对数据进行检查，比较安全 缺点：增加防火墙的负载 现实生产环境中所使用的防火墙一般都是二者结合体&ensp;&ensp;即先检查网络数据，通过之后再送到应用层去检查 iptables的基本认识Netfilter组件&ensp;&ensp;内核空间，集成在linux内核中&ensp;&ensp;扩展各种网络服务的结构化底层框架&ensp;&ensp;内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、 FORWARD、PREROUTING、POSTROUTING)，而这五个hook function 向用户开放，用户可以通过一个命令工具（iptables）向其写入规则&ensp;&ensp;由信息过滤表（table）组成，包含控制IP包处理的规则集（rules），规则 被分组放在链（chain）上 三种报文流向：netfilter内核级别的框架，，人是不可和内核打交道，使用用户空间的工具iptables，规则编辑器，内核级的系统级别netfilter的调用接口，将写的规则送到内核中的钩子hook上直接生效，直接送到内存中，说明主机关机则规则就没有了，所以想永久生效，可以放在内核启动时初始化时读取到的文件中，或者在或者启动完后，自动执行某个命令或者启动某个服务来调用（即刻生效，但是不会永久有效）路由前：PREROUTING流入：INPUT流出：OUTPUT转发：FORWARD路由后：POSTROUTING &ensp;&ensp;流入本机：PREROUTING --&gt; INPUT--&gt;用户空间进程&ensp;&ensp;流出本机：用户空间进程 --&gt;OUTPUT--&gt; POSTROUTING&ensp;&ensp;转发：PREROUTING --&gt; FORWARD --&gt; POSTROUTING linux早期没有防火墙的，仿照unix的发行版的OpenBSD，著名的以安全为目标的发行版OpenBSD：纯软件，内核级只负责传输层一下级检测实现，进行工作和防护 定制防火墙规则：黑名单、白名单&ensp;&ensp;黑名单适用于知道改拒绝谁&ensp;&ensp;百名单高效的仅授权可以连接的 iptables的基本认识防火墙工具iptables&ensp;&ensp;命令行工具，工作在用户空间&ensp;&ensp;用来编写规则，写好的规则被送往netfilter，告诉内核如何去处理信息包 firewalld&ensp;&ensp;CentOS 7 引入了新的前端管理工具&ensp;&ensp;管理工具：&ensp;&ensp;&ensp;&ensp;firewall-cmd 命令行&ensp;&ensp;&ensp;&ensp;firewall-config 图形 历史ipfw -&gt; ipchains -&gt; iptables -&gt; nftables(rhel8) 主机级别防火墙：INPUT---OUTPUTS网络级别防火墙：FROWARD NAT：网络地址转换 iptables： 四个功能：table filter:过滤 nat:地址转换 mangle:报文修改，fwmark raw:关闭连接追踪 Centos：使用iptables的方式 netfilter:内核框架（framework） syscall:系统调用接口，iptables命令行工具，管理规则（服务化的管理工具） firewalld:守护进程，firewall-cmd(默认安装，但是尽量不使用) 禁用firewalld123456[root@centos7 ~]# systemctl stop firewalld[root@centos7 ~]# systemctl disable firewalldRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@centos7 ~]# systemctl is-enabled firewallddisabled 报文流向： 到本机内部：prerouting–&gt;input 由本机发现：output–&gt;postrouting 转发：prerouting –&gt;forward–&gt;postrouting tables&lt;--&gt;CHANS链: filter: INPUT,PORWARD,OUTPUT nat: PREROUTING,INPUT,OUTPUT,POSTROUTING mangle: PREROUTING,INPUT,FOREARD,OUTPUT,POSTROUIING raw: PREROUTING,OUTPUT 查看各表中的链的规则：123456789[root@centos7 ~]# iptables -t filter -nLChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Netfilter表和链对应的关系 数据包过滤匹配流程 命令的使用格式123456789101112131415161718192021222324252627282930SYNOPSIS iptables [-t table] &#123;-A|-C|-D&#125; chain rule-specification ip6tables [-t table] &#123;-A|-C|-D&#125; chain rule-specification iptables [-t table] -I chain [rulenum] rule-specifica‐ tion iptables [-t table] -R chain rulenum rule-specification iptables [-t table] -D chain rulenum iptables [-t table] -S [chain [rulenum]] iptables [-t table] &#123;-F|-L|-Z&#125; [chain [rulenum]] [options...] iptables [-t table] -N chain iptables [-t table] -X [chain] iptables [-t table] -P chain target iptables [-t table] -E old-chain-name new-chain-name rule-specification = [matches...] [target] match = -m matchname [per-match-options] target = -j targetname [per-target-options] iptables [-t tables,如果不指定则代表使用默认的filter] SUBCMMAND子命令 chain [rulenum规则号码] [rule-spce] rule-specification=[matches匹配条件][-j target处理动作] CRUD:增删改查（指定多个规则隐含的是与关系，符合所有的条件才是满足定义的条件的） 子命令： 管理规则： -A ：append,尾部追加 -I ：inset,插入 -D ：删除 -R ：替换 管理链 -N ：new,新增加一条链 -X : 删除一条自定义、空的，不可有规则、引用计数为0的链 -E : rename 改自定义引用技术为0的链 -P ： policy,设置链的默认策略 -F ： flush,清空 -Z ： zero,置零，计数器归零 iptables的每条规则和每个链都有专用的两个计数器：pkts规则匹配到的报个数计数器，bytes报文体积计数器kbytes 查看 -L -n : 以数字显示主机的地址和端口 -v : -vv : 显示详细的信息 -x : exact，避免单位的换算显示精准的信息 –line-numbers : 显示行号 链 内置链 自定义链 匹配条件 检查报文 TCP或UDP首部：源端口，目标端口 FSM:有限状态机 IP首部：sip,dip（源ip和目标ip） MAC首部:MAC地址 匹配条件 通用匹配 [!] -s,–sip,–spurce-ip:报文的源地址,其值可以是ip或者是网络地址，不可使离散的网络（!为取反） [!] -d,–dip,–destination:报文的目标地址 -i,–in-interface : 表示从哪个网卡进入（PREROUTING，INPUT,FORWARD） -o,–out-interface : 表示从哪个网卡出去(,OUTPUT,POSTRUTING,FORWARD) -p protocol:四层协议，tcp,udp,icmp 扩展匹配 隐式扩展 -p tcp :隐含 -m tcp [!] –source-port ,–sport port [:port] : 匹配报文中的传输层的源端口,连续的端口范围，22，21：22 [!] –destination-port ,–dport poet [:port] :匹配报文中传输层的目标端口 [!] –tcp-flags mask comp SYN,ACK,RST,，FIN,URG,PSH mask:需要检查的标志位列表，以逗号分隔； comp:必须为1的标志列表，余下的出现在mask列表中的标志位则必须为0 范例:-tcp-flags SYN,ACK,FIN,RST SYN 表示检查报文tcp首部，syn为1，其余的为0，代表只检查源报文来的第一次握手 [!] –syn : tcp发送报文三次握手的第一次（相当于：–tcp-flags SYN,SCK,FINRST SYN） -p udp : 隐含了-m udp: [!] –source-port ,–sport port[:port] :匹配报文中传输层的源端口 [!] –destination-port,–dport port[:port] :匹配报文中传输层的目标端口 -p icmp(互联网控制协议) ： 隐含了-m udp: [!] –lcmp-type {type[/code]|typename} 8 : echo-request回显请求 0 : echo-reply 回显应答 显示扩展 ； 必须使用-m选项指出matchname(模块),有的match可能存在专用的选项 1.matchname扩展 以离散的或连续的方式定义多端口匹配条件 [!] –source-ports,–sports port[,port|,port:port]…:指定多个源端口,逗号隔开最多制定15个 [!] –destnation-ports,–dports port[,port|,port:port]…:制定多个目标端口 [!] –ports port[,port|,port:port]…:指定多个端口 2.iprange扩展 以连续的ip地址范围指明连续的多地址匹配条件 3.set扩展 依赖于ipset命令行工具 set存在的类型： hash:net : 网络地址的集合 hash:ip ：目标ip地址 使用方式： 先创建集合 ：ipset create NAMETYPE 向集合中添加元素 ：ipset add NAMETYPE 4.string扩展 对报文的应用层数据做字符串匹配检测 [!] –string pattern : 要检测的字符串模式 [!] –hex-string pattern : 要检测的字符串模式，16进制编码 –algo {bm|kmp} 5.time扩展 根据报文到达的时间与指定的时间范围进行匹配度检测 –datestart YYYY[-MM[-DD]Thh[:mm]:ss]]]]] : 起始日期时间 –datestop YYYY[-MM[-DD]Thh[:mm]:ss]]]]] : 结束日期时间 –timestart hh:mm[:ss] –timestop hh:mm[:ss] [!] –monthdays day[,day…] ： 每月几号的时间 [!] –weekdays day[,day…] ： 每周几的时间 –kerneltz : 使用内核中的配置的时区 6、connlimit扩展 根据每客户端IP做并发连接数匹配； –connlimit-upto n：连接数数量小于等于n，此时应该允许； –connlimit-above n：连接数数量大于n，此时应该拒绝； ~]# iptables -A INPUT -d 172.16.100.67 -p tcp –dport 23 -m connlimit –connlimit-upto 2 -j ACCEPT 7、limit扩展 基于收发报文的速率进行匹配； –limit rate[/second|/minute|/hour|/day]：平均速率 –limit-burst number：峰值速率 8、state扩展 状态检测；连接追踪机制（conntrack）； INVALID：无法识别的状态； ESTABLISHED：已建立的连接； NEW：新连接； RELATED：相关联的连接； UNTRACKED：未追踪的连接； nf_conntrack内核模块； 追踪到的连接：/proc/net/nf_conntrack文件中； 能追踪的最大连接数量定义在：/proc/sys/net/nf_conntrack_max 此值可自行定义，建议必要时调整到足够大； 不同的协议的连接追踪的时长： /proc/sys/net/netfilter/ [!] –state STATE 如何开放被模式的ftp服务： (1) 装载追踪ftp协议的模块； # modprobe nf_conntrack_ftp - (2) 放行命令连接 - ~] # iptables -A INPUT -d 172.16.100.67 -p tcp -m state --state ESTABLISHED -j ACCEPT - ~] # iptables -A INPUT -d 172.16.100.67 -p tcp --dport 21 -m state --state NEW -j ACCEPT - (3) 放行数据连接 - ~] iptables -A INPUT -d 172.16.100.67 -p tcp -m state --state RELATED -j ACCEPT 处理动作target DROP : 丢弃 REJECT : 拒绝 ACCEPT : 接受 RETURN : 无匹配的链的时候自动调回 REDIRECT : 重定向 SANT : 源地址转换 DNAT: 目标地址转换 MASQUERADE : 地址伪装 LOG : 日志 自定义链 管理机制 ： 两不兼容，最好不要并行 firewalld : firewalld-cmd iptables ： iptables-save,iptables-restore yum install iptables-services1234567891011每一个内核就是一个扩展 xt开头[root@centos7 ~]# cd /lib/modules/3.10.0-862.el7.x86_64/kernel/net/netfilter/[root@centos7 netfilter]# lsipset xt_connlimit.ko.xzipvs xt_connmark.ko.xznf_conntrack_amanda.ko.xz xt_CONNSECMARK.ko.xznf_conntrack_broadcast.ko.xz xt_conntrack.ko.xznf_conntrack_ftp.ko.xz xt_cpu.ko.xznf_conntrack_h323.ko.xz xt_CT.ko.xznf_conntrack_irc.ko.xz xt_dccp.ko.xznf_conntrack.ko.xz xt_devgroup.ko.xz 1234567891011121314151617181920212223242526272829查看某表中的规则[root@centos7 ~]# iptables -t filter -vnL将某表中的INPUT链计数器置零[root@centos7 ~]# iptables -t filter -Z INPUT规则显示详情[root@centos7 ~]# iptables -t filter -vnL pkts(报文数) bytes(字节数) target（目标） prot（协议） opt（选项） in（报文流入的接口） out（报文流出的接口） source（源地址） destination（目标地址） 显示iptables表的本文和自己的精确的显示以及行号的显示[root@centos7 ~]# iptables -t filter -vxnL --line-numbers-N 自定义规则链（见名知意）[root@centos7 ~]# iptables -N web_rules[root@centos7 ~]# iptables -vnLChain web_rules (0 references) 0个引用 pkts bytes target prot opt in out source destination -E 修改自定义的规则链名称（改名通常适用于修改自定义规则连0引用的规则链）[root@centos7 ~]# iptables -E web_rules cifs_rules-X 删除自定义的规则链：计数为0，若不为0 可以将主链中的调用删除再进行清空删除[root@centos7 ~]# iptables -F cifs_rules[root@centos7 ~]# iptables -X cifs_rules内部规则： Chain OUTPUT (policy ACCEPT 1 packets, 356 bytes)具有规则链和接收器 范例：使得iptables定义的规则永久有效12345678命令：内核中定义的规则标准输出至屏幕 [root@centos7 ~]# iptables-save 将标准的输入重定向到文件中 [root@centos7 ~]# iptables-save &gt; /data/iptables.txt 模拟清空防火墙规则 [root@centos7 ~]# iptables -F 还原防火墙的规则 [root@centos7 ~]# iptables-restore /data/iptables.txt 范例：如何将定义的防火墙规则开机自动生效123456yum install iptables-services -y服务方式管理的iptables[root@centos7 ~]# /usr/libexec/iptables/iptables.init restrtUsage: iptables &#123;start|stop|reload|restart|condrestart|status|panic|save&#125; 显示扩展1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461：multiport显示扩展：匹配多个源、目标端口 定义入栈规则 [root@centos7 ~]# iptables -I INPUT -p tcp -m multiport --dports 21:22,80,139,445 定义出栈规则 [root@centos7 ~]# iptables -I OUTPUT -p tcp -m multiport --sports 21:22,80,139,445 删除入栈规则的第#条 [root@centos7 ~]# iptables -D INPUT #2：iprange扩展：匹配ip地址的连续范围（仅开放给有限的地址去怕ping） 入栈 [root@centos7 ~]# iptables -I INPUT 4 -p icmp --icmp-type 8 -m iprange --src-range 192.168.10.10-192.168.10.20 -j ACCEPT 出栈 [root@centos7 ~]# iptables -I OUTPUT 4 -p icmp --icmp-type 0 -m iprange --dst-range 192.168.10.10-192.168.10.20 -j ACCEPT3：set扩展:非连续的ip地址，人为定义ip地址集后续调用 安装 [root@centos7 ~]# yum install ipset -y 查看帮助用法 ipset -h 创建集合ip哈希表 [root@centos7 ~]# ipset create pinghosts hash:ip (如果为多个网段hash:net) [root@centos7 ~]# ipset list Name: pinghosts Type: hash:ip Revision: 1 Header: family inet hashsize 1024 maxelem 65536 Size in memory: 16528 References: 0 Members: 向集合中添加允许的主机地址 [root@centos7 ~]# ipset add pinghosts 192.168.10.10 [root@centos7 ~]# ipset add pinghosts 192.168.10.20 [root@centos7 ~]# ipset list Name: pinghosts Type: hash:ip Revision: 1 Header: family inet hashsize 1024 maxelem 65536 Size in memory: 16560 References: 0 Members: 192.168.10.20 192.168.10.10 设置规则允许集合表中的主机对本机进行ping 入栈 [root@centos7 ~]# iptables -I INPUT 4 -p icmp --icmp-type 8 -m set --match-set pinghosts src -j ACCEPT 出栈 [root@centos7 ~]# iptables -I OUTPUT 4 -p icmp --icmp-type 0 -m set --match-set pinghosts dst -j ACCEPT [root@centos7 ~]# iptables -vnL4：string扩展：对报文的应用层数据做字符串匹配检测 假设web网页中的敏感字体进行字符串匹配检测 入栈 [root@centos7 ~]# iptables -I INPUT -m string --string "敏感字" --algo bm -j REJECT 出栈 [root@centos7 ~]# iptables -I OUTPUT -m srting --string "敏感字" --algo bm -j REJECT多个扩展可一起使用，与的关系，满足所有的条件time扩展 ： 根据报文到达的时间与指定的时间范围进行匹配度检测 [root@centos7 ~]# iptables -I INPUT 5 -p icmp --icmp-type 8 -m set --match-set pinghosts src -m time --timestart 08:00:00 --timestop 14:00:00 --weekdays Tue,Thu,Sat --kerneltz -j ACCEPT5：connlimit扩展：并发连接数限制 根据每个客户端ip做并发连接数数量匹配，可防止CC攻击。 --connlimit-upto # :连接的数量小于等于#时匹配 --connlimit-above # : 连接的数量大于#时匹配 通常分别与默认的拒绝或允许策略配合使用（默认的意思并非默认规则，而是定义的规则已经有允许，在此基础上做连接数量限制，定义在已经有的允许的规则之前） 限制ssh连接本机的连接数限制 [root@centos7 ~]# iptables -I INPUT 2 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT6：limit扩展 基于收发报文的速度做匹配(报文传输速率限制) 令牌桶过滤器 --limit # [/second|/minute|/hour|/day] --limit-burst number 允许别人ping自己仅能按照特定的速率进行ping 出去的速率无需控制，仅控制本机进来的速率 限制ping速率为每3秒钟一个，限制突发速率为5个 [root@centos7 ~]# iptables -I INPUT -p icmp --icmmp-type 8 -s 192.168.52.177 -d 192.168.52.182 -m limit --limit 20/minute --limit-burst 5 -j ACCEPT7：state状态扩展 根据“连续追踪机制”去检查连接的状态，较消耗资源 - conntrack机制：追踪本机上的请求和响应之间的关系 状态有如下几种： - NEW：新发出的请求，连接追踪信息库中不存在此链接的相关信息条目，因此，将其识别为第一次触发的请求（新人） - ESTABLISHED:NEW状态之后，连接追踪信息库中为其建立的条目失效之前期间内所进行的通讯状态（熟人） - RELATED:新发起的但与已有连接相关的连接，如：ftp协议中的数据连接与命令连接之间的关系（熟人的熟人） - INVALID:无效的连接，如flag标记不正确（识别不出的连接） - UNTRACKED:未进行的追踪的连接，如raw表中关闭追踪（未追踪的） - SNAT:源地址转换 - DNAT:目标地址转换 示例： iptables -A INPUT -d 172.16.1.10 -p tcp -m multiport --dports 22,80 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -s 172.16.1.10 -p tcp -m multiport --sports 22,80 -m state --state ESTABLISHED -j ACCEPT 已经追踪到的并记录下来的连接信息库 /proc/net/nf_conntrack 调整连接追踪功能所能够容纳的最大连接数量 /proc/sys/net/nf_conntrack_max 永久生效修改的所能够容纳的最大的连接数量 [root@centos7 ~]# vim /etc/sysctl.d/nf_conntrack_max.conf net.nf_conntrack_max = 10000000 [root@centos7 ~]# sysctl -p /etc/sysctl.d/nf_conntrack_max.conf net.nf_conntrack_max = 100000 [root@centos7 ~]# cat /proc/sys/net/nf_conntrack_max 100000 不同的协议的连接追踪时长 /proc/sys/net/netfilter/ 注意：CentOS7 需要加载模块： modprobe nf_conntrack范例： 允许所有已经连结果的请求入栈出栈 [root@centos7 ~]# iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT [root@centos7 ~]# iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT [root@centos7 ~]# iptables -A INPUT -p tcp -m multiport --dports 21:22,80 -m state --state NEW -j ACCEPT [root@centos7 ~]# iptables -A OUTPUT ! -i lo -j REJECT [root@centos7 ~]# iptables -A OUTPUT ! -o lo -j REJECT 服务端开放客户端ftp服务，客户端主动访问服务端，服务端数据端口为随机端口，在客户端添加规则 [root@centos7 ~]# iptables -I INPUT 2 -p tcp -m state --state RELATED -j ACCEPT 实现ftp RELATED 需要手动载入一个模块 [root@centos7 ~]# modprobe nf_conntrack [root@centos7 ~]# modinfo nf_conntrack [root@centos7 ~]# lsmod | grep nf_conntrack 手动载入的模块，重启后失效，大量的ftp服务就会被肆意的放行，如何让ftp连接状态iptabless开机继续生效（自动装入模块） 方法1： [root@centos7 ~]# vim /etc/sysconfig/iptables-config 第六行 IPTABLES_MODULES="nf-conntrack_ftp" 方法2： [root@centos7 ~]# vim /etc/sysconfig/modules/nf_conntrack.mudules #!/bin/bash /sbin/modprobe nf_conntrack_ftp [root@centos7 ~]# chmod +x /etc/sysconfig/modules/nf_conntrack.mudules 前提是已经安装启动iptables.services [root@centos7 ~]# systemctl restart iptables [root@centos7 ~]# systemctl enable iptables]]></content>
      <categories>
        <category>iptables防火墙</category>
      </categories>
      <tags>
        <tag>iptables防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧事-大好河山]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%97%A7%E4%BA%8B-%E5%A4%A7%E5%A5%BD%E6%B2%B3%E5%B1%B1%2F</url>
    <content type="text"><![CDATA[输入密码,PC:Enter查看,Phone:输入法换行查看. U2FsdGVkX19F7L18S04TB5sOUaeBPCIgzPsT8GsAoUrVmrHXgMkhPXfNGtsNb/NwcnlkhuqdShPDuHTNNxA0woYmEukdfyKGzdWmHjeemFmAe6279Uj1UBP0m12IhtV4EW7E6QdhZ37P3PWtsMqQqNVBljERH5lnzMxQ3oWK+BWsdezwMq96NBnfVH2Sf4YKsUAVPbAoHT3OFbfOLcNoKYqhDLlCmQDLRm/1QrxFvuhXpVygoGqZEGN+thhV/FoG1vPyEg3xPZQrlZ52PP6wMPEO4IQCPpucaJkQIWQ/Bhj8fGr77X9Sr6NZB8i9JsfiLIVP3VW1FB2oKTkKn1I91nPuOHaISDe23MbxbofG0jjrCRGI7TkiEdKTIe3RhhrA]]></content>
      <categories>
        <category>旧事，杂记</category>
      </categories>
      <tags>
        <tag>旧事，杂记</tag>
      </tags>
  </entry>
</search>
