<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dai zhe&#39;s notes</title>
  
  <subtitle>Just Du It</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://9527dz.top/"/>
  <updated>2019-01-13T02:52:37.711Z</updated>
  <id>https://9527dz.top/</id>
  
  <author>
    <name>哆啦A梦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx的http_upstream模块</title>
    <link href="https://9527dz.top/2019/01/12/nginx%E7%9A%84http-upstream%E6%A8%A1%E5%9D%97/"/>
    <id>https://9527dz.top/2019/01/12/nginx的http-upstream模块/</id>
    <published>2019-01-12T09:12:35.590Z</published>
    <updated>2019-01-13T02:52:37.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx的http-upstream模块"><a href="#nginx的http-upstream模块" class="headerlink" title="nginx的http_upstream模块"></a>nginx的http_upstream模块</h1><p><img src="nginx的http-upstream模块/图标.png" alt=""><br><a id="more"></a></p><h2 id="nginx的http-upstream模块-1"><a href="#nginx的http-upstream模块-1" class="headerlink" title="nginx的http_upstream模块"></a>nginx的http_upstream模块</h2><ul><li><p>我们知道单台服务器的性能是有上限的，当流量很大时，就需要使用多台服务器来共同提供服务，这就是所谓的集群。</p></li><li><p>负载均衡服务器，就是用来把经过它的流量，按照某种方法，分配到集群中的各台服务器上。这样一来不仅可以承担</p></li><li><p>更大的流量、降低服务的延迟，还可以避免单点故障造成服务不可用。一般的反向代理服务器，都具备负载均衡的功能。</p></li><li><p>负载均衡功能可以由硬件来提供，比如以前的F5设备。也可以由软件来提供，LVS可以提供四层的负载均衡(利用IP和端口)，</p></li><li><p>Haproxy和Nginx可以提供七层的负载均衡(利用应用层信息)。</p></li></ul><pre><code>硬件：F5 BigIP, Citrix NetScaler, A10 A10软件：    四层调度：lvs, nginx(stream module), haproxy(mode tcp)    七层调度：nginx(http_upstream module), haproxy(mode http), httpd, ats, ...        mysql: Proxy_SQL, ...        ... ...session sticky：会话粘滞    Source IP: sh, persistence    Cookie：session replication：session server：</code></pre><hr><h3 id="ngx-http-upstream-module"><a href="#ngx-http-upstream-module" class="headerlink" title="ngx_http_upstream_module"></a><code>ngx_http_upstream_module</code></h3><ul><li>参考文档：<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_upstream_module.html</a></li><li>ngx_http_upstream_module模块用于定义可以由proxy_pass、fastcgi_pass、uwsgi_pass、scgi_pass和memcached_pass指令引用的服务器组。        </li><li><p><code>(1) upstream name { ... }</code></p><ul><li>定义后端服务器组；引入一个新的上下文；只能用于http{}上下文中；<ul><li>默认的调度方法是wrr；</li></ul></li></ul></li><li><p><code>(2) server address [parameters];</code></p><ul><li>定义服务器地址和相关的参数；</li><li>地址格式：<ul><li>IP[:PORT]</li><li>HOSTNAME[:PORT]</li><li>unix:/PATH/TO/SOME_SOCK_FILE<ul><li>参数：<ul><li>weight=number<ul><li>权重，默认为1；</li></ul></li><li>max_fails=number<ul><li>失败尝试的最大次数；</li></ul></li><li>fail_timeout=time<ul><li>设置服务器为不可用状态的超时时长，默认为10秒；</li></ul></li><li>backup<ul><li>把服务器标记为“备用”状态（sory server 只有所有的服务器全部没办法工作时才会上线）； </li></ul></li><li>down<ul><li>手动标记其为不可用；</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 172.18.135.2 weight=2 backup max_fails=10m;</span><br></pre></td></tr></table></figure><ul><li><p>(3) least_conn;</p><ul><li>最少连接调度算法； 当server拥有不同的权重时为wlc；当所有后端主机的连接数相同时，则使用wrr进行调度；</li></ul></li><li><p>(4) ip_hash;</p><ul><li>源地址hash算法；能够将来自同一个源IP地址的请求始终发往同一个upstream server；</li></ul></li><li>(5) hash key [consistent];<ul><li>基于指定的key的hash表实现请求调度，此处的key可以文本、变量或二者的组合；<ul><li>consistent：参数，指定使用一致性hash算法；<ul><li>示例：<ul><li>hash $request_uri consistent<ul><li>hash $remote_addr</li><li>hash $cookie_name</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>(6) keepalive connections;<ul><li>可使用长连接的连接数量；每worker与后端服务保持的最大空闲长连接数量；</li></ul></li></ul><hr><h3 id="范例：实现nginx调度"><a href="#范例：实现nginx调度" class="headerlink" title="范例：实现nginx调度"></a><code>范例：实现nginx调度</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">三台主机</span><br><span class="line">  client</span><br><span class="line">  nginx_stream_server :yum install nginx -y</span><br><span class="line">  web_server1 :yum install httpd -y</span><br><span class="line">  web_server2 :yum install httpd -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置两台web_server的页面文件</span><br><span class="line">  <span class="comment">#为了达到负载均衡的web_server网页文件应该是相同的，这里为了演示调度器调度的差别有意的是web_server的网页文件设置有差别</span></span><br><span class="line">  web_server1</span><br><span class="line">  ~]<span class="comment"># echo "web_server1" &gt; /var/www/html/index.html</span></span><br><span class="line"></span><br><span class="line">  web_server2</span><br><span class="line">  ~]<span class="comment"># echo "web_server2" &gt; /var/www/html/index.html</span></span><br><span class="line"></span><br><span class="line">编辑nginx实现负载均衡</span><br><span class="line">  <span class="comment">#在原http配置</span></span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;  <span class="comment">#仅能在http上下文使用</span></span><br><span class="line">        upstream staticwebsrvs &#123;  <span class="comment">#定义后端服务器组</span></span><br><span class="line">        server 172.18.135.2;  <span class="comment">#web_server1</span></span><br><span class="line">        server 172.18.135.5;  <span class="comment">#web_server2</span></span><br><span class="line">        &#125;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">#server中调用服务器组名称</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">client客户端测试</span><br><span class="line"><span class="comment">#默认1:1轮询算法,支持加权轮询（Round-Robin）</span></span><br><span class="line">  ~]<span class="comment"># while true; do curl http://172.18.135.1:8080; sleep 1;done</span></span><br><span class="line">  web_server1</span><br><span class="line">  web_server2</span><br><span class="line">  web_server1</span><br><span class="line">  web_server2</span><br></pre></td></tr></table></figure><hr><h4 id="算法：使用加权轮询（wrr）"><a href="#算法：使用加权轮询（wrr）" class="headerlink" title="算法：使用加权轮询（wrr）"></a><code>算法：使用加权轮询（wrr）</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用加权轮询(默认权重都为1)</span><br><span class="line">  编辑nginx实现负载均衡</span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;</span><br><span class="line">        upstream staticwebsrvs &#123;</span><br><span class="line">        server 172.18.135.2 weight=2; <span class="comment">#将web_server1设置权重比为2</span></span><br><span class="line">        server 172.18.135.5;</span><br><span class="line">  &#125;</span><br><span class="line">    ....</span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">lient客户端测试</span><br><span class="line">  ~]<span class="comment"># while true; do curl http://172.18.135.1:8080; sleep 1;done</span></span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server2</span><br></pre></td></tr></table></figure><hr><h4 id="算法：least-conn做少连接（wlc）"><a href="#算法：least-conn做少连接（wlc）" class="headerlink" title="算法：least_conn做少连接（wlc）"></a><code>算法：least_conn做少连接（wlc）</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对短链接最好使用：轮询</span></span><br><span class="line"><span class="comment">#对长连接最好使用：wlc</span></span><br><span class="line"></span><br><span class="line">使用least_conn做少连接算法</span><br><span class="line">  编辑nginx实现负载均衡</span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;</span><br><span class="line">        upstream staticwebsrvs &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 172.18.135.2 weight=2;</span><br><span class="line">        server 172.18.135.5;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">lient客户端测试</span><br><span class="line">  ~]<span class="comment"># while true; do curl http://172.18.135.1:8080; sleep 1;done</span></span><br></pre></td></tr></table></figure><hr><h4 id="算法：ip-hash-sh"><a href="#算法：ip-hash-sh" class="headerlink" title="算法：ip_hash (sh)"></a><code>算法：ip_hash (sh)</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">使用ip_hash：bash原ip地址</span><br><span class="line">  编辑nginx实现负载均衡</span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;</span><br><span class="line">        upstream staticwebsrvs &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 172.18.135.2 weight=2;</span><br><span class="line">        server 172.18.135.5;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">lient客户端测试</span><br><span class="line">  ~]<span class="comment"># while true; do curl http://172.18.135.1:8080; sleep 1;done</span></span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line"></span><br><span class="line">工作方式：</span><br><span class="line"><span class="comment">#对客户端ip做bash计算，把后端服务器按权重bash成静态的数组，而后在数据上取模，取出模几，就映射到第几台服务器上</span></span><br><span class="line">缺点：</span><br><span class="line"><span class="comment">#如果服务器的总数发生了变化则此前的hash结果则发生变动</span></span><br><span class="line"><span class="comment">#当后端服务器宕机后，session会丢失；</span></span><br><span class="line"><span class="comment">#来自同一局域网的客户端会被转发到同一个后端服务器，可能导致负载失衡；</span></span><br><span class="line"><span class="comment">#不适用于CDN网络，不适用于前段还有代理的情况。</span></span><br></pre></td></tr></table></figure><hr><h4 id="算法：consistent-bashing-一致性hash"><a href="#算法：consistent-bashing-一致性hash" class="headerlink" title="算法：consistent bashing 一致性hash"></a><code>算法：consistent bashing 一致性hash</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#无论权重怎么变，但是hash算法是不变的，仅对固定的进行bash取模</span></span><br><span class="line"><span class="comment">#bash:可以对任何数据进行hash</span></span><br><span class="line"><span class="comment">#consistent一致性hash,如果不添加则便是静态hash与ip_hash相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">对原地址进行bash，不过做了一致性<span class="built_in">hash</span></span><br><span class="line">  编辑nginx实现负载均衡</span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;</span><br><span class="line">        upstream staticwebsrvs &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">        server 172.18.135.2 weight=2;</span><br><span class="line">        server 172.18.135.5;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">lient客户端测试</span><br><span class="line">  ~]<span class="comment"># while true; do curl http://172.18.135.1:8080; sleep 1;done</span></span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br><span class="line">  web_server1</span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">对用户请求的uri进项<span class="built_in">hash</span>(适用于后端服务器为缓存服务器，提高命中率)</span><br><span class="line"><span class="built_in">hash</span> <span class="variable">$request_uri</span> consistent;</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">  http &#123;</span><br><span class="line">        upstream staticwebsrvs &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$request_uri</span> consistent;</span><br><span class="line">        server 172.18.135.2 weight=2;</span><br><span class="line">        server 172.18.135.5;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://staticwebsrvs/;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx+才支持</span><br><span class="line">nginx-sticky-module的使用（基于cookie的会话保持）</span><br><span class="line"></span><br><span class="line">使用sticky_cookie_insert启用会话亲缘关系，这会导致来自同一客户端的请求被传递到一组服务器在同一台服务器。与ip_hash不同之处在于，它不是基于IP来判断客户端的，而是基于cookie来判断。因此可以避免上述ip_hash中来自同一局域网的客户端和前段代理导致负载失衡的情况。</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nginx的http-upstream模块&quot;&gt;&lt;a href=&quot;#nginx的http-upstream模块&quot; class=&quot;headerlink&quot; title=&quot;nginx的http_upstream模块&quot;&gt;&lt;/a&gt;nginx的http_upstream模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;nginx的http-upstream模块/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx的fastcgi模块</title>
    <link href="https://9527dz.top/2019/01/12/nginx%E7%9A%84fastcgi%E6%A8%A1%E5%9D%97/"/>
    <id>https://9527dz.top/2019/01/12/nginx的fastcgi模块/</id>
    <published>2019-01-12T05:51:45.884Z</published>
    <updated>2019-01-12T09:11:35.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx的fastcgi模块"><a href="#nginx的fastcgi模块" class="headerlink" title="nginx的fastcgi模块"></a>nginx的fastcgi模块</h1><p><img src="/2019/01/12/nginx的fastcgi模块/图标.png" alt=""><br><a id="more"></a></p><h2 id="nginx的fastcgi模块-1"><a href="#nginx的fastcgi模块-1" class="headerlink" title="nginx的fastcgi模块"></a>nginx的fastcgi模块</h2><p>1.1　什么是 FastCGI</p><ul><li><p>FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。</p></li><li><p>FastCGI是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后将结果返回给HTTP服务器。这在处理高并发访问时几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少使用了。</p></li><li><p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p></li></ul><p>1.2　Nginx+FastCGI运行原理(nginx+fcgi_module–&gt;fpm(php))=NMP</p><ul><li>Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端。这就是Nginx+FastCGI的整个运作过程，</li></ul><p><img src="/2019/01/12/nginx的fastcgi模块/fpm.png" alt=""></p><h2 id="ngx-http-fastcgi-module模块："><a href="#ngx-http-fastcgi-module模块：" class="headerlink" title="ngx_http_fastcgi_module模块："></a>ngx_http_fastcgi_module模块：</h2><ul><li><p><code>1、fastcgi_pass address;</code></p><ul><li>address为fastcgi server的地址；    location, if in location；</li></ul></li><li><p><code>2、fastcgi_index name;</code></p><ul><li>fastcgi默认的主页资源; </li></ul></li><li><p><code>3、fastcgi_param parameter value [if_not_empty];</code></p><ul><li>设置应该传递给FastCGI服务器的参数。该值可以包含文本、变量及其组合。(用于向后端的fastcgi或者fpm_server来传递参数)        </li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装完nginx时在目录中就有fastcgi_paeams文件，里面装的时nginx给fpm服务传递的参数，（每个默认的参数都要启动生效，每一个默认值fastcgi服务端执行fpm服务时要配置启用的参数的默认设定）</span></span><br><span class="line">    ~]<span class="comment"># ls /etc/nginx/</span></span><br><span class="line">    fastcgi_params </span><br><span class="line"></span><br><span class="line">两台主机</span><br><span class="line">    client</span><br><span class="line">    proxy_nginx_server    :yum install nginx -y</span><br><span class="line">    fpm_server          :yum install php-fpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编辑代理nginx_server</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">    </span><br><span class="line">        location  ~* \.php$  &#123;</span><br><span class="line">        fastcgi_pass 172.18.135.2:9000;  <span class="comment">#定义如果客户端请求的资源为.php结尾的文件转发到fpm_server服务器上</span></span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  /data<span class="variable">$fastcgi_script_name</span>;  <span class="comment">#/data是在fpm_server上</span></span><br><span class="line">        include        fastcgi_params;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    ~]<span class="comment"># nginx -t</span></span><br><span class="line">    ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">fpm_server创建.php文件供客户端访问</span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># cat /data/info.php </span></span><br><span class="line">    &lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">    ?&gt;</span><br><span class="line">    编辑fpm的配置文件的允许监听的地址</span><br><span class="line">    ~]<span class="comment"># vim /etc/php-fpm.d/www.conf</span></span><br><span class="line">    listen = 172.18.135.2:9000</span><br><span class="line">    listen.allowed_clients = any</span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># systemctl restart php-fpm</span></span><br><span class="line"></span><br><span class="line">client访问</span><br><span class="line">    http://172.18.135.1/info.php</span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">使用压测工具进行压测（ab）</span><br><span class="line">     ~]<span class="comment"># yum install httpd-tools -y</span></span><br><span class="line">        ab 命令（n&gt;c）</span><br><span class="line">            -c 模拟并发的数量</span><br><span class="line">            -n 指定请求的个数</span><br><span class="line"></span><br><span class="line">对nginx调度器进行压测</span><br><span class="line">    ~]<span class="comment"># ab -c 100 -n 1000 http://172.18.135.1/infp.php</span></span><br><span class="line">    Requests per second:    2389.18 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">对nginx调度器的fastcgi模块启用缓存</span><br><span class="line"><span class="comment">#http上下文定义键</span></span><br><span class="line">    ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">    http &#123;</span><br><span class="line">        fastcgi_cache_path /var/cache/fastcgi       levels=1:1:2 keys_zone=fastcgi:10m     max_size=2G;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">#调用http定义的键</span></span><br><span class="line">       server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        location  ~* \.php$  &#123;</span><br><span class="line">        fastcgi_pass 172.18.135.2:9000;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  /data<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">        fastcgi_cache     fastcgi;</span><br><span class="line">        fastcgi_cache_key <span class="variable">$request_uri</span>;</span><br><span class="line">        fastcgi_cache_valid 200 302 10m;</span><br><span class="line">        fastcgi_cache_valid 301   1h;</span><br><span class="line">        fastcgi_cache_valid any   1m;</span><br><span class="line">        fastcgi_cache_methods GET HEAD;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># mkdir -p /var/cache/fastcgi</span></span><br><span class="line">    ~]<span class="comment"># nginx -t</span></span><br><span class="line">    ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">再次访问测试验证是否加速</span><br><span class="line">    ~]<span class="comment"># ab -c 100 -n 1000 http://172.18.135.1/infp.php  #第一次访问生成缓存</span></span><br><span class="line">    [root@centos7 ~]<span class="comment"># tree /var/cache/fastcgi/</span></span><br><span class="line">    /var/cache/fastcgi/</span><br><span class="line">    └── 5</span><br><span class="line">      └── 6</span><br><span class="line">          └── af</span><br><span class="line">             └── 48fe86dcef16714ba3e4f82bba2daf65</span><br><span class="line">    3 directories, 1 file</span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># ab -c 100 -n 1000 http://172.18.135.1/infp.php</span></span><br><span class="line">    Requests per second:    10657.12 [<span class="comment">#/sec] (mean)</span></span><br></pre></td></tr></table></figure><p>4、fastcgi_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</p><ul><li><p>定义fastcgi的缓存；缓存位置为磁盘上的文件系统，由path所指定路径来定义；</p><ul><li>levels=levels：缓存目录的层级数量，以及每一级的目录数量；levels=ONE:TWO:THREE</li><li>leves=1:2:2</li><li>keys_zone=name:size<ul><li>k/v映射的内存空间的名称及大小<ul><li>inactive=time<ul><li>非活动时长</li></ul></li><li>max_size=size<ul><li>磁盘上用于缓存数据的缓存空间上限</li></ul></li></ul></li></ul></li></ul></li><li><p>5、fastcgi_cache zone | off;</p><ul><li>调用指定的缓存空间来缓存数据；http, server, location</li></ul></li><li><p>6、fastcgi_cache_key string;</p><ul><li>定义用作缓存项的key的字符串；</li></ul></li><li><p>7、fastcgi_cache_methods GET | HEAD | POST …;</p><ul><li>为哪些请求方法使用缓存；</li></ul></li><li><p>8、fastcgi_cache_min_uses number;</p><ul><li>缓存空间中的缓存项在inactive定义的非活动时间内至少要被访问到此处所指定的次数方可被认作活动项；</li></ul></li><li><p>9、fastcgi_cache_valid [code …] time;</p><ul><li>不同的响应码各自的缓存时长；</li></ul></li><li><p>10、fastcgi_keep_conn on | off;</p><ul><li>默认情况下，FastCGI服务器会在发送响应后立即关闭连接。但是，当这个指令被设置为on时，nginx将指示FastCGI服务器保持连接打开。    </li></ul></li></ul><p>范例：fastcgi模块内键有两个url可以输出fastcgi健康状态以及健康页面信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_server配置文件中开启两个内建的url(这两个url的输出默认使用的fastcgi协议)</span><br><span class="line">    ~]<span class="comment"># vim /etc/php-fpm.d/www.conf </span></span><br><span class="line">    121 pm.status_path = /pm_status</span><br><span class="line">    133 ping.path = /ping   <span class="comment">#ping·pong</span></span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># systemctl restart php-fpm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编辑nginx代理</span><br><span class="line">    ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        location ~* ^/(pm_status|ping)$ &#123;</span><br><span class="line">        fastcgi_pass 172.18.135.2:9000;</span><br><span class="line">         fastcgi_param  SCRIPT_FILENAME  <span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ~]<span class="comment"># nginx -t</span></span><br><span class="line">     ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">客户端访问测试</span><br><span class="line">    ~]<span class="comment"># curl 172.18.135.1/pm_status</span></span><br><span class="line">    pool:                 www</span><br><span class="line">    process manager:      dynamic</span><br><span class="line">    start time:           12/Jan/2019:17:09:39 +0800</span><br><span class="line">    start since:          57</span><br><span class="line">    accepted conn:        1</span><br><span class="line">    listen queue:         0</span><br><span class="line">    max listen queue:     0</span><br><span class="line">    listen queue len:     128</span><br><span class="line">    idle processes:       4</span><br><span class="line">    active processes:     1</span><br><span class="line">    total processes:      5</span><br><span class="line">    max active processes: 1</span><br><span class="line">    max children reached: 0</span><br><span class="line">    slow requests:        0</span><br><span class="line"></span><br><span class="line">    ~]<span class="comment"># curl 172.18.135.1/ping</span></span><br><span class="line">    pong</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nginx的fastcgi模块&quot;&gt;&lt;a href=&quot;#nginx的fastcgi模块&quot; class=&quot;headerlink&quot; title=&quot;nginx的fastcgi模块&quot;&gt;&lt;/a&gt;nginx的fastcgi模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/12/nginx的fastcgi模块/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx的proxy模块</title>
    <link href="https://9527dz.top/2019/01/10/nginx%E7%9A%84proxy%E6%A8%A1%E5%9D%97/"/>
    <id>https://9527dz.top/2019/01/10/nginx的proxy模块/</id>
    <published>2019-01-10T11:56:48.546Z</published>
    <updated>2019-01-12T06:00:57.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx的proxy模块"><a href="#nginx的proxy模块" class="headerlink" title="nginx的proxy模块"></a>nginx的proxy模块</h1><p><img src="/2019/01/10/nginx的proxy模块/图标.png" alt=""><br><a id="more"></a></p><h2 id="nginx的proxy模块-1"><a href="#nginx的proxy模块-1" class="headerlink" title="nginx的proxy模块"></a>nginx的proxy模块</h2><p>一、反向代理</p><ul><li><p>1.什么是反向代理（DNAT）<br>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中由代理服务器向Internet上的web服务器发起请求，最终达到客户机上网的目的（也就是正向代理）。</p></li><li><p>而反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p></li><li>Nginx只做请求的转发，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后面的服务器，决定把请求转发给谁</li></ul><p><img src="/2019/01/10/nginx的proxy模块/代理.png" alt=""></p><h2 id="ngx-http-proxy-module模块："><a href="#ngx-http-proxy-module模块：" class="headerlink" title="ngx_http_proxy_module模块："></a>ngx_http_proxy_module模块：</h2><ul><li>1、proxy_pass URL;    <ul><li>Context:    location, if in location, limit_except<ul><li>作用：将用户的请求代理到哪个URL上（完成的是两个路径的映射关系）<ul><li>注意：proxy_pass后面的路径不带uri时，其会将location的uri传递给后端主机；</li></ul></li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">server_name HOSTNAME;</span><br><span class="line">location /uri/ &#123;</span><br><span class="line">proxy http://hos[:port];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://HOSTNAME/uri --&gt; http://host/uri </span><br><span class="line"></span><br><span class="line">proxy_pass后面的路径是一个uri时，其会将location的uri替换为proxy_pass的uri；</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">server_name HOSTNAME;</span><br><span class="line">location /uri/ &#123;</span><br><span class="line">proxy http://host/new_uri/;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://HOSTNAME/uri/ --&gt; http://host/new_uri/</span><br><span class="line"></span><br><span class="line">如果location定义其uri时使用了正则表达式的模式，或在if语句或limt_execept中使用proxy_pass指令，则proxy_pass之后必须不能使用uri; 用户请求时传递的uri将直接附加代理到的服务的之后；</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">server_name HOSTNAME;</span><br><span class="line">location ~|~* /uri/ &#123;</span><br><span class="line">proxy http://host;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://HOSTNAME/uri/ --&gt; http://host/uri/；</span><br></pre></td></tr></table></figure><p><img src="/2019/01/10/nginx的proxy模块/代理1.png" alt=""></p><p><code>范例：实现简单的代理</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">使用docker镜像创建两个web_server服务器</span><br><span class="line"><span class="comment">#容易已经绑定宿主机的存储卷，默认安装完docker生成的一个net的地址桥</span></span><br><span class="line"><span class="comment">#无需暴漏端口，因为此web_server仅用于和前端内网中的nginx_proxy_server通讯不需要直接和客户端进行通讯</span></span><br><span class="line"></span><br><span class="line">   ~]<span class="comment"># docker run --name webser1 -it --network bridge -v /vols/websrv1:/vole/htdocs1 busybox</span></span><br><span class="line">   / <span class="comment"># httpd -f -v -h  /vole/htdocs1</span></span><br><span class="line"><span class="comment">#-f 运行在前台</span></span><br><span class="line"><span class="comment">#-v 打印信息在前台</span></span><br><span class="line"><span class="comment">#-h 指定家目录</span></span><br><span class="line"></span><br><span class="line">   ~]<span class="comment"># docker run --name webser2 -it --network bridge -v /vols/websrv2:/vole/htdocs1 busybox</span></span><br><span class="line">   / <span class="comment"># httpd -f -v -h  /vole/htdocs1</span></span><br><span class="line"></span><br><span class="line">在宿主机上创建对应的存储卷上对应的网页文件</span><br><span class="line">~]<span class="comment"># mkdir -p /vols/websrv1</span></span><br><span class="line">~]<span class="comment"># mkdir -p /vols/websrv2</span></span><br><span class="line">~]<span class="comment"># echo "webser1" &gt; /vols/websrv1/index.html</span></span><br><span class="line">  ~]<span class="comment"># echo "webser2" &gt; /vols/websrv2/index.html</span></span><br><span class="line">  ~]<span class="comment"># curl 172.17.0.2</span></span><br><span class="line">    websrv1</span><br><span class="line">  ~]<span class="comment"># curl 172.17.0.3</span></span><br><span class="line">    websrv2</span><br><span class="line"></span><br><span class="line">配置nginx代理</span><br><span class="line">  ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://172.17.0.2/;         <span class="comment">#proxy_pass的优先级比root的优先级要高 ,/有和无是有区别的。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">客户端请求nginx代理的地址</span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080</span></span><br><span class="line">websrv1</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line"><span class="comment">###实验说明/有和无是有区别的</span></span><br><span class="line"><span class="comment">##无/##</span></span><br><span class="line">       server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        root /nginx/html;</span><br><span class="line">        location /bbs &#123;</span><br><span class="line">        proxy_pass http://172.17.0.2; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~]<span class="comment"># mkdir -p /nginx/html/ddb</span></span><br><span class="line">~]<span class="comment"># mkdir -p /nginx/html/bbs</span></span><br><span class="line">~]<span class="comment"># echo "/nginx/html/bbs/index.html" &gt; /nginx/html/bbs/index.html</span></span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/bbs</span></span><br><span class="line">/nginx/html/bbs/index.html</span><br><span class="line"></span><br><span class="line">查看web_server打印的日志</span><br><span class="line">[::ffff:172.17.0.1]:50650: response:404</span><br><span class="line"></span><br><span class="line"><span class="comment">##有/##</span></span><br><span class="line">       server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        root /nginx/html;</span><br><span class="line">        location /bbs &#123;</span><br><span class="line">        proxy_pass http://172.17.0.2/; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/bbs</span></span><br><span class="line">websrv1</span><br><span class="line"></span><br><span class="line">查看web_server打印的日志</span><br><span class="line">[::ffff:172.17.0.1]:50648: response:200</span><br><span class="line"></span><br><span class="line">··············································································</span><br><span class="line">范例：使用正则表达式匹配客户端请求的文件进行代理</span><br><span class="line">配置nginx代理</span><br><span class="line"><span class="comment">#"proxy_pass"不能在正则表达式给出的位置中</span></span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location ~* \.(jpg|png|jpeg) &#123;<span class="comment">#如果客户端请求这些资源则代理则将客户段的请求代理到web_server的/images/目录下文件</span></span><br><span class="line">        proxy_pass http://172.17.0.1;<span class="comment">#proxy_pass定义的匹配条件后面不可以url（客户的请求资源url和自动补在服务器上，如果客户请求的http://172.18.135.1:8888/bbs/a.jpg,如果后端的web服务器上有这个资源，则客户端也回加载此图片（后面的uri是原封不动的放在后端服务器上的））</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">在web_server上放置图片提供访问（从宿主机上查找图片放在容器对应映射在宿主机上的存储卷）</span><br><span class="line">~]<span class="comment"># cd /vols/websrv1/</span></span><br><span class="line">websrv1]<span class="comment"># cp /usr/share/cups/www/images/smiley.jpg .</span></span><br><span class="line"></span><br><span class="line">客户端访问测试</span><br><span class="line">http://172.18.135.1:8888/smiley.jpg</span><br><span class="line"></span><br><span class="line">查看web_server是否接受请求</span><br><span class="line">[::ffff:172.17.0.1]:50720: response:200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##测试请求web_server下的其他url的图片</span></span><br><span class="line">宿主机放置资源在存储卷上</span><br><span class="line">bbs]<span class="comment"># pwd</span></span><br><span class="line">/vols/websrv1/bbs</span><br><span class="line">请求测试</span><br><span class="line">http://172.18.135.1:8888/bbs/profile.jpg</span><br><span class="line">```</span><br><span class="line">- `2、proxy_set_header field value;`</span><br><span class="line">- 设定发往后端主机的请求报文的请求首部的值；Context:http, server, location</span><br><span class="line">- proxy_set_header X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">- proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">`范例：proxy_set_header ：将请求报文发送给后端被代理的服务器时，修改请求报文的某些或者某个首部`</span><br><span class="line">```bash</span><br><span class="line">七层调度是可以操纵两路报文：</span><br><span class="line">第一：把请求转给后端时，可以操作报文</span><br><span class="line">第二：将后端服务器的响应发还给客户端时，可以操作报文</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">实现被调度的服务器显示的日志查看到的源地址为客户端的地址</span><br><span class="line"><span class="comment">#利用变量操作客户端请求被调度的服务器的请求报文的源地址的修改</span></span><br><span class="line"><span class="comment">#proxy_set_header X-Real-IP  $remote_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志查看被调度的默认的请求的客户端的地址，默认显示的不是真正的客户端的地址，显示的是调度的器的地址（请求报文的源地址）</span></span><br><span class="line"><span class="comment">#[::ffff:172.17.0.1]:50728: response:200</span></span><br><span class="line"></span><br><span class="line">（让代理服务器发请求报文时添加特定的请求首部，修改为真正的客户端地址，让后端被调度的服务器记录日志时，改为记录新的日志）</span><br><span class="line"></span><br><span class="line">编辑被调度的web服务的配置文件</span><br><span class="line">1.查看后端web服务器的使用的日志的格式</span><br><span class="line">CustomLog /path/to/file 格式定义（common、combined、combinedio）</span><br><span class="line"></span><br><span class="line">2.修改web后端使用的日志的格式</span><br><span class="line">LogFormat <span class="string">"%&#123;X-Real-IP&#125;i %l %u %t \"%r\" %&gt;s %b"</span> common</span><br><span class="line"></span><br><span class="line">3.修改nginx调度器的配置文件</span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        listen 8888;</span><br><span class="line">        location ~* \.(jpg|png|jpeg) &#123;</span><br><span class="line">        proxy_pass http://172.18.135.2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">4.客户端访问调度器并查看后端的web_server服务器的访问日志信息</span><br><span class="line">~]<span class="comment"># cat /var/log/httpd/access_log </span></span><br><span class="line">172.18.135.5 - - [12/Jan/2019:10:08:05 +0800] <span class="string">"GET /smiley.jpg HTTP/1.0"</span> 200 14120</span><br><span class="line">(此地址文真实客户端地址)</span><br></pre></td></tr></table></figure><ul><li><code>3、proxy_cache_path</code><ul><li>定义可用于proxy功能的缓存；Context:    http            <ul><li>proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</li></ul></li></ul></li></ul><p>范例：    定义可用于proxy功能的缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">页面缓存（http服务）</span><br><span class="line"><span class="comment">#nginx作为反向代理服务器时支持缓存功能的，缓存是由缓存模块个缓存机制来提供的，对于缓存服务来说要想启用起来，是由代理模块自带的，在nginx上想要使用代理，必须要匹配模式，在nginx中的缓存是要先定义在使用的，</span></span><br><span class="line">levels=levels <span class="comment">#定义使用几级索引，做多使用三级=每级索引当中打算使用几个字符创建多少个子项（一个字符是16个，两个字符就是256个，2^8）</span></span><br><span class="line"><span class="comment">#inactive=time非活动时间</span></span><br><span class="line"><span class="comment">#max_size=size  整个磁盘空间用于缓存的时间的空间的大小</span></span><br><span class="line"><span class="comment">#manager_sleep=time每隔多长时间检查缓存的有效性</span></span><br><span class="line"><span class="comment">#manager_threshold=time如果缓存时间沾满，如何使用LRU（最近最少使用算法）算法激活，并清理缓存</span></span><br><span class="line"></span><br><span class="line">范例：配置nginx的proxy功能的页面缓存</span><br><span class="line"><span class="comment">#直接定义在http的上下文</span></span><br><span class="line"><span class="comment"># proxy_cache_path定义缓存的放置路径，并确保定义的缓存的目录的存在,应该放置在当前主机上的io性能最好的设备上（固态硬盘）（缓存对cpu的压力小，但是最磁盘io的压力很大）</span></span><br><span class="line"><span class="comment">#levels=1:1:1 定义缓存的路由级别，每个路由有16个子目录</span></span><br><span class="line"><span class="comment">#keys_zone定义内存空间的路径和定义内存数据或者索引数据的缓存（K/V）</span></span><br><span class="line"><span class="comment">#max_size=size指定磁盘空间的大小</span></span><br><span class="line"><span class="comment">#proxy_cache调用缓存的名称</span></span><br><span class="line"><span class="comment">#proxy_cache_key $schene$proxy_host$is_args$args;#定义使用的键bash（协议：服务器地址：端口：请求的uri）如果是服务器的地址使用了泛域名解析，则要去掉协议和服务器地址</span></span><br><span class="line"><span class="comment">#proxy_cache_valid 定义缓存进来的键被保留多长时间</span></span><br><span class="line"><span class="comment">#proxy_cache_methods(默认为GET、POST)(对web服务器来讲通常仅缓存读操作，不缓存写操作，查询缓存时只对读操作查缓存)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#proxy_cache_use_stale (缓存的内容不一定是权威的内容，所有能够响应客户端的前提是后端服务器时ok的，如果客户的某一请求来了服务器时不在了，代理联系不到后端的服务器，并且缓存中的内容已经过期了客户端的且缓存中的内容还是存在的，决定代理服务器还要不要给客户端返回结果)off代表如果服务器有问题时代理服务器不拿缓存中数据去对客户端进行响应，定义服务器出现问题是代理继续使用未过期的缓存进行响应proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off ...;</span></span><br><span class="line"></span><br><span class="line">编辑nginx代理节点的配置文件</span><br><span class="line"><span class="comment">#定义缓存功能</span></span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">http &#123;</span><br><span class="line">        proxy_cache_path /var/cache/nginxlevels=1:1:2 keys_zone=webcache:10mmax_size=2G;</span><br><span class="line">....</span><br><span class="line"><span class="comment">#调用缓存</span></span><br><span class="line">        server &#123;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        listen 8888;</span><br><span class="line">        location ~* \.(jpg|png|jpeg) &#123;</span><br><span class="line">        proxy_pass http://172.18.135.2;</span><br><span class="line">        proxy_cache     webcache;</span><br><span class="line">proxy_cache_key <span class="variable">$request_uri</span>;<span class="comment">#设置仅使用uri当客户端请求的bash的键</span></span><br><span class="line">proxy_cache_valid 200 302 10m;<span class="comment">#根据用户第一次请求的响应码定义缓存的时长</span></span><br><span class="line">proxy_cache_valid 3011h;</span><br><span class="line">proxy_cache_valid any1m;</span><br><span class="line">proxy_cache_methods GET HEAD;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">客户端进行访问测试</span><br><span class="line">http://172.18.135.1:8888/smiley.jpg</span><br><span class="line"></span><br><span class="line">调度器查看是否生成缓存</span><br><span class="line">~]<span class="comment"># tree /var/cache/nginx</span></span><br><span class="line">/var/cache/nginx</span><br><span class="line">└── 2<span class="comment">#一级桶</span></span><br><span class="line">    └── b<span class="comment">#二级桶</span></span><br><span class="line">        └── df<span class="comment">#三级桶</span></span><br><span class="line">            └── ac2582e15d13e9fa21b8da128b16dfb2</span><br><span class="line">3 directories, 1 file</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># cat /var/cache/nginx/2/b/df/ac2582e15d13e9fa21b8da128b16dfb2 </span></span><br><span class="line">޷9\YJ9\u9\¼b]<span class="string">"3728-57f392ebe4ca8"</span></span><br><span class="line">KEY: /smiley.jpg</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 12 Jan 2019 05:05:11 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS)</span><br><span class="line">Last-Modified: Sat, 12 Jan 2019 02:00:57 GMT</span><br><span class="line">ETag: <span class="string">"3728-57f392ebe4ca8"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 14120</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure></p><ul><li><p>4、proxy_cache zone | off;</p><ul><li>指明要调用的缓存，或关闭缓存机制；Context:    http, server, location</li></ul></li><li><p>5、    proxy_cache_key string;</p><ul><li>缓存中用于“键”的内容；<ul><li>默认值：proxy_cache_key $scheme$proxy_host$request_uri;</li></ul></li></ul></li><li><p>6、proxy_cache_valid [code …] time;</p><ul><li><p>定义对特定响应码的响应内容的缓存时长；</p><ul><li><p>定义在http{…}中；</p><ul><li>proxy_cache_path /var/cache/nginx/proxy_cache levels=1:1:1 keys_zone=pxycache:20m max_size=1g;</li></ul></li><li><p>定义在需要调用缓存功能的配置段，例如server{…}；</p><ul><li>proxy_cache pxycache;</li><li>proxy_cache_key $request_uri;</li><li>proxy_cache_valid 200 302 301 1h;</li><li>proxy_cache_valid any 1m;</li></ul></li></ul></li></ul></li><li><p>7、proxy_cache_use_stale</p><ul><li>proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off …;</li><li>确定在与代理服务器通信期间发生错误时，可以在哪些情况下使用陈旧的缓存响应。        </li></ul></li><li><p>8、proxy_cache_methods GET | HEAD | POST …;</p><ul><li>如果在这个指令中列出了客户机请求方法，那么响应将被缓存。“GET”和“HEAD”方法总是添加到列表中，但是建议显式地指定它们。    </li></ul></li><li><p><code>9、proxy_hide_header field;</code>    #操纵发送给客户端的响应报文</p><ul><li>默认情况下，nginx不传递头字段“Date”、“Server”、“X-Pad”和“X-Accel-…”从代理服务器到客户机的响应。proxy_hide_header指令设置不传递的其他字段。    (参考文档：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_purge" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_purge</a>)</li></ul></li><li><p><code>10、proxy_connect_timeout time;</code></p><ul><li>定义与代理服务器建立连接的超时。应该注意的是，这个超时通常不能超过75秒。</li><li>默认为60s；最长为75s；</li></ul></li><li><code>11、proxy_read_timeout time;</code> <ul><li>定义从代理服务器读取响应的超时。超时仅在两个连续读取操作之间设置，而不是为整个响应的传输设置。</li></ul></li><li><code>12、proxy_send_timeout time;</code><ul><li>设置将请求发送到代理服务器的超时。仅在两个连续的写操作之间设置超时，而不是为整个请求的传输设置超时。如果代理服务器在此期间没有收到任何消息，则连接将关闭。</li></ul></li></ul><h3 id="ngx-http-headers-module模块"><a href="#ngx-http-headers-module模块" class="headerlink" title="ngx_http_headers_module模块"></a><code>ngx_http_headers_module模块</code></h3><ul><li>ngx_http_headers_module模块允许将“Expires”和“Cache-Control”报头字段以及任意字段添加到响应报头中。</li><li><p>向由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值；</p></li><li><p><code>1、add_header name value [always];</code></p><ul><li>添加自定义首部；<ul><li>add_header X-Via  $server_addr;</li><li>add_header X-Accel $server_name;</li></ul></li></ul></li><li>2、expires [modified] time;<ul><li>expires epoch | max | off;</li><li>用于定义Expire或Cache-Control首部的值；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nginx的proxy模块&quot;&gt;&lt;a href=&quot;#nginx的proxy模块&quot; class=&quot;headerlink&quot; title=&quot;nginx的proxy模块&quot;&gt;&lt;/a&gt;nginx的proxy模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/10/nginx的proxy模块/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置和使用基础--Webserver</title>
    <link href="https://9527dz.top/2019/01/09/nginx%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%802/"/>
    <id>https://9527dz.top/2019/01/09/nginx配置和使用基础2/</id>
    <published>2019-01-09T11:54:53.467Z</published>
    <updated>2019-01-12T01:51:21.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-Webserver-第二章：配置指令"><a href="#Nginx-Webserver-第二章：配置指令" class="headerlink" title="Nginx-Webserver:第二章：配置指令"></a>Nginx-Webserver:第二章：配置指令</h1><p><img src="/2019/01/09/nginx配置和使用基础2/标题.png" alt=""><br><a id="more"></a></p><h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul><li><p>程序环境</p><ul><li>配置文件的组成部分：</li><li>主配置文件：nginx.conf<ul><li>include conf.d/*.conf</li><li>fastcgi， uwsgi，scgi等协议相关的配置文件</li><li>mime.types：支持的mime类型</li></ul></li><li><p>主程序文件：/usr/sbin/nginx</p><ul><li>Unit File：nginx.service</li></ul></li><li><p>配置：</p><ul><li>主配置文件的配置指令：<ul><li>directive value [value2 …];</li></ul></li></ul></li><li><p>注意：</p><ul><li>(1) 指令必须以分号结尾；</li><li>(2) 支持使用配置变量；<ul><li>内建变量：由Nginx模块引入，可直接引用；</li><li>自定义变量：由用户使用set命令定义；<ul><li>set variable_name value;</li></ul></li></ul></li><li>引用变量：$variable_name</li></ul></li></ul></li><li>nginx支持三类功能在配置文件中放在三个不同的上下文配置段中（一般这三种配置不会同时出现）<ul><li>web<ul><li>http{}</li></ul></li><li>mail<ul><li>mail{}</li></ul></li><li>四层调度机制<ul><li>stream{}</li></ul></li></ul></li></ul><h2 id="主配置文件结构："><a href="#主配置文件结构：" class="headerlink" title="主配置文件结构："></a>主配置文件结构：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">main block：主配置段，也即全局配置段；</span><br><span class="line">event &#123;</span><br><span class="line">...</span><br><span class="line">&#125;：事件驱动相关的配置；</span><br><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">&#125;：http/https 协议相关的配置段；</span><br><span class="line">mail &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">stream &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http协议相关的配置结构</span><br><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">...：各server的公共配置</span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">&#125;：每个server用于定义一个虚拟主机；</span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">listen <span class="comment">#监听端口</span></span><br><span class="line">server_name <span class="comment">#服务器名称</span></span><br><span class="line">root    <span class="comment">#网页文件根目录</span></span><br><span class="line"><span class="built_in">alias</span></span><br><span class="line">location [OPERATOR] URL &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> CONDITION &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><h3 id="main配置段常见的配置指令："><a href="#main配置段常见的配置指令：" class="headerlink" title="main配置段常见的配置指令："></a>main配置段常见的配置指令：</h3><ul><li>分类：<ul><li>正常运行必备的配置</li><li>优化性能相关的配置</li><li>用于调试及定位问题相关的配置</li><li>事件驱动相关的配置</li></ul></li></ul><h3 id="正常运行必备的配置："><a href="#正常运行必备的配置：" class="headerlink" title="正常运行必备的配置："></a>正常运行必备的配置：</h3><ul><li><p>1、user</p><ul><li>Syntax:    user user [group];</li><li>Default:    user nobody nobody;</li><li>Context:    main            </li><li>定义工作进程使用的用户和组凭据。如果省略组，则使用名称与user相同的组。</li></ul></li><li><p>2、pid /PATH/TO/PID_FILE;</p><ul><li>指定存储nginx主进程进程号码的文件路径；</li></ul></li><li><p>3、include file | mask;</p><ul><li>指明包含进来的其它配置文件片断；</li></ul></li><li>4、load_module file;<ul><li>指明要装载的动态模块；</li></ul></li></ul><h3 id="性能优化相关的配置："><a href="#性能优化相关的配置：" class="headerlink" title="性能优化相关的配置："></a>性能优化相关的配置：</h3><ul><li><p><code>1、worker_processes number | auto;</code></p><ul><li>worker进程的数量；通常应该等于小于当前主机的cpu的物理核心数；</li><li>auto：当前主机物理CPU核心数；</li></ul></li><li><p><code>2、worker_cpu_affinity cpumask ...;</code></p><ul><li>worker_cpu_affinity auto [cpumask];    <ul><li>nginx进程的CPU亲缘性；    </li></ul></li><li>CPU MASK：(cpu位掩码称为bit mask)<ul><li>00000000：</li><li>0000 0001：0号CPU</li><li>0000 0010：1号CPU</li><li>0000 0100：2号CPU</li><li>… …</li><li>0000 0011：0和1号CPU；<ul><li>优点：提升缓存的命中率</li><li>context switch:会产生cpu不必要的消耗</li></ul></li></ul></li></ul></li><li><p>3、worker_priority number;</p><ul><li>指定worker进程的nice值，设定worker进程优先级；[-20,20]</li><li>（数字越小优先级越高，默认的值为0）    </li></ul></li><li><p><code>4、worker_rlimit_nofile number;</code></p><ul><li>worker进程所能够打开的文件数量上限；</li></ul></li><li><p>time_resolution</p><ul><li>计时器解析度，降低此值，可减少gettimeofday()系统调用的次数</li></ul></li></ul><h3 id="调试、定位问题："><a href="#调试、定位问题：" class="headerlink" title="调试、定位问题："></a>调试、定位问题：</h3><h4 id="如果是编译安装想要使用一下功能必须在编译时使用–with-debug功能开启"><a href="#如果是编译安装想要使用一下功能必须在编译时使用–with-debug功能开启" class="headerlink" title="如果是编译安装想要使用一下功能必须在编译时使用–with-debug功能开启"></a>如果是编译安装想要使用一下功能必须在编译时使用–with-debug功能开启</h4><ul><li><p>1、daemon on|off;    </p><ul><li>是否以守护进程方式运行Nignx；</li></ul></li><li><p>2、master_process on|off;</p><ul><li>是否以master/worker模型运行nginx；默认为on；(适用于追踪和调试问题，开启以单进程模式运行nginx，主进程直接处理用户的请求)</li></ul></li><li><p>3、error_log file [level];</p><ul><li>错误日志和日志级别（web服务器一般有两种日志：访问日志和错误日志）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在配置nginx.conf 的时候，有一项是指定错误日志的，默认情况下你不指定也没有关系，因为nginx很少有错误日志记录的。但有时出现问题时，是有必要记录一下错误日志的，方便我们排查问题。</span><br><span class="line"></span><br><span class="line">error_log 级别分为 debug, info, notice, warn, error, crit  默认为crit, 该级别在日志名后边定义格式如下：</span><br><span class="line">error_log  /your/path/error.log crit; </span><br><span class="line"></span><br><span class="line">crit 记录的日志最少，而debug记录的日志最多。如果你的nginx遇到一些问题，比如502比较频繁出现，但是看默认的error_log并没有看到有意义的信息，那么就可以调一下错误日志的级别，当你调成error级别时，错误日志记录的内容会更加丰富。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="事件驱动相关的配置"><a href="#事件驱动相关的配置" class="headerlink" title="事件驱动相关的配置:"></a>事件驱动相关的配置:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事件驱动中的参数定义决定了每一个子进程支持的并发连接数</span></span><br><span class="line">events &#123;   </span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- `1、worker_connections number;`</span><br><span class="line">- 每个worker进程所能够打开的最大并发连接数数量；</span><br><span class="line">    - 整个nginx并发连接数（进程数*每个进程可以打开的并发连接数）</span><br><span class="line">    - worker_processes * worker_connections</span><br><span class="line"></span><br><span class="line">- 2、use [epoll|rtsig|select|poll];</span><br><span class="line">- 指明并发连接请求的处理方法；</span><br><span class="line">- 事件驱动机制模型： use epoll;</span><br><span class="line">- 建议让nginx自行选择</span><br><span class="line"></span><br><span class="line">- 3、accept_mutex on | off;（是否打开互斥锁）</span><br><span class="line">- 处理新的连接请求的方法；on意味着由各worker轮流处理新请求，Off意味着每个新请求的到达都会通知所有的worker进程；</span><br><span class="line"></span><br><span class="line">- 4、lock_file file;</span><br><span class="line">- accept_mutex用到的锁文件的路径；</span><br><span class="line"></span><br><span class="line"><span class="comment">## http协议的相关配置</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">http协议的相关配置：</span><br><span class="line">http &#123;    <span class="comment">#http全局配置，可共享给多个server使用</span></span><br><span class="line">... ...</span><br><span class="line">server &#123;  <span class="comment">#一到多个server,每一个server用来定义一个虚拟主机</span></span><br><span class="line">...</span><br><span class="line">listen  <span class="comment">#</span></span><br><span class="line">server_name</span><br><span class="line">root</span><br><span class="line">location [OPERATOR] /uri/ &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与套接字相关的配置"><a href="#与套接字相关的配置" class="headerlink" title="与套接字相关的配置"></a>与套接字相关的配置</h3><ul><li>1、server { … }<ul><li>配置一个虚拟主机；</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen address[:PORT]|PORT; <span class="comment">#指定要监听的地址和端口，仅指定监听的端口，表示监听本机可用的所有此端口，或者指定地址，代表监听此地址的80端口，或者仅监听在本机的unix.socket</span></span><br><span class="line">server_name SERVER_NAME;</span><br><span class="line">root /PATH/TO/DOCUMENT_ROOT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>2、listen PORT|address[:port]|unix:/PATH/TO/SOCKET_FILE</p><ul><li><p>listen address[:port] [default_server] [ssl] [http2 | spdy]  [backlog=number] [rcvbuf=size] [sndbuf=size]</p><ul><li>default_server：设定为默认虚拟主机；</li><li>ssl：限制仅能够通过ssl连接提供服务；</li></ul></li><li>http2:要求支持http2协议；<ul><li>backlog=number：后援队列长度；</li><li>rcvbuf=size：接收缓冲区大小；</li><li>sndbuf=size：发送缓冲区大小；</li></ul></li></ul></li><li><p>3、server_name name …;</p><ul><li>指明虚拟主机的主机名称；后可跟多个由空白字符分隔的字符串；</li><li>支持*通配任意长度的任意字符；</li><li>server_name <em>.magedu.com  <a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.</em></li><li>支持~起始的字符做正则表达式模式匹配；</li><li>server_name ~^www\d+.magedu.com$<ul><li>匹配机制：   <pre><code>-  (1) 首先是字符串精确匹配;     -     (2) 左侧*通配符；      -     (3) 右侧*通配符；    -     (4) 正则表达式；（尽量不要使用正则表达式，引擎在处理字符串影响效率）</code></pre></li></ul></li></ul></li><li><p>4、</p><ul><li>tcp_nodelay on | off;<ul><li>在keepalived模式下的连接是否启用TCP_NODELAY选项；</li></ul></li><li>tcp_nopush on|off;<ul><li>在sendfile模式下，是否启用TCP_CORK选项；</li></ul></li></ul></li><li><p>5、sendfile on | off;</p><ul><li>是否启用sendfile功能；</li></ul></li></ul><h3 id="定义路径相关的配置"><a href="#定义路径相关的配置" class="headerlink" title="定义路径相关的配置"></a>定义路径相关的配置</h3><ul><li><p><code>6、root path;</code></p><ul><li>设置web资源路径映射；用于指明用户请求的url所对应的本地文件系统上的文档所在目录路径；<ul><li>可用的位置：http（对整个http生效）, server（仅对一个server生效）, location（仅对一个location生效）, if in location；</li></ul></li></ul></li><li><p><code>7、location [ = | ~ | ~* | ^~ ] uri { ... }</code>   </p><ul><li>用来表达nginx中，一组有匹配模式的url路径下的资源访问的属性定义和访问控制机制的</li><li><p>在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；  </p></li><li><p>ngnix会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置；</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">客户请求到收到请求，服务端的匹配路由</span><br><span class="line"></span><br><span class="line">  Nginx--&gt;server_name</span><br><span class="line">    server</span><br><span class="line">    server</span><br><span class="line">  Server--&gt;Location</span><br><span class="line">    location&#123;&#125;  <span class="comment">#仅为一个location所匹配处理</span></span><br><span class="line">      <span class="keyword">if</span></span><br><span class="line">      <span class="keyword">if</span></span><br><span class="line">    location&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=：对URI做精确匹配；例如, http://www.9727.top/，</span><br><span class="line">http://www.9727.top/index.html</span><br><span class="line"></span><br><span class="line">  location  =  / &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~：对URI做正则表达式模式匹配，区分字符大小写；</span><br><span class="line">~*：对URI做正则表达式模式匹配，不区分字符大小写；</span><br><span class="line">^~：对URI的左半部分做匹配检查，不区分字符大小写；</span><br><span class="line">不带符号：以URI为前缀的所有uri；</span><br><span class="line"></span><br><span class="line">    匹配优先级：=, ^~, ～/～*，不带符号；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        让我们通过一个例子来说明以上内容：</span><br><span class="line">            location = / &#123;</span><br><span class="line">                [ configuration A ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location / &#123;</span><br><span class="line">                [ configuration B ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location /documents/ &#123;</span><br><span class="line">                [ configuration C ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location ^~ /images/ &#123;</span><br><span class="line">                [ configuration D ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">                [ configuration E ]</span><br><span class="line">            &#125;</span><br><span class="line">            “ /”请求将匹配配置A，“ /index.html”请求将匹配配置B，“ /documents/document.html”请求将匹配配置C，“ /images/1.gif”请求将匹配配置D，“ /documents/1.jpg”请求将匹配配置E.</span><br><span class="line">            “ @”前缀定义命名位置。这样的位置不用于常规请求处理，而是用于请求重定向。它们不能嵌套，也不能包含嵌套位置。</span><br></pre></td></tr></table></figure><p><code>范例： 用来表达nginx中，一组有匹配模式的url路径下的资源访问的属性定义和访问控制机制的</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        root <span class="string">"/ngx/html"</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">        location /images &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080</span></span><br><span class="line">/web/nginx/html/index.html</span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/images/</span></span><br><span class="line">/ngx/html/images/index.html</span><br></pre></td></tr></table></figure></p><ul><li><code>8、alias path;</code><ul><li>定义路径别名，文档映射的另一种机制；仅能用于location上下文；    <ul><li>注意：location中使用root指令和alias指令的意义不同；<ul><li>(a) root，给定的路径对应于location中的/uri/左侧的/；</li><li>(b) alias，给定的路径对应于location中的/uri/右侧的/；</li></ul></li></ul></li></ul></li></ul><p><code>范例：alias path</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#alias</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line"><span class="comment">#        root "/ngx/html";</span></span><br><span class="line">        location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">        location /images &#123;</span><br><span class="line">        <span class="built_in">alias</span> <span class="string">"/ngx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/images/</span></span><br><span class="line">/ngx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#root</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line"><span class="comment">#       root "/ngx/html";</span></span><br><span class="line">        location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">        location /images &#123;</span><br><span class="line">        root <span class="string">"/ngx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/images/</span></span><br><span class="line">/ngx/html/images/index.html</span><br></pre></td></tr></table></figure></p><ul><li><p>9、index file …;</p><ul><li>默认资源；http, server, location；</li></ul></li><li><p><code>10、error_page code ... [=[response]] uri;</code> </p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个错误页面即错误重定向</span></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /404.html &#123;</span><br><span class="line">root <span class="string">"/www/error_pages"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>范例：error_page code ... [=[response]] uri;  定义一个错误页面</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">status(状态码)：告诉客户端的请求发生的结果：</span><br><span class="line">1XX：100-101，信息提示</span><br><span class="line">2XX：200-206，成功类型信息</span><br><span class="line">3XX：300-305，重定向的资源</span><br><span class="line">4XX：400-415，错误类型的信息，客户端的错误，</span><br><span class="line">5XX：500-505，错误类型错误，服务器端错误</span><br><span class="line">常用的状态码：</span><br><span class="line">200：:成功响应，请求的所有数据通过相应报文的entity-body部分发送，OK</span><br><span class="line">301：请求的URL执行的资源已经被删除；但在相应报文中通过首部Location指明了资源的所在位置；Moved Permanently （永久重定向）</span><br><span class="line">302：与301相似，但在相应报文中通过首部Location指明了资源现在所处临时新位置；Found （临时重定向）</span><br><span class="line">304：客户端发出了条件式请求，但服务器的资源为曾发生改变，则通过相应此响应状态码通知客户端，Not Modified</span><br><span class="line">401：需要输入账号和密码认证方能访问资源：Unauthorized</span><br><span class="line">403：请求被禁止：Forbidden</span><br><span class="line">404：服务器无法找到客户端请求的资源：Not Found</span><br><span class="line">500：服务器内部错误：InternalServerError</span><br><span class="line">502：:代理服务器从后端服务器中收到的一条伪响应：Bad Gateway</span><br><span class="line"></span><br><span class="line">定义一个404服务器无法找到客户端请求的资源的错误页面</span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line"><span class="comment">#       root "/ngx/html";</span></span><br><span class="line">        location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        location /images &#123;</span><br><span class="line">        root <span class="string">"/ngx/html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># curl 172.18.135.1:8080/aaaa/</span></span><br><span class="line">/web/nginx/html/404.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line"><span class="comment">#       root "/ngx/html";</span></span><br><span class="line">        location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">        location /images &#123;</span><br><span class="line">        root <span class="string">"/ngx/html"</span>;</span><br><span class="line">&#125;</span><br><span class="line">        error_page 404 /xx.html;</span><br><span class="line">        location = /xx.html&#123;</span><br><span class="line">        root <span class="string">"/etc/nginx/error/"</span></span><br><span class="line">&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>11、try_files file … uri;</li></ul><h3 id="定义客户端请求的相关配置"><a href="#定义客户端请求的相关配置" class="headerlink" title="定义客户端请求的相关配置"></a>定义客户端请求的相关配置</h3><ul><li>12、keepalive_timeout timeout [header_timeout];<ul><li>设定保持连接的超时时长，0表示禁止长连接；默认为75s；</li></ul></li><li>13、keepalive_requests number;<ul><li>在一次长连接上所允许请求的资源的最大数量，默认为100;                     </li></ul></li><li>14、keepalive_disable none | browser …;<ul><li>对哪种浏览器禁用长连接；</li></ul></li><li>15、send_timeout time;<ul><li>向客户端发送响应报文的超时时长，此处，是指两次写操作之间的间隔时长；</li></ul></li><li>16、client_body_buffer_size size;<ul><li>用于接收客户端请求报文的body部分的缓冲区大小；默认为16k；超出此大小时，其将被暂存到磁盘上的由client_body_temp_path指令所定义的位置；</li></ul></li><li>17、client_body_temp_path path [level1 [level2 [level3]]];<ul><li>设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量；<ul><li>16进制的数字；<ul><li>client_body_temp_path   /var/tmp/client_body  1 2 2  <ul><li>1：表示用一位16进制数字表示一级子目录；0-f  </li><li>2：表示用2位16进程数字表示二级子目录：00-ff  </li><li>2：表示用2位16进程数字表示三级子目录：00-ff  </li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="对客户端进行限制的相关配置"><a href="#对客户端进行限制的相关配置" class="headerlink" title="对客户端进行限制的相关配置"></a>对客户端进行限制的相关配置</h2><ul><li>18、limit_rate rate;<ul><li>限制响应给客户端的传输速率，单位是bytes/second，0表示无限制；</li></ul></li><li>19、limit_except method … { … }<ul><li>限制对指定的请求方法之外的其它方法的使用客户端；</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">limit_except GET &#123;</span><br><span class="line">allow 192.168.1.0/24;</span><br><span class="line">deny  all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作优化的配置"><a href="#文件操作优化的配置" class="headerlink" title="文件操作优化的配置"></a>文件操作优化的配置</h2><ul><li>20、aio on | off | threads[=pool];<ul><li>是否启用aio功能；</li></ul></li><li>21、directio size | off;<ul><li>在Linux主机启用O_DIRECT标记，此处意味文件大于等于给定的大小时使用，例如directio 4m;</li></ul></li><li><p>22、open_file_cache off;</p><ul><li><p>open_file_cache max=N [inactive=time];</p><ul><li><p>nginx可以缓存以下三种信息：</p><ul><li>(1) 文件的描述符、文件大小和最近一次的修改时间；</li><li>(2) 打开的目录结构；</li><li><p>(3) 没有找到的或者没有权限访问的文件的相关信息；</p></li><li><p>max=N：可缓存的缓存项上限；达到上限后会使用LRU算法实现缓存管理；</p></li><li>inactive=time：缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于open_file_cache_min_uses指令所指定的次数的缓存项即为非活动项；</li></ul></li></ul></li></ul></li><li><p>23、open_file_cache_valid time;</p><ul><li>缓存项有效性的检查频率；默认为60s; </li></ul></li><li><p>24、open_file_cache_min_uses number;</p><ul><li>在open_file_cache指令的inactive参数指定的时长内，至少应该被命中多少次方可被归类为活动项；</li></ul></li><li>25、open_file_cache_errors on | off;<ul><li>是否缓存查找时发生错误的文件一类的信息；<h2 id="modules模块"><a href="#modules模块" class="headerlink" title="modules模块"></a>modules模块</h2><h3 id="ngx-http-access-module模块：实现基于ip的访问控制功能"><a href="#ngx-http-access-module模块：实现基于ip的访问控制功能" class="headerlink" title="ngx_http_access_module模块：实现基于ip的访问控制功能"></a><code>ngx_http_access_module模块：实现基于ip的访问控制功能</code></h3></li></ul></li><li>26、allow address | CIDR | unix: | all;</li><li>27、deny address | CIDR | unix: | all;<ul><li>http, server, location, limit_except</li><li>该ngx_http_access_module模块允许限制对某些客户端地址的访问。</li><li>访问也可以通过 密码，子请求的 结果或JWT来限制。通过地址和密码同时限制访问由satisf指令控制。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例配置（默认为allow）</span><br><span class="line">location / &#123;</span><br><span class="line">    deny  192.168.1.1;      <span class="comment">#单独拒绝此地址</span></span><br><span class="line">    allow 192.168.1.0/24;</span><br><span class="line">    allow 10.1.1.0/16;</span><br><span class="line">    allow 2001:0db8::/32;</span><br><span class="line">    deny  all;              <span class="comment"># 拒绝所有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按顺序检查规则，直到找到第一个匹配项。在此示例中，仅允许IPv4网络访问 10.1.1.0/16并且192.168.1.0/24 不包括地址192.168.1.1，以及IPv6网络2001:0db8::/32。如果有很多规则， 最好使用 ngx_http_geo_module模块变量。</span><br></pre></td></tr></table></figure><h3 id="ngx-http-auth-basic-module模块-实现基于用户的访问控制，使用basic机制进行用户认证；"><a href="#ngx-http-auth-basic-module模块-实现基于用户的访问控制，使用basic机制进行用户认证；" class="headerlink" title="ngx_http_auth_basic_module模块:实现基于用户的访问控制，使用basic机制进行用户认证；"></a><code>ngx_http_auth_basic_module模块:实现基于用户的访问控制，使用basic机制进行用户认证；</code></h3><ul><li>28、auth_basic string | off;</li><li>29、auth_basic_user_file file;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /admin/ &#123;</span><br><span class="line"><span class="built_in">alias</span> /webapps/app1/data/;</span><br><span class="line">auth_basic <span class="string">"Admin Area"</span>;    <span class="comment">#注释信息</span></span><br><span class="line">auth_basic_user_file /etc/nginx/.ngxpasswd;   <span class="comment">#放置授权加密可以访问的用户名密码文件路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：htpasswd命令由httpd-tools所提供；</span><br></pre></td></tr></table></figure><p><code>范例：基于ngx_http_auth_basic_module模块:实现基于用户的访问控制，使用basic机制进行用户认证</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">配置nginx实现basic加密认证访问</span><br><span class="line">    ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">          server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        root <span class="string">"/ngx/html"</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">        auth_basic <span class="string">"prvate images"</span>;<span class="comment">#注释信息</span></span><br><span class="line">        auth_basic_user_file <span class="string">"/etc/nginx/.ngxpasswd"</span>;<span class="comment">#存放用户名密码的文件定义</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">安装htpasswd命令</span><br><span class="line">htpasswd命令由httpd-tools所提供</span><br><span class="line">  ~]<span class="comment"># yum install httpd-tools -y</span></span><br><span class="line"></span><br><span class="line">创建存放实现加密的用户名和密码文件</span><br><span class="line">  -c 仅用于第一次创建用户时使用</span><br><span class="line">  -m 指定MD5加密算法</span><br><span class="line">  -b 直接给定密码，不使用交互式</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># htpasswd -c -m /etc/nginx/.ngxpasswd daizhe</span></span><br><span class="line">  New password: centos</span><br><span class="line">  Re-type new password: centos</span><br><span class="line">  Adding password <span class="keyword">for</span> user daizhe <span class="comment">#创建daizhe用户</span></span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># htpasswd -m -b /etc/nginx/.ngxpasswd nn centos</span></span><br><span class="line">  Adding password <span class="keyword">for</span> user nn</span><br><span class="line"></span><br><span class="line">查看创建的加密的账号以及测试访问</span><br><span class="line">  ~]<span class="comment"># cat /etc/nginx/.ngxpasswd </span></span><br><span class="line">  daizhe:<span class="variable">$apr1</span><span class="variable">$5kVocZ7d</span><span class="variable">$KIumQtuh5wGySn0iUomd30</span></span><br><span class="line">  nn:<span class="variable">$apr1</span><span class="variable">$ayW</span>.DtQE<span class="variable">$sN5QCmC4enr</span>.a1rUkTHHK0</span><br><span class="line"></span><br><span class="line">  ~]<span class="comment"># nginx -t</span></span><br><span class="line">  ~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">测试</span><br></pre></td></tr></table></figure><p><img src="/2019/01/09/nginx配置和使用基础2/加密.png" alt=""></p><h3 id="ngx-http-stub-status-module模块：用于输出nginx的基本状态信息；"><a href="#ngx-http-stub-status-module模块：用于输出nginx的基本状态信息；" class="headerlink" title="ngx_http_stub_status_module模块：用于输出nginx的基本状态信息；"></a><code>ngx_http_stub_status_module模块：用于输出nginx的基本状态信息；</code></h3><ul><li>30、stub_status;<ul><li>配置示例：</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">location  /basic_status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- Active connections: 291 </span><br><span class="line">- server accepts handled requests</span><br><span class="line">- 16630948 16630948 31070465 </span><br><span class="line">- Reading: 6 Writing: 179 Waiting: 106 </span><br><span class="line"></span><br><span class="line">- Active connections: 活动状态的连接数；</span><br><span class="line">- accepts：已经接受的客户端请求的总数；</span><br><span class="line">- handled：已经处理完成的客户端请求的总数；</span><br><span class="line">- requests：客户端发来的总的请求数；</span><br><span class="line">- Reading：处于读取客户端请求报文首部的连接的连接数；</span><br><span class="line">- Writing：处于向客户端发送响应报文过程中的连接数；</span><br><span class="line">- Waiting：处于等待客户端发出请求的空闲连接数；</span><br><span class="line"></span><br><span class="line">范例：ngx_http_stub_status_module模块：用于输出nginx的基本状态信息；</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        &#125;</span><br><span class="line">        location = /ngx_status &#123;<span class="comment">#声明访问指定的location可以查看nginx的基本状态信息</span></span><br><span class="line">        stub_status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line">[root@host-192-168-35-104 ~]<span class="comment"># curl 172.20.101.158:8080/ngx_status</span></span><br><span class="line">Active connections: 1 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 9 9 8 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br></pre></td></tr></table></figure><h3 id="ngx-http-log-module模块-gx-http-log-module模块以指定的格式写入请求日志。-访问日志"><a href="#ngx-http-log-module模块-gx-http-log-module模块以指定的格式写入请求日志。-访问日志" class="headerlink" title="ngx_http_log_module模块:gx_http_log_module模块以指定的格式写入请求日志。    (访问日志)"></a><code>ngx_http_log_module模块:gx_http_log_module模块以指定的格式写入请求日志。    (访问日志)</code></h3><ul><li><code>31、log_format name string ...;</code><ul><li>string可以使用nginx核心模块及其它模块内嵌的变量；</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#string可以使用nginx核心模块及其它模块内嵌的变量</span></span><br><span class="line"><span class="comment">#string可以命名为一下变量</span></span><br><span class="line"><span class="variable">$bytes_sent</span></span><br><span class="line">发送到客户端的字节数</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span></span><br><span class="line">连接序列号</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection_requests</span></span><br><span class="line">通过连接发出的当前请求数（1.1.18）</span><br><span class="line"></span><br><span class="line"><span class="variable">$msec</span></span><br><span class="line">以秒为单位的时间，日志写入时的分辨率为毫秒</span><br><span class="line"></span><br><span class="line"><span class="variable">$pipe</span></span><br><span class="line">“ p”如果请求是流水线的，“ .”否则</span><br><span class="line"></span><br><span class="line"><span class="variable">$request_length</span></span><br><span class="line">请求长度（包括请求行，标题和请求正文）</span><br><span class="line"></span><br><span class="line"><span class="variable">$request_time</span></span><br><span class="line">以毫秒为单位请求处理时间（以秒为单位）; 从客户端读取第一个字节之间经过的时间，并将最后一个字节发送到客户端后的日志写入</span><br><span class="line"></span><br><span class="line"><span class="variable">$status</span></span><br><span class="line">回应状态</span><br><span class="line"></span><br><span class="line"><span class="variable">$time_iso8601</span></span><br><span class="line">当地时间采用ISO 8601标准格式</span><br><span class="line"></span><br><span class="line"><span class="variable">$time_local</span></span><br><span class="line">通用日志格式的本地时间</span><br><span class="line"></span><br><span class="line"><span class="variable">$remote_addr</span> </span><br><span class="line">远程客户端地址</span><br><span class="line"></span><br><span class="line"><span class="variable">$http_referer</span></span><br><span class="line">~]<span class="comment"># curl -e "www.baidu.com" 172.20.101.158:8080/ngx_status</span></span><br><span class="line">~]<span class="comment"># cat /var/log/nginx/access.log </span></span><br><span class="line">172.20.101.158 - - [10/Jan/2019:10:18:57 +0800] <span class="string">"GET /ngx_status HTTP/1.1"</span> 200 100 <span class="string">"www.baidu.com"</span> <span class="string">"curl/7.29.0"</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按字母顺序排列的变量索引</span><br><span class="line">http://nginx.org/en/docs/varindex.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看安装完nginx默认定义的日志的格式</span></span><br><span class="line"><span class="comment">#默认放置在http上下文，对所有的sever生效</span></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"><span class="comment">#调用此日志格式</span></span><br><span class="line">access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br></pre></td></tr></table></figure><ul><li><p>32、access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</p><ul><li>access_log off;</li><li>访问日志文件路径，格式及相关的缓冲的配置；<ul><li>buffer=size</li><li>flush=time </li></ul></li></ul></li><li><p>33、open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</p><ul><li>open_log_file_cache off;    #关闭</li><li>缓存各日志文件相关的元数据信息；<ul><li>max：缓存的最大文件描述符数量；</li><li>min_uses：在inactive指定的时长内访问大于等于此值方可被当作活动项；</li><li>inactive：非活动时长；</li><li>valid：验正缓存中各缓存项是否为活动项的时间间隔；</li></ul></li></ul></li></ul><h3 id="ngx-http-gzip-module：-压缩传输-ngx-http-gzip-module模块是一个过滤器，它使用“gzip”方法压缩响应。这通常有助于将传输数据的大小减少一半甚至更多"><a href="#ngx-http-gzip-module：-压缩传输-ngx-http-gzip-module模块是一个过滤器，它使用“gzip”方法压缩响应。这通常有助于将传输数据的大小减少一半甚至更多" class="headerlink" title="ngx_http_gzip_module：(压缩传输)ngx_http_gzip_module模块是一个过滤器，它使用“gzip”方法压缩响应。这通常有助于将传输数据的大小减少一半甚至更多"></a><code>ngx_http_gzip_module：(压缩传输)ngx_http_gzip_module模块是一个过滤器，它使用“gzip”方法压缩响应。这通常有助于将传输数据的大小减少一半甚至更多</code></h3><ul><li><p>1、gzip on | off;    （总开关，是否开启压缩功能）#cpu资源紧缺尽量不要压缩，节省带宽，cpu不紧缺则可以考虑开启压缩传输（对文本文件进行压缩，其他格式的文件内容本身就是压缩的，压缩比不大，或许还可以增长）</p></li><li><p>2、gzip_comp_level level;</p><ul><li>设置响应的gzip压缩级别。可接受的值在1到9之间。（数字越大，压缩比越高，也越消耗cpu）    </li></ul></li><li><p>3、    gzip_disable regex …;</p><ul><li>禁用“User-Agent”头字段匹配任何指定正则表达式的请求的响应gzipping。    </li></ul></li><li><p>4、    gzip_min_length length;</p><ul><li>启用压缩功能的响应报文大小阈值； (资源压缩的最小下限阀值，一个资源已经3k了还怎么压缩，设置最小的下限)</li></ul></li><li><p>5、gzip_buffers number size;    </p><ul><li>支持实现压缩功能时为其配置的缓冲区数量及每个缓存区的大小；（内存资源较为充沛时启用，可以加速压缩的速度）</li></ul></li><li><p>6、gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any …;</p><ul><li>nginx作为代理服务器接收到从被代理服务器发送的响应报文后，在何种条件下启用压缩功能的；<ul><li>off：对代理的请求不启用压缩</li><li>no-cache, no-store，private：表示从被代理服务器收到的响应报文首部的Cache-Control的值为此三者中任何一个，则启用压缩功能；</li><li>any：对任何可以压缩的内容都压缩</li></ul></li></ul></li><li><p>7、gzip_types mime-type …;</p><ul><li>压缩过滤器，仅对此处设定的MIME类型的内容启用压缩功能；（纯文本和html格式的内容默认就是压缩的内容）</li></ul></li></ul><p>范例：启用压缩<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义服务器的压缩功能</span><br><span class="line"><span class="comment">#定义在http上下文对所有的server都生效，定义在单独的server中仅对单个server生效</span></span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">http &#123;</span><br><span class="line">.........</span><br><span class="line">    gzip on;<span class="comment">#开启压缩</span></span><br><span class="line">    gzip_comp_level 6;<span class="comment">#压缩比为6</span></span><br><span class="line">    gzip_min_length 64;<span class="comment">#低于64个字节则不压缩</span></span><br><span class="line">    gzip_proxied any;<span class="comment">#任何被代理的内容都压缩</span></span><br><span class="line">    gzip_types text/xml text/css application/javasctipt;<span class="comment">#压缩的文件类型</span></span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br><span class="line"></span><br><span class="line">使用curl命令请求服务端进行压缩</span><br><span class="line">[root@host-192-168-35-104 ~]<span class="comment"># curl --compressed -I 172.20.101.158</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Thu, 10 Jan 2019 03:39:11 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Last-Modified: Thu, 10 Jan 2019 03:24:04 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: W/<span class="string">"5c36bad4-1293ae"</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">测试</span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/09/nginx配置和使用基础2/压缩.png" alt=""></p><h3 id="ngx-http-ssl-module模块："><a href="#ngx-http-ssl-module模块：" class="headerlink" title="ngx_http_ssl_module模块："></a>ngx_http_ssl_module模块：</h3><ul><li>1、    ssl on | off;<ul><li>为给定的虚拟服务器启用HTTPS协议。</li></ul></li><li><p>2、ssl_certificate file;</p><ul><li>当前虚拟主机使用PEM格式的证书文件；</li></ul></li><li><p>3、ssl_certificate_key file;</p><ul><li>当前虚拟主机上与其证书匹配的私钥文件；</li></ul></li><li><p>4、ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2];</p><ul><li>支持ssl协议版本，默认为后三个；</li></ul></li><li><p>5、ssl_session_cache off | none | [builtin[:size]] [shared:name:size];</p><ul><li><p>builtin[:size]：使用OpenSSL内建的缓存，此缓存为每worker进程私有；</p></li><li><p>[shared:name:size]：在各worker之间使用一个共享的缓存；</p></li></ul></li><li><p>6、ssl_session_timeout time;</p><ul><li>客户端一侧的连接可以复用ssl session cache中缓存 的ssl参数的有效时长；</li></ul></li></ul><p>范例：ssl加密传输nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line"></span><br><span class="line">        ssl_protocols       TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;<span class="comment">#加密算法，不写使用默认的加密算法</span></span><br><span class="line">        ssl_certificate     /etc/nginx/certs/nginx.crt;<span class="comment">#私钥</span></span><br><span class="line">        ssl_certificate_key /etc/nginx/certs/nginx.key;<span class="comment">#证书</span></span><br><span class="line">        ssl_session_cache   shared:SSL:10m;<span class="comment">#加密传输的缓存的大小10m</span></span><br><span class="line">        ssl_session_timeout 10m;</span><br><span class="line">location / &#123;</span><br><span class="line">        root <span class="string">"/web/nginx/html"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">生成自签名的证书</span><br><span class="line">~]<span class="comment"># cd /etc/nginx/</span></span><br><span class="line">nginx]<span class="comment"># mkdir certs</span></span><br><span class="line">nginx]<span class="comment"># cd certs/</span></span><br><span class="line">    certs]<span class="comment"># openssl genrsa -out nginx.key 2048#私钥</span></span><br><span class="line">certs]<span class="comment"># openssl req -new -x509 -key nginx.key -out nginx.crt -days 3650 -subj "/CN=www.centos.com"#证书</span></span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line"> ~]<span class="comment"># mkdir -p /web/nginx/html</span></span><br><span class="line"> ~]<span class="comment"># echo "123" &gt; /web/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line">~]<span class="comment"># nginx -t</span></span><br><span class="line">~]<span class="comment"># nginx -s reload</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/09/nginx配置和使用基础2/ssl.png" alt=""></p><h3 id="ngx-http-rewrite-module模块：实现url重写，将用户请求的URI基于regex所描述的模式进行检查，而后完成替换；"><a href="#ngx-http-rewrite-module模块：实现url重写，将用户请求的URI基于regex所描述的模式进行检查，而后完成替换；" class="headerlink" title="ngx_http_rewrite_module模块：实现url重写，将用户请求的URI基于regex所描述的模式进行检查，而后完成替换；"></a><code>ngx_http_rewrite_module模块：实现url重写，将用户请求的URI基于regex所描述的模式进行检查，而后完成替换；</code></h3><ul><li><p>1、rewrite regex replacement [flag]</p><ul><li>将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定的新的URI；</li><li><p>注意：如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查；被某条件规则替换完成后，会重新一轮的替换检查，因此，隐含有循环机制；[flag]所表示的标志位用于控制此循环机制；</p><ul><li><p>如果replacement是以http://或https://开头，则替换结果会直接以重向返回给客户端；</p><ul><li><p>301：永久重定向；</p><ul><li>[flag]：</li><li>last：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环； </li><li>break：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环；</li><li><p>redirect：重写完成后以临时重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；302：临时重定向</p></li><li><p>permanent:重写完成后以永久重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；301：永久重定向</p></li></ul></li></ul></li></ul></li></ul></li></ul><p><code>范例：将用户对bbs的访问，转成对forum的访问</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># mkdir /web/nginx/html/forum</span></span><br><span class="line">~]<span class="comment"># echo "/web/nginx/html/forum/index.html" &gt; /web/nginx/html/forum/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时对forum/index.html访问url路径为：http://172.10.101.158/forum</span></span><br><span class="line"></span><br><span class="line">实现用户访问http://172.10.101.158/bbs跳转到http://172.10.101.158/forum响应（bbs目录可以不存在）</span><br><span class="line"></span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        root <span class="string">"/var/www/nginx"</span>;</span><br><span class="line">        location /bbs/ &#123;</span><br><span class="line">        rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span>;<span class="comment">#后面未加任何控制符相当于last</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#如果访问此server的/var/www/nginx/bbs则重写到此server的/var/www/nginx/forum(此格式仅限单个的重写操作写法)</span></span><br><span class="line"></span><br><span class="line">设置用户对bbs的访问和对forum的访问统统改为其他的其他的server访问</span><br><span class="line">http://www.centos.com/bbs和http://www.centos.com/forum响应的访问请求一个新的serverwww.linux.com的访问</span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name www.centos.com;</span><br><span class="line">        root <span class="string">"/var/www/nginx"</span>;</span><br><span class="line">        location ~* ^/(bbs|forum) &#123;</span><br><span class="line">        rewrite ^/(bbs|froum)/(.*)$ http://www.linux.com/<span class="variable">$2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        server &#123;</span><br><span class="line">        server_name www.linux.com;</span><br><span class="line">        listen 8080;</span><br><span class="line">        root <span class="string">"/web/nginx/forum"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现对本机的任何的不安全的172.20.101.158下的所有资源都会跳转到www.centos.com的https</span><br><span class="line">        server &#123;</span><br><span class="line"> 66         listen              443 ssl;</span><br><span class="line"> 67         server_name www.centos.com</span><br><span class="line"> 68         ssl_protocols       TLSv1.1 TLSv1.2;</span><br><span class="line"> 69         ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-    MD5;</span><br><span class="line"> 70         ssl_certificate     /etc/nginx/certs/nginx.crt;</span><br><span class="line"> 71         ssl_certificate_key /etc/nginx/certs/nginx.key;</span><br><span class="line"> 72         ssl_session_cache   shared:SSL:10m;</span><br><span class="line"> 73         ssl_session_timeout 10m;</span><br><span class="line"> 74         location / &#123;</span><br><span class="line"> 75         root <span class="string">"/web/nginx/html"</span>;</span><br><span class="line"> 76         &#125;</span><br><span class="line"> 77     &#125;</span><br><span class="line"> 78 </span><br><span class="line"> 7</span><br><span class="line"> 80         server &#123;</span><br><span class="line"> 81         listen 8080;</span><br><span class="line"> 82         server_name 172.20.101.158;</span><br><span class="line"> 83         root <span class="string">"/var/www/nginx"</span>;</span><br><span class="line"> 84         rewrite ^/(.*)$ https://centos.com/<span class="variable">$1</span>;</span><br><span class="line"> 85         location / &#123;</span><br><span class="line"> 86 &#125;</span><br><span class="line"> 87 &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">临时重定向</span><br><span class="line">    rewrite ^/(.*)$ https://centos.com/<span class="variable">$1</span> redirect;</span><br><span class="line">永久重定向</span><br><span class="line">rewrite ^/(.*)$ https://centos.com/<span class="variable">$1</span> permanent;</span><br></pre></td></tr></table></figure></p><ul><li>2、return<ul><li>return code [text];</li><li>return code URL;</li><li>return URL;</li></ul></li></ul><ul><li><p>3、    rewrite_log on | off;</p><ul><li>是否开启重写日志；</li></ul></li><li><p>4、    if (condition) { … }</p><ul><li><p>引入一个新的配置上下文 ；条件满足时，执行配置块中的配置指令；一般用在：server, location；</p></li><li><p>condition：</p><ul><li>比较操作符：<ul><li>==</li><li>!=</li><li>~：模式匹配，区分字符大小写；</li><li>~*：模式匹配，不区分字符大小写；</li><li>!~：模式不匹配，区分字符大小写；</li><li>!~*：模式不匹配，不区分字符大小写；</li></ul></li><li>文件及目录存在性判断：<ul><li>-e, !-e</li><li>-f, !-f</li><li>-d, !-d</li><li>-x, !-x</li></ul></li></ul></li></ul></li><li><p>5、set $variable value;    #在nginx里自己定义变量</p><ul><li>用户自定义变量 ；    </li></ul></li></ul><h3 id="ngx-http-referer-module模块：ngx-http-referer-module模块用于阻止“Referer”头字段中值无效的请求访问站点。"><a href="#ngx-http-referer-module模块：ngx-http-referer-module模块用于阻止“Referer”头字段中值无效的请求访问站点。" class="headerlink" title="ngx_http_referer_module模块：ngx_http_referer_module模块用于阻止“Referer”头字段中值无效的请求访问站点。"></a><code>ngx_http_referer_module模块：ngx_http_referer_module模块用于阻止“Referer”头字段中值无效的请求访问站点。</code></h3><p>引用者，显示上级url的来源（盗链）</p><ul><li>1、valid_referers none | blocked | server_names | string …;<ul><li>定义referer首部的合法可用值(合法的链接)；<ul><li>none：请求报文首部没有referer首部；</li><li>blocked：请求报文的referer首部没有值；</li><li>server_names：参数，其可以有值作为主机名或主机名模式；<ul><li>arbitrary_string：直接字符串，但可使用*作通配符；</li><li>regular expression：被指定的正则表达式模式匹配到的字符串；要使用~打头，例如 ~.*.a.com；</li></ul></li></ul></li></ul></li></ul><p>范例:防盗链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义正常引用和非正常引用链接的跳转</span></span><br><span class="line">~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">        server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        server_name 172.20.101.158;</span><br><span class="line">        valid_referers none blocked server_name 172.20.101.158 172.20.101.82 *.ce</span><br><span class="line">ntos.com;<span class="comment">#定义允许外链访问的地址</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;<span class="comment">#除了上面定义的地址外可以外链访问主页，其余的地址直接跳转至http://172.20.101.158:8080/;</span></span><br><span class="line">        <span class="built_in">return</span> http://172.20.101.158:8080/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        root <span class="string">"/var/www/nginx"</span>;</span><br><span class="line">        rewrite ^/(.*)$ https://www.daizhe.111/<span class="variable">$1</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-e 模拟外链来的地址</span><br><span class="line">~]<span class="comment"># curl -I -e "www.baidu.com" http://172.20.101.158/</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nginx-Webserver-第二章：配置指令&quot;&gt;&lt;a href=&quot;#Nginx-Webserver-第二章：配置指令&quot; class=&quot;headerlink&quot; title=&quot;Nginx-Webserver:第二章：配置指令&quot;&gt;&lt;/a&gt;Nginx-Webserver:第二章：配置指令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/09/nginx配置和使用基础2/标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置和使用基础--Webserver</title>
    <link href="https://9527dz.top/2019/01/07/nginx%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://9527dz.top/2019/01/07/nginx配置和使用基础/</id>
    <published>2019-01-07T11:46:19.581Z</published>
    <updated>2019-01-09T13:09:53.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-Webserver-第一章：工作模型"><a href="#Nginx-Webserver-第一章：工作模型" class="headerlink" title="Nginx-Webserver:第一章：工作模型"></a>Nginx-Webserver:第一章：工作模型</h1><p><img src="/2019/01/07/nginx配置和使用基础/标题.png" alt=""><br><a id="more"></a></p><h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>一、Nginx的产生</p><ul><li><p>Nginx是一款高性能的 HTTP 和反向代理服务器，由俄罗斯人Igor Sysoev（伊戈尔·赛索耶夫）为俄罗斯网站Rambler.ru开发的，在Rambler.ru网站平稳的运行了四年，而且俄俄罗斯超过20%的虚拟主机平台采用Nginx作为反向代理服务器。</p></li><li><p>在国内，使用nginx网站用户有：百度、京东、金山爱词霸、新浪、校内网、、淘宝、YUPOO相册、豆瓣、迅雷看看、网易、腾讯等。</p></li></ul><p>二、Nginx的优点</p><ul><li>1.高并发量：根据官方给出的数据，能够支持高达 50,000 个并发连接数的响应</li><li>2.内存消耗少：处理静态文件，同样起web 服务，比apache 占用更少的内存及资源，所有它是轻量级的</li><li>3.简单稳定：配置简单，基本在一个conf文件中配置，性能比较稳定，可以7*24小时长时间不间断运行</li><li>4.模块化程度高：Nginx是高度模块化的设计，编写模块相对简单，包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter，支持 SSL 和 TLSSNI。</li><li>5.支持Rwrite重写规则：能够根据域名、URL的不同， 将HTTP请求分发到不同的后端服务器群组。</li><li>6.低成本：Nginx可以做高并发的负载均衡，且Nginx是开源免费的，如果使用F5等硬件来做负载均衡，硬件成本比较高。 </li><li>7.支持多系统：Nginx代码完全用C语言从头写成，已经移植到许多体系结构和操作系统，包括：Linux、FreeBSD、Solaris、Mac OS X、AIX以及Microsoft Windows，由于Nginx是免费开源的，可以在各系统上编译并使用。</li></ul><p>三、Nginx的缺点</p><ul><li>1.动态处理差：nginx处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用nginx作为反向代理抗住压力，apache作为后端处理动态请求。</li><li>2.rewrite弱：虽然nginx支持rewrite功能，但是相比于Apache来说，Apache比nginx 的rewrite 强大。</li></ul><h2 id="nginx特征及基础概念"><a href="#nginx特征及基础概念" class="headerlink" title="nginx特征及基础概念"></a>nginx特征及基础概念</h2><ul><li><p>nginx(web 服务器、web代理、反向代理)</p><ul><li><p>调用libevent:高性能的网络服务程序库</p><ul><li>epoll():基于事件驱动的开发好的库文件</li></ul></li><li><p>nginx特性：</p><ul><li>模块化设计、较好的扩展性</li><li>高可靠(组成部分一个主控进程+多个子进程组成)<ul><li>master—&gt;worker<ul><li>master主控进程负责解析配置文件，启动子进程（读取和验证配置，创建或绑定关闭套接字以及启动终止worker进程以及控制worker进程的个数，无需重新启动进程让新的配置文件加载、完成平滑版本升级等..）</li><li>worker子进程才是真正响应用户请求的进程（worker子进程有多种种类：有的子进程是实现缓存加载多适用于反向代理、接受用户的请求-接收传入并处理客户端的连接请求，cache实现缓存）</li></ul></li></ul></li><li>低内存消耗（一个线程相应多个请求）<ul><li>10000个保持连接状态模式下的连接nginx仅需2.5MB的内存</li></ul></li><li>支持热部署<ul><li>不停机而且更新配置文件、日志文件滚动、升级程序版本</li></ul></li></ul></li><li>nginx的基本功能<ul><li>支持event模型</li><li>支持epool机制</li><li>支持异步IO（事件驱动）</li><li>支持内存映射</li></ul></li><li>基本功能<ul><li>静态资源的web服务器，能缓存打开的文件描述符</li><li>支持http、smtp、pop3协议的反向代理服务器（缓存加速、缓存在本地是基于键值对关系缓存的，键是用户请求的url,值为对应的取得的数据流极大的减轻了后端服务器的压力）<ul><li>反向代理服务器：仅为接受用户请求并且自行到某个有限的服务器上去取内容（只要是把自己扮演成某个特定服务器的样子）</li><li>正向代理：代表客户端出去请求任何网站(把自己扮演成所有服务器的样子)</li></ul></li><li>支持缓存加速、负载均衡机制（反向代理）</li><li>支持fastcgi(fpm,LNMP),uWSGI(python)等</li><li>模块化（非DSO机制）、过滤器zip，SSI（服务器端包含）及图像打大小调整</li><li>支持ssl</li></ul></li><li>扩展功能<ul><li>基于名称和ip和端口的虚拟主机</li><li>支持keepalive</li><li>支持平滑升级</li><li>定制访问日志、支持日志缓冲区</li><li>支持路径别名</li><li>支持基于ip以及用户的访问控制</li><li>支持速率限制、支持并发数限制</li></ul></li><li>nginx的基本架构特性<ul><li>一个master进程，生成一个或者多个worker进程</li><li>事件驱动：epoll（边缘触发）、Kqueue,/dev/poll</li><li>IO复用器<ul><li>select,poll,rt signal(实时信号)</li></ul></li><li>支持sendfile,sendfile64</li><li>支持AIO（异步IO）</li><li>支持非阻塞模型</li><li>支持内存映射（mmap）</li></ul></li><li>nginx工作模式：基于非阻塞、事件驱动、由一个master进程生成多个worker线程，每一个worker响应n个请求<ul><li>一般单机并发3w请求，在反代的情况下会影响其性能</li></ul></li><li>nginx的模块类型<ul><li>核心模块</li><li>标准的http模块（Standard http modules）</li><li>可选的http模块（Optional http modules ）</li><li>邮件模块（Mail modules）</li><li>第三方模块（3rd party modules）</li></ul></li></ul></li></ul><p><img src="/2019/01/07/nginx配置和使用基础/功能.png" alt=""></p><h2 id="nginx是基于epel源安装"><a href="#nginx是基于epel源安装" class="headerlink" title="nginx是基于epel源安装"></a>nginx是基于epel源安装</h2><pre><code>nginx的安装配置：    官方的预制包：        http://nginx.org/packages/centos/7/x86_64/RPMS/        Fedora-EPEL:</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">yum安装</span><br><span class="line">    yum install nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译安装：</span><br><span class="line">~]<span class="comment"># yum groupinstall "Development Tools" "Server Platform Development"</span></span><br><span class="line">~]<span class="comment"># yum install pcre-devel openssl-devel zlib-devel</span></span><br><span class="line">~]<span class="comment"># useradd -r nginx</span></span><br><span class="line">~]<span class="comment">#  ./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_dav_module --with-http_stub_status_module --with-threads --with-file-aio</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># make &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line">nginx -t    <span class="comment">#检查nginx语法格式</span></span><br><span class="line">nginx -s relod <span class="comment">#重新服务配置文件</span></span><br><span class="line">man nginx</span><br><span class="line">     -s signal      Send a signal to the master process.  The argument signal can be one</span><br><span class="line">                    of: stop, quit, reopen, reload.  The following table shows the cor‐</span><br><span class="line">                    responding system signals:</span><br><span class="line"></span><br><span class="line">                    stop    SIGTERM</span><br><span class="line">                    quit    SIGQUIT</span><br><span class="line">                    reopen  SIGUSR1</span><br><span class="line">                    reload  SIGHUP</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nginx-Webserver-第一章：工作模型&quot;&gt;&lt;a href=&quot;#Nginx-Webserver-第一章：工作模型&quot; class=&quot;headerlink&quot; title=&quot;Nginx-Webserver:第一章：工作模型&quot;&gt;&lt;/a&gt;Nginx-Webserver:第一章：工作模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/07/nginx配置和使用基础/标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>http协议及io模型</title>
    <link href="https://9527dz.top/2019/01/06/io%E6%A8%A1%E5%9E%8B/"/>
    <id>https://9527dz.top/2019/01/06/io模型/</id>
    <published>2019-01-06T07:16:30.928Z</published>
    <updated>2019-01-06T07:19:04.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http协议及io模型"><a href="#http协议及io模型" class="headerlink" title="http协议及io模型"></a>http协议及io模型</h1><p><img src="/2019/01/06/io模型/标题.png" alt=""><br><a id="more"></a></p><h2 id="HTTP-协议和IO模型"><a href="#HTTP-协议和IO模型" class="headerlink" title="HTTP 协议和IO模型"></a>HTTP 协议和IO模型</h2><p>一：HTTP协议</p><ul><li>http协议：HyperText Transfer Procotol超文本传输协议，http协议是无状态的，监听在80端口，TCP协议上。HTTP协议的特点有以下几点：<ul><li>1.支持客户/服务器模式。</li><li>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。</li><li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul></li></ul><p>二：HTTP协议Procatol</p><ul><li><p>在服务器不是持久连接的状况下，客户端在第一次访问服务器时服务器会记录客户端的个人标志信息，当客户端刷新或者再次访问时，服务器就要要求客户端输个人的标识信息，记录访问者的信息。也就是说在不是持久连接的状况下，服务器无法追踪访问者的来源。</p></li><li><p>1.于是就出现了 cookie和session</p><ul><li>html：HyperText Mark Language：超文标记语言</li><li>web资源：<ul><li>静态文件：.jpg .gif .html  .txt .js .css.mp3 .avi</li><li>动态文件：.php  .jsp</li></ul></li></ul></li><li><p>2.http早期版本只能传输文本内容，到HTTP/1.0之后支持MIME。使HTTP协议支持传输多媒体信息。</p></li><li><p>MIME：Multipurpose Internet Mailextention</p><ul><li>MIME类型：Major/minor<ul><li>text/plain</li><li>image/jpeg  </li><li>image/gif</li></ul></li></ul></li><li><p>3.URI:Uniform Resource Idetifier ：统一资源标识符</p><ul><li>URL：Uniform Resource Locate：统一资源定位符</li><li>用于描述某服务特定资源的位置</li><li>格式：Scheme://Server:Poert/Path/to/resource<ul><li>URN：Uniform Resource Naming：统一资源命名符。</li><li>URL方案：scheme</li><li>服务器地址：IP：Port</li><li>资源路径</li><li>基本语法：  <ul><li><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></li></ul></li></ul></li></ul></li><li><p>4.http事务 （请求—&gt;响应）</p><ul><li>request:请求报文<ul><li>报文格式<ul><li><code>&lt;method&gt;&lt;URL&gt;&lt;version&gt;&lt;HEADERS&gt;&lt;body&gt;</code></li><li>请求的方法.url.协议版本.请求报文的首部.主体</li></ul></li></ul></li><li>response:响应报文<ul><li>响应报文<ul><li><code>&lt;version&gt;&lt;status&gt;&lt;reason phrase&gt;&lt;HEADERS&gt;&lt;body&gt;</code></li><li>协议的版本.状态码.原因短语.响应报文的首部.主体</li></ul></li></ul></li><li>协议格式<ul><li>文本</li><li>二进制   </li></ul></li></ul></li><li>5.method：请求的方法：<ul><li>常用请求的方法：  <ul><li>GET：从服务器获取一个资源 </li><li>HEAD：只从服务器获取文档的响应首部</li><li>POST：向服务器发送要处理的数据</li><li>PUT：将请求的主题部分存储服务器上</li><li>DEETE：强求删除服务器上指定的文档</li><li>TRACE：追踪请求到达服务器中间经过的代理服务器</li><li>OPTIONS：请求服务器返回对指定资源支持使用的请求方法</li></ul></li></ul></li></ul><p><img src="/2019/01/06/io模型/请求.png" alt=""></p><p>6.status(状态码)：告诉客户端的请求发生的结果：</p><ul><li>1XX：100-101，信息提示</li><li>2XX：200-206，成功类型信息</li><li>3XX：300-305，重定向的资源</li><li>4XX：400-415，错误类型的信息，客户端的错误，</li><li><p>5XX：500-505，错误类型错误，服务器端错误</p></li><li><p>常用的状态码：</p><ul><li>200：:成功响应，请求的所有数据通过相应报文的entity-body部分发送，OK </li><li>301：请求的URL执行的资源已经被删除；但在相应报文中通过首部Location指明了资源的所在位置；Moved Permanently （永久重定向）</li><li>302：与301相似，但在相应报文中通过首部Location指明了资源现在所处临时新位置；Found  （临时重定向）</li><li>304：客户端发出了条件式请求，但服务器的资源为曾发生改变，则通过相应此响应状态码通知客户端，Not Modified</li><li>401：需要输入账号和密码认证方能访问资源：Unauthorized</li><li>403：请求被禁止：Forbidden</li><li>404：服务器无法找到客户端请求的资源：Not Found</li><li>500：服务器内部错误：InternalServerError</li><li>502：:代理服务器从后端服务器中收到的一条伪响应：Bad Gateway</li></ul></li></ul><ul><li>7.hearders首部：<ul><li>通用首部：<ul><li>Date：报文的创建时间</li><li>Connection：连接状态，keep-alive,close</li><li>via：显示报文经过的中间节点</li><li>Cache-Control：控制缓存<ul><li>no-cache：</li><li>max-age</li></ul></li><li>Transfer-Encoding<ul><li>WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked），例如：Transfer-Encoding: chunked</li></ul></li><li>pragma</li></ul></li></ul></li></ul><p><img src="/2019/01/06/io模型/请求头部.png" alt=""></p><ul><li><p>上图为请求首部：</p><ul><li>Accept：通过服务器自己能够接受的媒体类型</li><li>Accept_Charset</li><li>Accept_Encoding：告诉服务器自己能接受的编码格式，如gzip</li><li>Accept-Language：通知服务器自己能接受的语言</li><li>Host：请求的服务器名称或者端口号</li><li>Referer：包含了当前正在请求的资源的上一级资源。</li><li><p>User-Agent：客户端代理</p></li><li><p>7.1条件式请求首部</p><ul><li>Expect：</li><li>If-Modified-Since：自从指定的时间之后，请求的资源是否发生过修改</li><li>If-Unmodufied-Since：</li><li>If-None-Match：本地缓存中存储的文档的ETag标签是否与服务器文档的Etag不匹配。</li><li>If-Match;</li></ul></li><li>7.2安全请求首部：<ul><li>Authorization:向服务器发送认证信息，如账号密码</li><li>Cookie：客户端向服务器发送cookie</li><li>Cookie2：</li></ul></li><li>7.3代理请求首部：<ul><li>Proxy-authorization:向代理服务器认证</li></ul></li></ul></li><li><p>8.响应首部：</p><ul><li>信息性：<ul><li>Age：响应持续时长</li><li>Server：服务器程序软件名称和版本</li></ul></li><li>协商首部：某资源有多种表示方法时使用<ul><li>Accept-Ranges：服务器可接受的请求范围类型</li><li>Vary：服务器查看的其他首部列表</li></ul></li><li>安全响应首部：<ul><li>Set-Cookie：向客户端设置Cookie</li><li>Set-Cookie2</li><li>WWW-Authenticate：来自服务器的对客户端质询认证表单</li></ul></li></ul></li><li><p>9.实体首部：</p><ul><li>Allow：列出次实体可使用的请求方法：</li><li>Location：告诉客户端真正的实体位于何处</li><li>Content-encoding：编码格式</li><li>Content-language</li><li>Content-Length：实体的长度</li><li>Content-Location：实体真正所在的位置</li><li>Content-Type：主体的对象类型</li><li>缓存相关：<ul><li>Etag:实体的扩展标签</li><li>Expires：实体的过期时间</li></ul></li></ul></li></ul><p>三：web页面，多个资源</p><ul><li><p>浏览器自身的限制是针对于单一域名访问的限制，最多能打开几个线程进行访问，。而在一个公司网站使用多个域名的话，当用户使用浏览器访问时，浏览器会针对不同的域名开启多个线程来访问页面资源。如，在单一域名 <a href="http://www.nginx.com进行访问，浏览器可能开启2个线程进行页面资源的访问。假如在" target="_blank" rel="noopener">www.nginx.com进行访问，浏览器可能开启2个线程进行页面资源的访问。假如在</a> <a href="http://www.nginx.com" target="_blank" rel="noopener">www.nginx.com</a> 域名下的图片资源又单独使用一个域名 <a href="http://www.image.com" target="_blank" rel="noopener">www.image.com</a> 。那么浏览器会再次开启两个线程进行访问。所以在公司内部使用多个域名，这也是提升访问速度的一种方法。</p></li><li><p>1.web服务器的认证：</p><ul><li>基于IP认证：</li><li>基于用户认证：<ul><li>basic认证</li><li>digest认证</li></ul></li></ul></li><li>2.web服务器的资源映射<ul><li>a.DocumentRoot</li><li>b.路径别名Alias</li><li>c.虚拟主机DocumentRoot</li><li>b.用户家目录DocumentRoot</li></ul></li><li>3.支持第三方模块：支持模块的动态加载</li></ul><p>四：一次完整的http请求</p><ul><li>（1）建立连接或处理连接：接收客户端请求或拒绝请求</li><li><p>（2）接收请求</p><ul><li>接收来自网络的请求报文对某一个资源的请求</li><li>并发服务器访问响应模型（Web I/O）<ul><li>单进程I/O机结构：启动一个进程处理用户请求，而且一次只处理一个请求，多个请求被串行响应。</li><li>多进程I/O结构：并行启动多个线程，每个进程响应一个请求，一个请求称为一个pv。</li><li>复用I/O 结构：一个进程响应多个n个请求<ul><li>多线程模型：一个进程生成多个线程，每个线程响应一个用户请求。</li><li>事件驱动机制：事件回调来完成事件请求：event-driven</li><li>复用的多进程I/O结构：启动多个（m）进程，每个进程响应n个请求。</li><li>c10K问题 :1w个并发连接：</li></ul></li></ul></li></ul></li><li><p>（3）处理请求：对请求报文进行解析，并获取请求的资源及请求方法等相关信息</p><ul><li>元数据：请求报文首部</li><li><code>请求方法&lt;method&gt;</code></li><li><code>&lt;method&gt;&lt;URL&gt;&lt;VerSion&gt;</code></li></ul></li><li><p>（4）访问资源:获取请求报文中请求的资源</p><ul><li>web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源，这些资源放置在本地文件系统某路径下，此路径通常为DocRoot</li><li>web服务器资源路径的映射方式：<ul><li>a.docroot</li><li>b.路径别名</li><li>c.虚拟主机docroot</li><li>b.用户家目录docroot</li></ul></li></ul></li><li><p>5）构建响应报文</p><ul><li>MIME类型：<ul><li>显示分类</li><li>魔法分类</li><li>协商分类</li></ul></li><li>URL重定向：<ul><li>cdn</li><li>web服务构建的响应并非客户端请求的资源，而是资源另一个访问路径。</li><li>游走重定向：</li><li>永久重定向：</li></ul></li></ul></li><li>（6）发送响应报文</li><li>（7）记录日志</li></ul><p>五：I/O模型</p><ul><li>(1)I/O类型：</li><li>同步IO和异步IO：synchronous ,asyncronous：关注的是消息通知机制<ul><li>同步：调用发出之后不会立即返回，但一旦返回，则返回最终结果。</li><li>异步：调用发出之后，被调用方立即返回消息，但返回的并不是最终结果被调用者通过状态，通知机制等通知调用者，或通过回调函数来处理结果。 </li></ul></li><li><p>阻塞IO和非阻塞IO：nlock，nonlock：关注的是调用者等待被调用者返回调用结果时的状态：（调用者的状态）</p><ul><li>阻塞：调用结果返回之前，调用者会被挂起；调用真只有在得到调用结果之后才能继续。</li><li>非阻塞：调用者在调用结果返回之前，不会被挂起，即调用不会阻塞调用者 </li></ul></li><li><p>(2)常用的IO模型：</p><ul><li>blocking IO ：阻塞型IO</li><li>noblocking IO 非阻塞型IO</li><li>IO multiplexing：复用型IO</li><li>signal driven IO：事件驱动型IO</li><li>asynchronnous IO：异步型IO</li></ul></li><li><p>通过磁盘IO总体解释：</p><ul><li>一个用户进程发起一次磁盘IO调用时，将有两个阶段组成，一次是内核向磁盘取数据，存放到内存空间，另一次是数据从内存空间取出，将数据存到用户进程的内存中。真正被称为执行IO的阶段是：数据从内核内存到进程内存的过程。</li></ul></li></ul><h3 id="阻塞型IO："><a href="#阻塞型IO：" class="headerlink" title="阻塞型IO："></a><code>阻塞型IO：</code></h3><p><img src="/2019/01/06/io模型/阻塞型.png" alt=""></p><ul><li>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对磁盘read来说内核从磁盘获取数据）。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</li><li>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</li><li>实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</li><li>一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。</li></ul><h3 id="非阻塞IO："><a href="#非阻塞IO：" class="headerlink" title="非阻塞IO："></a><code>非阻塞IO：</code></h3><p><img src="/2019/01/06/io模型/非阻塞型.png" alt=""></p><ul><li>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</li></ul><h3 id="复用型IO："><a href="#复用型IO：" class="headerlink" title="复用型IO："></a><code>复用型IO：</code></h3><ul><li>内核提供了两种调用，select（），poll(),当用户进程发起系统调用时，内核中的selecte会接受这个系统调用，并select自身将系统调用发送给内核，内核再进行准备数据和拷贝数据。当用户进程发起一次系统调用给select之后，用户进程在等待数据返回的过程中，还可以发起多次系统调用，每次系统调用都要经过select发送内核进行处理。也就是说，selects是一个代理。比如，（例子不是很恰当）公司老板向人事部发布通知要裁员，此时老板通过助理把裁员名单送给人事部。在发送和得到结果之前，公司老板还可以通过助理让销售部经理来老板办公室。其实这就相当于复用IO的模型，助理就相当于select。<ul><li>select不能超过1024个。</li><li>prefork模型和worker模型就是基于复用IO模型的。并发响应有限。</li><li>调用者被阻塞者select上，但可以处理其他请求或IO</li></ul></li></ul><h3 id="事件驱动型IO："><a href="#事件驱动型IO：" class="headerlink" title="事件驱动型IO："></a><code>事件驱动型IO：</code></h3><p><img src="/2019/01/06/io模型/事件驱动型.png" alt=""></p><ul><li>事件驱动型IO：<ul><li>在第一阶段内：当用户进程发起系统调用时，内核会立即通知给用户进程系统调用已经收到，并且会在数据收集和准备完成时通知用户进程。此时用户进程就可以处理其他事物。</li><li>在第二阶段内：当系统将磁盘数据取到内存空间中后，通知调用者，调用者会使用回调函数进行处理，来获取数据。这个阶段会发生阻塞状况。</li><li>假如一个用户进程在第一次发送系统调用请求后，在第一阶段内，继续发送第二次系统调用请求。当用户进程第一次请求被阻塞第二阶段时，内核告知用户进程，第二次请求的数据也已经准备好了，让用户进程来获取。此时就出现了冲突状态</li><li>通知机制：<ul><li>水平触发：多次通知</li><li>边缘触发：只通知一次：</li><li>event模型就是使用的此IO模型。</li><li>Nginx支持此IO模型，采用的通知机制为边缘触发。</li></ul></li></ul></li></ul><h3 id="异步型IO："><a href="#异步型IO：" class="headerlink" title="异步型IO："></a><code>异步型IO：</code></h3><p><img src="/2019/01/06/io模型/异步型.png" alt=""></p><ul><li>异步IO模型和复用IO模型区别之处就是：在数据准备第二阶段，内核将数据直接存放到用户进程的内存空间中，不需要用户进程使用回调函数从内核中获取数据。如当一个web服务进程发送请求后，后续过程直接交给内核，在内核处理的过程时间内，此进程可以响应其他的用户请求。当内核将数据返回到进程内存中后，进程就可以把数据直接返回给用户，这大大提高了响应的速度。</li><li>Nginx也支持异步IO模型，还可以基于内存映射的机制来完成数据的发放、所以说Nginx并发能力强。</li></ul><h2 id="几种IO模型的比较"><a href="#几种IO模型的比较" class="headerlink" title="几种IO模型的比较:"></a>几种IO模型的比较:</h2><p><img src="/2019/01/06/io模型/比较.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;http协议及io模型&quot;&gt;&lt;a href=&quot;#http协议及io模型&quot; class=&quot;headerlink&quot; title=&quot;http协议及io模型&quot;&gt;&lt;/a&gt;http协议及io模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/06/io模型/标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://9527dz.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://9527dz.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>四层调度和七层调度器的区别</title>
    <link href="https://9527dz.top/2019/01/05/%E5%9B%9B%E5%B1%82%E8%B0%83%E5%BA%A6%E5%92%8C%E4%B8%83%E5%B1%82%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://9527dz.top/2019/01/05/四层调度和七层调度的区别/</id>
    <published>2019-01-05T08:19:10.670Z</published>
    <updated>2019-01-05T08:35:10.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四层调度和七层调度器的区别"><a href="#四层调度和七层调度器的区别" class="headerlink" title="四层调度和七层调度器的区别"></a>四层调度和七层调度器的区别</h1><p><img src="/2019/01/05/四层调度和七层调度的区别/图标.png" alt=""><br><a id="more"></a></p><p><img src="/2019/01/05/四层调度和七层调度的区别/1111.png" alt=""></p><h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><ul><li><p>简单理解四层和七层负载均衡:</p><ul><li><p>1.所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。 换句换说，二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。</p></li><li><p>2.所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。 比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p></li><li><p>3.负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。</p><ul><li><p>（1）负载均衡分为L4 switch（四层交换），即在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。</p></li><li><p>（2）另一种叫做L7 switch（七层交换），OSI的最高层，应用层。此时，该Load Balancer能理解应用协议。例子：  haproxy，MySQL Proxy。</p></li><li><p>注意：上面的很多Load Balancer既可以做四层交换，也可以做七层交换。</p></li></ul></li></ul></li></ul><h3 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h3><ul><li><p>负载均衡设备也常被称为”四到七层交换机”，那么四层和七层两者到底区别在哪里？</p><ul><li><p>第一，技术原理上的区别。</p><ul><li><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p></li><li><p>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p></li></ul></li></ul></li></ul><pre><code>- `所谓七层负载均衡`，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。- 以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</code></pre><ul><li><p>第二，应用场景的需求。</p><ul><li><p>七层应用负载的好处，是使得整个网络更”智能化”。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p></li><li><p>另外一个常常被提到功能就是安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(DoS)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。</p></li><li><p>现在的7层负载均衡，主要还是着重于应用HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。</p></li></ul></li><li><p>第三，七层应用需要考虑的问题。</p><ul><li><p>1：是否真的必要，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。</p></li><li><p>2：是否真的可以提高安全性。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗DDoS能力，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。</p></li><li><p>3：是否有足够的灵活度。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。</p></li></ul></li></ul><p>　　（本节出自 “ADC技术博客” 博客，请务必保留此出处<a href="http://virtualadc.blog.51cto.com/3027116/591396）" target="_blank" rel="noopener">http://virtualadc.blog.51cto.com/3027116/591396）</a></p><h3 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h3><ul><li><p>负载均衡四七层介绍:</p><ul><li><p>负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p></li><li><p>负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p></li><li><p>本文所要介绍的负载均衡技术主要是指在均衡服务器群中所有服务器和应用程序之间流量负载的应用，目前负载均衡技术大多数是用于提高诸如在Web服务器、FTP服务器和其它关键任务服务器上的Internet服务器程序的可用性和可伸缩性。</p></li></ul></li><li><p>负载均衡技术分类</p><ul><li>目前有许多不同的负载均衡技术用以满足不同的应用需求，下面从负载均衡所采用的设备对象、应用的网络层次（指OSI参考模型）及应用的地理结构等来分类。</li></ul></li><li><p>软/硬件负载均衡</p><ul><li><p>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</p></li><li><p>软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。</p></li><li><p>硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。 </p></li><li><p>负载均衡器有多种多样的形式，除了作为独立意义上的负载均衡器外，有些负载均衡器集成在交换设备中，置于服务器与Internet链接之间，有些则以两块网络适配器将这一功能集成到PC中，一块连接到Internet上，一块连接到后端服务器群的内部网络上。</p></li><li><p>一般而言，硬件负载均衡在功能、性能上优于软件方式，不过成本昂贵。</p></li></ul></li><li><p>本地/全局负载均衡</p><ul><li><p>负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)，本地负载均衡是指对本地的服务器群做负载均衡，全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。</p></li><li><p>本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。 </p></li><li><p>全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet（企业内部互联网）来达到资源统一合理分配的目的。</p></li></ul></li><li><p>网络层次上的负载均衡</p><ul><li><p>针对网络上负载过重的不同瓶颈所在，从网络的不同层次入手，我们可以采用相应的负载均衡技术来解决现有问题。 </p></li><li><p>随着带宽增加，数据流量不断增大，网络核心部分的数据接口将面临瓶颈问题，原有的单一线路将很难满足需求，而且线路的升级又过于昂贵甚至难以实现，这时就可以考虑采用链路聚合（Trunking）技术。</p></li><li><p>链路聚合技术（第二层负载均衡）将多条物理链路当作一条单一的聚合逻辑链路使用，网络数据流量由聚合逻辑链路中所有物理链路共同承担，由此在逻辑上增大了链路的容量，使其能满足带宽增加的需求。</p></li><li><p>现代负载均衡技术通常操作于网络的第四层或第七层。第四层负载均衡将一个Internet上合法注册的IP地址映射为多个内部服务器的IP地址，对每次 TCP连接请求动态使用其中一个内部IP地址，达到负载均衡的目的。在第四层交换机中，此种均衡技术得到广泛的应用，一个目标地址是服务器群VIP（虚拟 IP，Virtual IP address）连接请求的数据包流经交换机，交换机根据源端和目的IP地址、TCP或UDP端口号和一定的负载均衡策略，在服务器IP和VIP间进行映射，选取服务器群中最好的服务器来处理连接请求。</p></li><li><p>第七层负载均衡控制应用层服务的内容，提供了一种对访问流量的高层控制方式，适合对HTTP服务器群的应用。第七层负载均衡技术通过检查流经的HTTP报头，根据报头内的信息来执行负载均衡任务。 </p></li></ul></li><li><p>第七层负载均衡优点表现在如下几个方面： </p><ul><li><p>通过对HTTP报头的检查，可以检测出HTTP400、500和600系列的错误信息，因而能透明地将连接请求重新定向到另一台服务器，避免应用层故障。</p></li><li><p>可根据流经的数据类型（如判断数据包是图像文件、压缩文件或多媒体文件格式等），把数据流量引向相应内容的服务器来处理，增加系统性能。</p></li><li><p>能根据连接请求的类型，如是普通文本、图象等静态文档请求，还是asp、cgi等的动态文档请求，把相应的请求引向相应的服务器来处理，提高系统的性能及安全性。</p></li><li><p>第七层负载均衡受到其所支持的协议限制（一般只有HTTP），这样就限制了它应用的广泛性，并且检查HTTP报头会占用大量的系统资源，势必会影响到系统的性能，在大量连接请求的情况下，负载均衡设备自身容易成为网络整体性能的瓶颈。</p></li></ul></li><li><p>负载均衡策略</p><ul><li><p>在实际应用中，我们可能不想仅仅是把客户端的服务请求平均地分配给内部服务器，而不管服务器是否宕机。而是想使Pentium III服务器比Pentium II能接受更多的服务请求，一台处理服务请求较少的服务器能分配到更多的服务请求，出现故障的服务器将不再接受服务请求直至故障恢复等等。</p></li><li><p>选择合适的负载均衡策略，使多个设备能很好的共同完成任务，消除或避免现有网络负载分布不均、数据流量拥挤反应时间长的瓶颈。在各负载均衡方式中，针对不同的应用需求，在OSI参考模型的第二、三、四、七层的负载均衡都有相应的负载均衡策略。</p></li><li><p>负载均衡策略的优劣及其实现的难易程度有两个关键因素：一、负载均衡算法，二、对网络系统状况的检测方式和能力。 </p></li><li><p>考虑到服务请求的不同类型、服务器的不同处理能力以及随机选择造成的负载分配不均匀等问题，为了更加合理的把负载分配给内部的多个服务器，就需要应用相应的能够正确反映各个服务器处理能力及网络状态的负载均衡算法：</p></li><li><p>轮循均衡（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p></li><li><p>权重轮循均衡（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器A的权值被设计成1，B的权值是 3，C的权值是6，则服务器A、B、C将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p></li><li><p>随机均衡（Random）：把来自网络的请求随机分配给内部中的多个服务器。</p></li><li><p>权重随机均衡（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。</p></li><li><p>响应速度均衡（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p></li><li><p>最少连接数均衡（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。 </p></li><li><p>处理能力均衡：此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。</p></li><li><p>DNS响应均衡（Flash DNS）：在Internet上，无论是HTTP、FTP或是其它的服务请求，客户端一般都是通过域名解析来找到服务器确切的IP地址的。在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的IP地址（即与此负载均衡设备在同一位地理位置的服务器的IP地址）并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p></li><li><p>尽管有多种的负载均衡算法可以较好的把数据流量分配给服务器去负载，但如果负载均衡策略没有对网络系统状况的检测方式和能力，一旦在某台服务器或某段负载均衡设备与服务器网络间出现故障的情况下，负载均衡设备依然把一部分数据流量引向那台服务器，这势必造成大量的服务请求被丢失，达不到不间断可用性的要求。所以良好的负载均衡策略应有对网络故障、服务器系统故障、应用服务故障的检测方式和能力：</p></li><li><p>Ping侦测：通过ping的方式检测服务器及网络系统状况，此种方式简单快速，但只能大致检测出网络及服务器上的操作系统是否正常，对服务器上的应用服务检测就无能为力了。</p></li><li><p>TCP Open侦测：每个服务都会开放某个通过TCP连接，检测服务器上某个TCP端口（如Telnet的23口，HTTP的80口等）是否开放来判断服务是否正常。</p></li><li><p>HTTP URL侦测：比如向HTTP服务器发出一个对main.html文件的访问请求，如果收到错误信息，则认为服务器出现故障。</p></li><li><p>负载均衡策略的优劣除受上面所讲的两个因素影响外，在有些应用情况下，我们需要将来自同一客户端的所有请求都分配给同一台服务器去负担，例如服务器将客户端注册、购物等服务请求信息保存的本地数据库的情况下，把客户端的子请求分配给同一台服务器来处理就显的至关重要了。有两种方式可以解决此问题，一是根据IP地址把来自同一客户端的多次请求分配给同一台服务器处理，客户端IP地址与服务器的对应信息是保存在负载均衡设备上的；二是在客户端浏览器 cookie内做独一无二的标识来把多次请求分配给同一台服务器处理，适合通过代理服务器上网的客户端。</p></li><li><p>还有一种路径外返回模式（Out of Path Return），当客户端连接请求发送给负载均衡设备的时候，中心负载均衡设备将请求引向某个服务器，服务器的回应请求不再返回给中心负载均衡设备，即绕过流量分配器，直接返回给客户端，因此中心负载均衡设备只负责接受并转发请求，其网络负担就减少了很多，并且给客户端提供了更快的响应时间。此种模式一般用于HTTP服务器群，在各服务器上要安装一块虚拟网络适配器，并将其IP地址设为服务器群的VIP，这样才能在服务器直接回应客户端请求时顺利的达成三次握手。</p></li></ul></li><li><p>负载均衡实施要素</p><ul><li><p>负载均衡方案应是在网站建设初期就应考虑的问题，不过有时随着访问流量的爆炸性增长，超出决策者的意料，这也就成为不得不面对的问题。当我们在引入某种负载均衡方案乃至具体实施时，像其他的许多方案一样，首先是确定当前及将来的应用需求，然后在代价与收效之间做出权衡。</p></li><li><p>针对当前及将来的应用需求，分析网络瓶颈的不同所在，我们就需要确立是采用哪一类的负载均衡技术，采用什么样的均衡策略，在可用性、兼容性、安全性等等方面要满足多大的需求，如此等等。 </p></li><li><p>不管负载均衡方案是采用花费较少的软件方式，还是购买代价高昂在性能功能上更强的第四层交换机、负载均衡器等硬件方式来实现，亦或其他种类不同的均衡技术，下面这几项都是我们在引入均衡方案时可能要考虑的问题：</p></li><li><p>性能：性能是我们在引入均衡方案时需要重点考虑的问题，但也是一个最难把握的问题。衡量性能时可将每秒钟通过网络的数据包数目做为一个参数，另一个参数是均衡方案中服务器群所能处理的最大并发连接数目，但是，假设一个均衡系统能处理百万计的并发连接数，可是却只能以每秒2个包的速率转发，这显然是没有任何作用的。性能的优劣与负载均衡设备的处理能力、采用的均衡策略息息相关，并且有两点需要注意：一、均衡方案对服务器群整体的性能，这是响应客户端连接请求速度的关键；二、负载均衡设备自身的性能，避免有大量连接请求时自身性能不足而成为服务瓶颈。有时我们也可以考虑采用混合型负载均衡策略来提升服务器群的总体性能，如DNS负载均衡与NAT负载均衡相结合。另外，针对有大量静态文档请求的站点，也可以考虑采用高速缓存技术，相对来说更节省费用，更能提高响应性能；对有大量ssl/xml内容传输的站点，更应考虑采用ssl/xml加速技术。</p></li><li><p>可扩展性：IT技术日新月异，一年以前最新的产品，现在或许已是网络中性能最低的产品；业务量的急速上升，一年前的网络，现在需要新一轮的扩展。合适的均衡解决方案应能满足这些需求，能均衡不同操作系统和硬件平台之间的负载，能均衡HTTP、邮件、新闻、代理、数据库、防火墙和 Cache等不同服务器的负载，并且能以对客户端完全透明的方式动态增加或删除某些资源。</p></li><li><p>灵活性：均衡解决方案应能灵活地提供不同的应用需求，满足应用需求的不断变化。在不同的服务器群有不同的应用需求时，应有多样的均衡策略提供更广泛的选择。</p></li><li><p>可靠性：在对服务质量要求较高的站点，负载均衡解决方案应能为服务器群提供完全的容错性和高可用性。但在负载均衡设备自身出现故障时，应该有良好的冗余解决方案，提高可靠性。使用冗余时，处于同一个冗余单元的多个负载均衡设备必须具有有效的方式以便互相进行监控，保护系统尽可能地避免遭受到重大故障的损失。</p></li><li><p>易管理性：不管是通过软件还是硬件方式的均衡解决方案，我们都希望它有灵活、直观和安全的管理方式，这样便于安装、配置、维护和监控，提高工作效率，避免差错。在硬件负载均衡设备上，目前主要有三种管理方式可供选择：一、命令行接口（CLI：Command Line Interface），可通过超级终端连接负载均衡设备串行接口来管理，也能telnet远程登录管理，在初始化配置时，往往要用到前者；二、图形用户接口（GUI：Graphical User Interfaces），有基于普通web页的管理，也有通过Java Applet 进行安全管理，一般都需要管理端安装有某个版本的浏览器；三、SNMP（Simple Network Management Protocol，简单网络管理协议）支持，通过第三方网络管理软件对符合SNMP标准的设备进行管理。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;四层调度和七层调度器的区别&quot;&gt;&lt;a href=&quot;#四层调度和七层调度器的区别&quot; class=&quot;headerlink&quot; title=&quot;四层调度和七层调度器的区别&quot;&gt;&lt;/a&gt;四层调度和七层调度器的区别&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/05/四层调度和七层调度的区别/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="lvs" scheme="https://9527dz.top/categories/lvs/"/>
    
    
      <category term="lvs" scheme="https://9527dz.top/tags/lvs/"/>
    
  </entry>
  
  <entry>
    <title>lvs负载均衡</title>
    <link href="https://9527dz.top/2019/01/05/lvs%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://9527dz.top/2019/01/05/lvs负载均衡/</id>
    <published>2019-01-05T05:48:37.097Z</published>
    <updated>2019-01-05T12:43:42.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lvs负载均衡"><a href="#lvs负载均衡" class="headerlink" title="lvs负载均衡"></a>lvs负载均衡</h1><p><img src="/2019/01/05/lvs负载均衡/图标.png" alt=""><br><a id="more"></a></p><h2 id="lvs负载均衡-1"><a href="#lvs负载均衡-1" class="headerlink" title="lvs负载均衡"></a>lvs负载均衡</h2><ul><li>负载均衡集群是 Load Balance(负载均衡器) 集群。是一种将网络上的访问流量分布于各个节点，以降低服务器压力，更好的向客户端提供服务的一种方式。常用<br>的负载均衡。</li><li><p>调度器分类：</p><ul><li>硬负载 (专用硬件)<ul><li>F5-Big Ip</li><li>NetScaler-Citrix</li><li>A10-A10</li></ul></li><li>软负载(pc server)<ul><li>四层：LVS,Nginx(stream模块伪四层),HAProxy（mode tcp）</li><li>七层：Nginx,HAProxy,ATS,Envoy,Traefik,Kong…</li></ul></li></ul></li><li><p>七层调度器（应用程序调度器）</p><ul><li>如果调度器是根据OSI第七层应用层的报文的格式来识别客户端身份并根据算法获取其中数据完成后端客户端挑选的称之为七层调度器或者称之为应用层调度器。。</li></ul></li><li>四层调度器（内核级调度）<ul><li>仅根据客户端请求时请求的套接字（ip+port）完成后端客户端挑选。</li></ul></li></ul><h3 id="一、负载均衡LVS基本介绍"><a href="#一、负载均衡LVS基本介绍" class="headerlink" title="一、负载均衡LVS基本介绍"></a>一、负载均衡LVS基本介绍</h3><ul><li><p>LB集群的架构和原理很简单，就是当用户的请求过来时，会直接分发到Director Server上，然后它把用户的请求根据设置好的调度算法，智能均衡地分发到后端真正服务器(real server)上。为了避免不同机器上用户请求得到的数据不一样，需要用到了共享存储，这样保证所有用户请求的数据是一样的。</p></li><li><p>LVS是 Linux Virtual Server 的简称，也就是Linux虚拟服务器。这是一个由章文嵩博士发起的一个开源项目，它的官方网站是 <a href="http://www.linuxvirtualserver.org" target="_blank" rel="noopener">http://www.linuxvirtualserver.org</a> 现在 LVS 已经是 Linux 内核标准的一部分。使用 LVS 可以达到的技术目标是：通过 LVS 达到的负载均衡技术和 Linux 操作系统实现一个高性能高可用的 Linux 服务器集群，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的性能。LVS 是一个实现负载均衡集群的开源软件项目，LVS架构从逻辑上可分为调度层、Server集群层和共享存储。</p></li></ul><h3 id="二、LVS的基本工作原理"><a href="#二、LVS的基本工作原理" class="headerlink" title="二、LVS的基本工作原理"></a>二、LVS的基本工作原理</h3><p><img src="/2019/01/05/lvs负载均衡/lvs工作原理.png" alt=""></p><h3 id="三、LVS的组成"><a href="#三、LVS的组成" class="headerlink" title="三、LVS的组成"></a>三、LVS的组成</h3><ul><li><p>1.lvs分为两个部分，分别是内核模块和lvs的管理工具。</p><ul><li><p>LVS 由2部分程序组成，包括 ipvs 和 ipvsadm。</p><ul><li>ipvsadm：用户空间的命令行工具，规则管理器，用于管理集群服务及相关的RealServer；</li><li>ipvs：工作于内核空间的netfilter的INPUT钩子之上的框架；</li></ul></li><li><p>目前来说，centos7及其以上的内核版本已经包括了ipvs的相关模块了。</p></li></ul></li></ul><p><code>内核支持的ipvs模块</code><br><img src="/2019/01/05/lvs负载均衡/lvs组成.png" alt=""></p><ul><li>上图中的rr，wrr，lc，wlc，lblc等等都是lvs中调度器的调度算法，根据不同的调度算法可以更好的分配服务，实现负载均衡。</li><li>而ipvs(ip virtual server)：一段代码工作在内核空间，实现调度。</li></ul><p><code>ipvsadm客户端管理工具</code><br><img src="/2019/01/05/lvs负载均衡/lvs组成2.png" alt=""></p><ul><li>上图是ipvsadm。负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调度算法为内建在内核中的模块一共有10种</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># grep -i "ip_vs" /boot/config-3.10.0-862.el7.x86_64 </span></span><br><span class="line">CONFIG_IP_VS=m</span><br><span class="line">CONFIG_IP_VS_IPV6=y</span><br><span class="line"><span class="comment"># CONFIG_IP_VS_DEBUG is not set</span></span><br><span class="line">CONFIG_IP_VS_TAB_BITS=12</span><br><span class="line">CONFIG_IP_VS_PROTO_TCP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_UDP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_AH_ESP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_ESP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_AH=y</span><br><span class="line">CONFIG_IP_VS_PROTO_SCTP=y</span><br><span class="line">CONFIG_IP_VS_RR=m</span><br><span class="line">CONFIG_IP_VS_WRR=m</span><br><span class="line">CONFIG_IP_VS_LC=m</span><br><span class="line">CONFIG_IP_VS_WLC=m</span><br><span class="line">CONFIG_IP_VS_LBLC=m</span><br><span class="line">CONFIG_IP_VS_LBLCR=m</span><br><span class="line">CONFIG_IP_VS_DH=m</span><br><span class="line">CONFIG_IP_VS_SH=m</span><br><span class="line">CONFIG_IP_VS_SED=m</span><br><span class="line">CONFIG_IP_VS_NQ=m</span><br><span class="line">CONFIG_IP_VS_SH_TAB_BITS=8</span><br><span class="line">CONFIG_IP_VS_FTP=m</span><br><span class="line">CONFIG_IP_VS_NFCT=y</span><br><span class="line">CONFIG_IP_VS_PE_SIP=m</span><br></pre></td></tr></table></figure></li></ul><p>四.LVS的调度算法<br>前面已经说了，调度器（directory） 是通过一定的调度算法将服务请求一个一个的分发下去。现在了解一下调度算法</p><ul><li><code>LVS一共有10种调度算法。</code>  <ul><li>静态算法（算法仅根据算法本身与请求报文特征进行调度 起点公平）</li><li>动态算法（额外考虑后端各RS的当前的负载的状态  结果公平）  </li></ul></li></ul><p><code>静态调度算法（4个）</code></p><ul><li>1.rr（轮叫调度）<ul><li>轮叫调度：这种是最简单的调度算法，就是将请求A一个，B一个，A一个，B一个 …… 循环的发。就算A主机挂掉了，调度器还是会将请求发送到A。十分均衡。</li></ul></li><li>2.wrr（加权轮叫）<ul><li>加权轮叫调度：这种算法是在rr基础上实现的，只不过加了权重，权重范围为1-100，假设A的服务器性能好，就给A的权重设置的高一点，设为2，而B主机是1。这样就实现A二个，B一个，A二个，B一个 …… 循环的发。这样照顾到了服务器性能。</li></ul></li><li>3.sh（源地址哈希）<ul><li>源地址散列：主要是实现将此前的session（会话）绑定。将此前客户的源地址作为散列键，从静态的散列表中找出对应的服务器，只要目标服务器是没有超负荷的就将请求发送过去。就是说某客户访问过A,现在这个客户又来了，所以客户请求会被发送到服务过他的A主机。</li></ul></li><li>4.dh（目的地址哈希）<ul><li>目的地址散列：以目的地址为关键字查找一个静态hash表来获得需要的RS。以目标地址为标准挑选。 功能是和sh近似的，但应用场景不同<ul><li>（dh举个例子：假设1号客户访问了web集群的一个动态页面，调度器将请求转发个A服务器，A服务器的PHP将这个动态请求运行了一遍，生成了缓存并回应1号客户。这下2号客户也访问了这个动态页面，调度器应该将请求发给A。毕竟A已经跑过这段程序了，有缓存，对吧。所以这既是dh算法）</li></ul></li></ul></li></ul><p>接下来是动态算法，动态算法与静态算法最大的区别就是动态算法考虑了服务器的压力。<br>活动链接（active）：客户与服务器建立连接并且有数据传送<br>非活动链接（inactive）：只是建立连接，没有数据传送，没有断开连接  </p><p><code>动态调度算法（6个）</code></p><ul><li>1.lc（最少链接）<ul><li>最少连接调度：这种算法是看A，和B的主机谁的连接少，请求就发给谁，如果负载相同，自上而下调度。</li><li>负载的简单算法：active*256+inactive  （谁小发给谁）</li></ul></li><li>2.wlc（加权最少链接）LVS的理想算法，也是默认的算法<ul><li>加权最少链接：这种算法就是比lc多了一个加权。</li><li>简单算法：( active*256+inactive )/weight    (谁小就发给谁)</li></ul></li><li>3.sed（最短期望延迟）<ul><li>基于wlc算法，假设A，B的权重分别是1，2 。而A的链接数为1，B的链接数为2 。这样的话，用wlc算法得出的结果一样，而明显B的权重大，B的能力较强。用sed算法的话，就可以避免wlc出现的问题。</li><li>简单算法：（active+1)<em>256/weight （活动的连接数+1）</em>256/除以权重  谁小发给谁<ul><li>A：（1+1）/1</li><li>B：（2+1）/2  （B小，交给B）</li></ul></li></ul></li><li>4.nq（永不排队）<ul><li>基于sed算法：在sed的基础上，若谁的链接数为0，直接将请求发送给他，没二话</li></ul></li><li>5.LBLC（基于局部性的最少连接）类似于dh，目标地址hash<ul><li>这个算法主要用于Cache集群系统，因为Cache集群的中客户请求报文的目标IP地址的变化，将相同的目标URL地址请求调度到同一台服务器，来提高服务器的访问的局部性和Cache命中率。从而调整整个集群的系统处理能力。但是，如果realserver的负载处于一半负载，就用最少链接算法，将请求发送给活动链接少的主机。</li></ul></li><li>6.LBLCR（带复制的基于局部性的最少链接）<ul><li>该算法首先是基于最少链接的，当一个新请求收到后，一定会将请求发给最少连接的那台主机的。但这样又破坏了cache命中率。但这个算法中，集群服务是cache共享的，假设A的PHP跑了一遍，得到缓存。但其他realserver可以去A那里拿缓存，这是种缓存复制机制。</li></ul></li></ul><h3 id="五、lvs类型（工作拓扑结构及转发机制）"><a href="#五、lvs类型（工作拓扑结构及转发机制）" class="headerlink" title="五、lvs类型（工作拓扑结构及转发机制）"></a>五、lvs类型（工作拓扑结构及转发机制）</h3><ul><li>LVS 的工作模式分为4中分别是 NAT，DR，TUN，FULL-NAT。其中做个比较，由于工作原理的关系的，NAT的配置最为简单，但是NAT对调度器的压力太大了，导致其效率最低，DR和TUN的工作原理差不多，但是DR中，所有主机必须处于同一个物理环境中，而在TUN中，所有主机可以分布在不同的位置，服务器一个在纽约，一个在深圳。最多应用的是FULL-NAT。</li></ul><p><img src="/2019/01/05/lvs负载均衡/工作类型.png" alt=""></p><ul><li>lvs-nat：修改请求报文的目标IP,多目标IP的DNAT</li><li>lvs-dr：操纵封装新的MAC地址</li><li>lvs-tun：在原请求IP报文之外新加一个IP首部</li><li>lvs-fullnat：修改请求报文的源和目标IP</li></ul><hr><p><img src="/2019/01/05/lvs负载均衡/解析.png" alt=""></p><ul><li>其中的专业术语<ul><li><ol><li>DS：Director Server。指的是前端负载均衡器。</li></ol></li><li><ol start="2"><li>RS：Real Server。后端真实的工作服务器。</li></ol></li><li><ol start="3"><li>VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址。</li></ol></li><li><ol start="4"><li>DIP：Director Server IP，主要用于和内部主机通讯的IP地址。</li></ol></li><li><ol start="5"><li>RIP：Real Server IP，后端服务器的IP地址。</li></ol></li><li><ol start="6"><li>CIP：Client IP，访问客户端的IP地址。</li></ol></li></ul></li></ul><p><code>1.NAT模式</code></p><p><img src="/2019/01/05/lvs负载均衡/NAT.png" alt=""></p><ul><li><p>客户发出请求，发送请求给链接调度器的VIP，调度器将请求报文中的目标Ip地址改为RIP。这样服务器RealServer将请求的内容发给调度器，调度器再将报文中的源IP地址改为VIP。</p><ul><li>(a). 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP</li><li>(b). PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链</li><li>(c). IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP</li><li>(d). POSTROUTING链通过选路，将数据包发送给Real Server</li><li>(e). Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP</li><li>(f). Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP</li></ul></li><li><p>Nat模型的特点</p><ul><li>1.很好配置，原理简单易懂</li><li>2.由于调度器的工作量太大，很容易成为整个集群系统的瓶颈。</li><li>3.RS应该使用私有地址，RS的网关必须指向DIP</li><li>4.支持端口映射</li><li>5.多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发；</li><li>6.RIP和DIP必须在同一个IP网络，且应该使用私网地址；RS的网关要指向DIP；</li><li>7.请求报文和响应报文都必须经由Director转发；Director易于成为系统瓶颈；</li><li>8.支持端口映射，可修改请求报文的目标PORT；</li><li>9.vs必须是Linux系统，rs可以是任意系统；</li></ul></li></ul><p><code>2.DR模式</code><br><img src="/2019/01/05/lvs负载均衡/DR.png" alt=""></p><ul><li><p>整个DR模式都是停留在第二层的数据链路层。直接修改MAC。实现报文的转发。</p><ul><li>(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP</li><li>(b) PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链</li><li>(c) IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址</li><li>(d) 由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。</li><li>(e) RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的源IP地址为VIP，目标IP为CIP</li><li>(f) 响应报文最终送达至客户端</li></ul></li><li><p>LVS-DR的特点</p><ul><li>1.在前端路由器做静态地址路由绑定，将对于VIP的地址仅路由到Director Server</li><li>2.arptables：在arp的层次上实现在ARP解析时做防火墙规则，过滤RS响应ARP请求。</li><li>3.修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在网卡接口的别名上，并限制其不能响应对VIP地址解析请求。</li><li>4.确保前端路由器将目标IP为VIP的请求报文发往Director：<ul><li>(a) 在前端网关做静态绑定；</li><li>(b) 在RS上使用arptables；</li><li>(c) 在RS上修改内核参数以限制arp通告及应答级别；<ul><li>arp_announce</li><li>arp_ignore</li></ul></li></ul></li><li>5.RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director；</li><li>6.RS跟Director要在同一个物理网络；</li><li>7.请求报文要经由Director，但响应不能经由Director，而是由RS直接发往Client；</li><li>8.不支持端口映射；</li></ul></li></ul><p><code>3.TUN模式</code><br><img src="/2019/01/05/lvs负载均衡/TUN.png" alt=""></p><ul><li><p>和DR模式差不多，但是比DR多了一个隧道技术以支持realserver不在同一个物理环境中。就是realserver一个在北京，一个工作在上海。</p></li><li><p>在原有的IP报文外再次封装多一层IP首部，内部IP首部(源地址为CIP，目标IIP为VIP)，外层IP首部(源地址为DIP，目标IP为RIP</p><ul><li>(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP 。</li><li>(b) PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链</li><li>(c) IPVS比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层IP报文，封装源IP为为DIP，目标IP为RIP。然后发至POSTROUTING链。 此时源IP为DIP，目标IP为RIP</li><li>(d) POSTROUTING链根据最新封装的IP报文，将数据包发至RS（因为在外层封装多了一层IP首部，所以可以理解为此时通过隧道传输）。 此时源IP为DIP，目标IP为RIP</li><li>(e) RS接收到报文后发现是自己的IP地址，就将报文接收下来，拆除掉最外层的IP后，会发现里面还有一层IP首部，而且目标是自己的lo接口VIP，那么此时RS开始处理此请求，处理完成之后，通过lo接口送给eth0网卡，然后向外传递。 此时的源IP地址为VIP，目标IP为CIP</li><li>(f) 响应报文最终送达至客户端</li></ul></li><li><p>LVS-TUN的特点</p><ul><li>1 .RIP、VIP、DIP全是公网地址</li><li>2.RS的网关不会也不可能指向DIP</li><li>3.不支持端口映射</li><li>4.RS的系统必须支持隧道</li></ul></li></ul><p><code>lvs-fullnat模式：</code></p><ul><li>通过同时修改请求报文的源IP地址和目标IP地址进行转发；<ul><li>CIP <--> DIP </--></li><li>VIP <--> RIP </--></li><li>lvs-fullnat    特点：            </li></ul></li><li>(1) VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP；</li><li>(2) RS收到的请求报文源地址是DIP，因此，只能响应给DIP；但Director还要将其发往Client；</li><li>(3) 请求和响应报文都经由Director；</li><li>(4) 支持端口映射；        </li><li>注意：此类型默认不支持；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lvs负载均衡&quot;&gt;&lt;a href=&quot;#lvs负载均衡&quot; class=&quot;headerlink&quot; title=&quot;lvs负载均衡&quot;&gt;&lt;/a&gt;lvs负载均衡&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/05/lvs负载均衡/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="lvs" scheme="https://9527dz.top/categories/lvs/"/>
    
    
      <category term="lvs" scheme="https://9527dz.top/tags/lvs/"/>
    
  </entry>
  
  <entry>
    <title>docker资源限制以及compose基础应用</title>
    <link href="https://9527dz.top/2019/01/04/docker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    <id>https://9527dz.top/2019/01/04/docker资源限制/</id>
    <published>2019-01-04T13:03:24.175Z</published>
    <updated>2019-01-05T03:56:28.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker资源限制以及compose基础应用"><a href="#docker资源限制以及compose基础应用" class="headerlink" title="docker资源限制以及compose基础应用"></a>docker资源限制以及compose基础应用</h1><p><img src="/2019/01/04/docker资源限制/图标.png" alt=""><br><a id="more"></a></p><h2 id="docker资源限制"><a href="#docker资源限制" class="headerlink" title="docker资源限制"></a>docker资源限制</h2><ul><li><p>在使用docker运行容器时，一台主机上可能会运行几百个容器，这些容器虽然互相隔离，但是底层却使用着相同的CPU，内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会互相影响，小的来说会导致容器资源使用不公平;大的来说，可能会导致主机和集群资源耗尽，服务完全不可用.docker </p></li><li><p>作为容器的管理者，自然提供了控制容器资源的功能。正如使用内核的命名空间来做赚容器之间的隔离，docker也是通过内核的cgroups来做容器的资源限制。</p></li></ul><h3 id="1-内存（不可压缩资源）"><a href="#1-内存（不可压缩资源）" class="headerlink" title="1. 内存（不可压缩资源）"></a>1. 内存（不可压缩资源）</h3><ul><li>1.1 了解耗尽内存的风险</li><li><p>不让正在运行的容器消耗太多的主机内存是很重要的。在 Linux 主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出一个 OOME内存耗尽 或 Out Of Memory Exception，并开始查杀进程以释放内存。任何进程都可能被杀掉，包括 Docker 和其他重要应用程序。如果终止了错误进程，有可能导致系统宕机。</p></li><li><p>Docker 尝试通过调整 Docker 守护进程的 OOM 优先级来降低这些风险，从而使其和系统上的其他进程相比更不容易被杀掉。容器的 OOM 优先级不调整。这使得单个容器被杀死的可能性要比 Docker 守护进程或其他系统进程被终止的可能性要大。不应该通过手动将守护程序或容器上的 –oom-score-adj 设置为极端负数，或通过在容器上设置 –oom-disable-kill 来尝试规避这些安全措施。</p></li><li>生产环境一般不建议使用swap，因为使用swap会严重影响服务器性能。</li></ul><ul><li><p>选项    描述</p><ul><li>-m 或 –memory=    容器可用的最大内存。如果设置了这个值，最小可用内存是 4MB。</li><li>–memory-swap*    允许容器放入磁盘 swap 中的内存数量。</li><li>–memory-swappiness    默认情况下，主机内核可以交换容器使用的匿名页面的百分比。可以设置为介于0和100之间的值，以调整此百分比。用来定义系统是使用的交换分区的倾向性（数值越大越倾向使用，数值越低越少越晚的使用能不用则不用）</li><li>–memory-reservation    软限制。指定一个小于 –memory 的软限制，当 Docker 检测到主机上的争用或内存不足时，会采用这个限制来替换 –memory。如果使用这个限制，则必须将其设置为低于 –memory，以使其优先。不能保证容器不会超出限制。</li><li>–kernel-memory    容器可以使用的最大内核内存量。允许的最小值是 4m。由于内核内存不能被换出，因此内核内存不足的容器可能会阻塞主机资源，这会对主机和其他容器产生副作用。</li><li>–oom-kill-disable    默认情况下，如果发生内存不足（OOM）错误，内核会杀死容器中的进程。使用 –oom-kill-disable 选项可以更改此行为。注意只能在同时设置了-m/–memory 选项的容器上使用此选项，因为如果未设置 -m 标志，可能会耗尽主机的内存，导致内核需要终止主机系统的进程以释放内存。</li></ul></li><li><p>1.2 限制容器对内存的访问</p><ul><li>Docker 可以对内存实施两种限制：硬限制，允许容器使用不超过给定数量的用户或系统内存；软限制，允许容器使用尽可能多的内存，除非满足某些条件，例如内核检测到内存不足或主机上的争用。其中一些选项在单独使用或同时设置多个选项时会有不同的效果。</li><li>这些选项大多数都是一个正整数，后跟一个后缀 b，k，m，g，以表示字节，千字节，兆字节或千兆字节。</li></ul></li></ul><p><img src="/2019/01/04/docker资源限制/内存资源限制.png" alt=""></p><ul><li><p>1.3 –memory-swap 详情</p><ul><li>–memory-swap 是一个修饰符标志，只有在 –memory 也被设置时才有意义。使用 swap 使得容器可以在耗尽所有可用 RAM 时，将多余的内存需求写入磁盘。对于经常将内存交换到磁盘的应用程序会有性能损失。</li></ul><ul><li><p>其设置可能会产生复杂的效果：</p><ul><li>如果 –memory-swap 设置为正整数，那么 –memory 和 –memory-swap 都需要设置。–memory-swap 表示所有可用的内存和 swap 之和，并且 –memory 控制非 swap 内存数量。因此，如果 –memory=”300m” 和 –memory-swap=”1g”，则容器可以使用 300MB 内存和 700MB swap。</li><li>如果 –memory-swap 设置为 0，则会忽略这个设置。</li><li>如果 –memory-swap 设置的值与 –memory相同，并且 –memory 设置为正整数，则容器无法访问 swap。</li><li>如果 –memory-swap 未设置，并且 –memory 设置了，如果主机容器配置了交换内存，则容器会使用 –memory 设置值的两倍作为 swap 的大小。例如，如果 –memory=”300m”，–memory-swap没有设置，则容器可以使用 300MB 内存和 600MB swap。</li><li>如果 –memory-swap 显式设置为 -1，允许容器使用无限制的 swap，直到达到主机系统可用值。</li></ul></li></ul></li><li><p>禁止容器使用 SWAP</p><ul><li>如果 –memory-swap 设置的值与 –memory相同，则容器无法访问 swap。这是因为 –memory-swap 设置的值是可用的内存与 swap 之和，而 –memory 是可用的物理内存量。</li></ul></li><li><p>1.4 –memory-swappiness 详情</p><ul><li>值为 0 时，关闭匿名页的 swap。</li><li>值为 100 时，所有匿名页都可以 swap。</li><li>默认情况下，如果没有设置 –memory-swappiness，会从主机继承这个值。</li></ul></li><li>1.5 –kernel-memory 详情<ul><li>内核内存限制以分配给指定容器的全部内存来表示。考虑以下情况：<ul><li>无限内存，无限内核内存：这是默认行为。</li><li>无限内存，有限内核内存：当所有 cgroup 所需的内存大于主机上实际存在的内存时，这是合适的。可以将内核内存配置为永远不会覆盖主机上可用的内容，而需要更多内存的容器需要等待。</li><li>有限内存，无限内核内存：整个内存是有限的，但内核内存不是。</li><li>有限内存，有限内核内存：限制用户和内核内存可用于调试与内存相关的问题。如果某个容器对任意一种内存的使用数量超量，则会导致内存不足但不会影响其他容器或主机。在此设置下，如果内核内存限制低于用户内存限制，则内核内存用尽会导致容器遇到 OOM 错误。如果内核内存限制高于用户内存限制，则内核限制不会导致容器体验 OOM。</li></ul></li></ul></li><li>当打开任何内核内存限制时，主机会在每个进程的基础上跟踪“high water mark”（高位标记）统计信息，以便跟踪哪些进程（在这种情况下是容器）正在使用多余的内存。可以通过在主机上查看 /proc/<pid>/status 来查看每个进程。</pid></li></ul><h3 id="2-CPU（可压缩资源）"><a href="#2-CPU（可压缩资源）" class="headerlink" title="2. CPU（可压缩资源）"></a>2. CPU（可压缩资源）</h3><ul><li><p>默认情况下，每个容器对主机 CPU 的周期访问是无限的。可以设置各种约束来限制给定容器访问主机的 CPU 周期。大多数用户使用和配置默认的 CFS 调度器。在 Docker 1.13 及更高版本中，还可以配置实时调度器</p></li><li><p>2.1 配置默认的 CFS 调度器</p><ul><li>CFS 是用于普通 Linux 进程的 Linux 内核 CPU 调度程序。几个运行时标志允许配置容器的 CPU 资源访问量。使用这些设置时，Docker 会修改主机上容器的 cgroup 设置。</li></ul></li></ul><p><img src="/2019/01/04/docker资源限制/cpu.png" alt=""></p><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><p>此镜像可以进行压测，参考镜像地址：<a href="https://hub.docker.com/r/lorel/docker-stress-ng" target="_blank" rel="noopener">https://hub.docker.com/r/lorel/docker-stress-ng</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拖下测试镜像</span><br><span class="line">  [root@centos7 ~]<span class="comment"># docker pull lorel/docker-stress-ng</span></span><br><span class="line"></span><br><span class="line">查看镜像的使用帮助</span><br><span class="line">  [root@centos7 ~]<span class="comment"># docker run --name pc1 -it --rm lorel/docker-stress-ng --help</span></span><br></pre></td></tr></table></figure><h2 id="docker-compose容器编排工具"><a href="#docker-compose容器编排工具" class="headerlink" title="docker compose容器编排工具"></a><code>docker compose容器编排工具</code></h2><p>官网：<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">https://docs.docker.com/compose/</a></p><ul><li><p>1.Compose介绍</p><ul><li>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。 </li><li>Compose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</li></ul></li><li><p>2.Compose和Docker兼容性</p></li></ul><p><img src="/2019/01/04/docker资源限制/兼容.png" alt=""></p><ul><li>Docker版本变化说明：<ul><li>Docker从1.13.x版本开始，版本分为企业版EE和社区版CE，版本号也改为按照时间线来发布，比如17.03就是2017年3月。</li><li>Docker的linux发行版的软件仓库从以前的<a href="https://apt.dockerproject.org和https://yum.dockerproject.org变更为目前的https://download.docker.com" target="_blank" rel="noopener">https://apt.dockerproject.org和https://yum.dockerproject.org变更为目前的https://download.docker.com</a>, 软件包名字改为docker-ce和docker-ee。</li></ul></li></ul><p>范例：打算部署一个wordpress<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">WordPress:</span><br><span class="line"></span><br><span class="line">1. 在你的主文件夹中创建一个名为my_wordpress的新目录，并将<span class="built_in">cd</span>放入其中:</span><br><span class="line"><span class="comment">#yum install docker-compose</span></span><br><span class="line"><span class="comment"># systemctl start docker</span></span><br><span class="line"><span class="comment"># mkdir ~/my_wordpress/</span></span><br><span class="line"><span class="comment"># cd ~/my_wordpress/ </span></span><br><span class="line"><span class="comment"># docker pull wordpress:latest</span></span><br><span class="line"><span class="comment"># docker pull mysql:5.7</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">2. 创建一个名为docker-compose的文件。并在此文件夹中添加以下内容。为WORDPRESS_DB_PASSWORD、MYSQL_ROOT_PASSWORD和MYSQL_PASSWORD环境选项设置您自己的密码。为WORDPRESS_DB_PASSWORD和MYSQL_PASSWORD输入的密码应该相同。</span><br><span class="line"></span><br><span class="line"><span class="comment"># rpm -q docker-compose</span></span><br><span class="line"><span class="comment">#docker-compose-1.18.0-2.el7.noarch</span></span><br><span class="line"></span><br><span class="line">vim docker-compose.yml</span><br><span class="line">version: <span class="string">'3.3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">   wordpress: <span class="comment">#服务</span></span><br><span class="line">     depends_on:</span><br><span class="line">       - db</span><br><span class="line">     image: wordpress:latest  <span class="comment">#互联网镜像为wordpress(http、php、php-mysql、wordpress)</span></span><br><span class="line">     volumes:</span><br><span class="line">       - wordpress_files:/var/www/html</span><br><span class="line">     ports:</span><br><span class="line">       - <span class="string">"80:80"</span> <span class="comment">#端口映射,左侧宿主机右侧容器</span></span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       WORDPRESS_DB_HOST: db:3306</span><br><span class="line">       WORDPRESS_DB_NAME: wordpress</span><br><span class="line">       WORDPRESS_DB_USER: wordpress</span><br><span class="line">       WORDPRESS_DB_PASSWORD: my_wordpress_db_password</span><br><span class="line"></span><br><span class="line">   db: <span class="comment">#服务</span></span><br><span class="line">     image: mysql:5.7</span><br><span class="line">     volumes:</span><br><span class="line">       - db_data:/var/lib/mysql</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       MYSQL_ROOT_PASSWORD: my_db_root_password</span><br><span class="line">       MYSQL_DATABASE: wordpress</span><br><span class="line">       MYSQL_USER: wordpress</span><br><span class="line">       MYSQL_PASSWORD: my_wordpress_db_password</span><br><span class="line">volumes:</span><br><span class="line">    wordpress_files:</span><br><span class="line">    db_data: </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">3. 从my_wordpress目录，开始你的Docker容器:</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker-compose up -d    </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">4. Docker容器启动WordPress和MySQL需要一到两分钟。之后，您可以在web浏览器中访问您的IP地址，您应该被引导到WordPress设置表单。</span><br><span class="line"> </span><br><span class="line">文档出处，</span><br><span class="line">    https://www.linode.com/docs/quick-answers/linux/wordpress-with-docker-compose/</span><br></pre></td></tr></table></figure></p><p>docker ps 命令：</p><pre><code>过滤器：过滤标志(-f或–filter)格式是key=value。如果超过一个过滤，就传递多个标志(如–filter “foo=bar” –filter “bif=baz”)目前支持的过滤有如下这些:    id(容器id)    label(label=或label=&gt;)    name(容器名称)    exited(整数 – 容器退出码。只在使用–all才有用)    status (created restarting running paused exited dead)    ancestor([:], or ) – 过滤从指定镜像创建的容器。    before (容器的名称或id) – 过滤在给定id或名称之前创建的容器。    since (容器的名称或id) – 过滤在给定id或名称之后创建的容器。    isolation (default process hyperv) (Windows daemon only)    volume (数据卷名称或挂载点) – 过滤挂载有指定数据卷的容器。    network (网络id或名称) – 过滤连接到指定网络的容器。--format为格式化输出。格式化选项(–format)使用Go模板来美化打印容器输出。Go模板有效的占位符如下：    .ID 容器ID    .Image 镜像ID    .Command Quoted command    .CreatedAt 创建容器的时间点.    .RunningFor 从容器创建到现在过去的时间.    .Ports 暴露的端口.    .Status 容器状态.    .Size 容器占用硬盘大小.    .Names 容器名称.    .Labels 容器所有的标签.    .Label 指定label的值 例如&apos;{{.Label “com.docker.swarm.cpu”}}’    .Mounts 挂载到这个容器的数据卷名称Docker参考手册：    https://docs.docker.com/engine/reference/commandline/dockerd/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker资源限制以及compose基础应用&quot;&gt;&lt;a href=&quot;#docker资源限制以及compose基础应用&quot; class=&quot;headerlink&quot; title=&quot;docker资源限制以及compose基础应用&quot;&gt;&lt;/a&gt;docker资源限制以及compose基础应用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/04/docker资源限制/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker私有仓库</title>
    <link href="https://9527dz.top/2019/01/03/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    <id>https://9527dz.top/2019/01/03/docker私有仓库和资源限制/</id>
    <published>2019-01-03T11:55:04.058Z</published>
    <updated>2019-01-04T13:02:35.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker私有仓库"><a href="#docker私有仓库" class="headerlink" title="docker私有仓库"></a>docker私有仓库</h1><p><img src="/2019/01/03/docker私有仓库和资源限制/图标.png" alt=""><br><a id="more"></a></p><h2 id="ocker-Registry-分类"><a href="#ocker-Registry-分类" class="headerlink" title="ocker Registry 分类"></a>ocker Registry 分类</h2><ul><li>Registry用于保存docker镜像，包括镜像的层次结构和元数据 </li><li>用户可自建Registry，也可使用官方的Docker Hub </li><li>分类  <ul><li>Sponsor Registry：第三方的registry，供客户和Docker社区使用 </li><li>Mirror Registry：第三方的registry，只让客户使用 </li><li>Vendor Registry：由发布Docker镜像的供应商提供的registry </li><li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供的registry</li></ul></li></ul><h2 id="Registry-repository-and-index"><a href="#Registry-repository-and-index" class="headerlink" title="Registry(repository and index)"></a>Registry(repository and index)</h2><ul><li>Repository <ul><li>由某特定的docker镜像的所有迭代版本组成的镜像仓库 </li><li>一个 Registry中可以存在多个Repository <ul><li>Repository可分为“顶层仓库”和“用户仓库” </li><li>用户仓库名称格式为“用户名/仓库名” </li></ul></li><li>每个仓库可以包含多个Tag(标签) ，每个标签对应一个镜像 </li><li>Index <ul><li>维护用户帐户、镜像的校验以及公共命名空间的信息 </li><li>相当于为Registry提供了一个完成用户认证等功能的检索接口</li></ul></li></ul></li></ul><p><img src="/2019/01/03/docker私有仓库和资源限制/仓库类型.png" alt=""></p><h2 id="docker简单的私有仓库"><a href="#docker简单的私有仓库" class="headerlink" title="docker简单的私有仓库"></a>docker简单的私有仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 yum.repos.d]<span class="comment"># yum info docker-distribution</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Repository extras is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.huaweicloud.com</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.huaweicloud.com</span><br><span class="line">Available Packages</span><br><span class="line">Name        : docker-distribution</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 2.6.2</span><br><span class="line">Release     : 2.git48294d9.el7</span><br><span class="line">Size        : 3.5 M</span><br><span class="line">Repo        : extras/7/x86_64</span><br><span class="line">Summary     : Docker toolset to pack, ship, store, and deliver content</span><br><span class="line">URL         : https://github.com/docker/distribution</span><br><span class="line">License     : ASL 2.0</span><br><span class="line">Description : Docker toolset to pack, ship, store, and deliver content </span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">############################实验前提#######################</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#说明:Docker工具集用于打包、运输、存储和交付内容</span></span><br><span class="line"></span><br><span class="line">实现自建简单的docker私有仓库  </span><br><span class="line">  两台主机间共享私用仓库</span><br><span class="line">    发送镜像端:172.18.135.1</span><br><span class="line">    distribution服务器：主机名为www.centos7.com(172.18.135.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################接收镜像的节点distribution服务器#########</span></span><br><span class="line"><span class="comment">###############################安装docker##################</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment">#  wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># yum install docker-ce -y</span></span><br><span class="line"></span><br><span class="line">安装docker-distribution</span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># yum install docker-distribution.x86_64 </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl start  docker-distribution</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># rpm -ql docker-distribution </span></span><br><span class="line">/etc/docker-distribution/registry/config.yml <span class="comment">#配置文件</span></span><br><span class="line">/usr/bin/registry</span><br><span class="line">/usr/lib/systemd/system/docker-distribution.service</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/AUTHORS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/CONTRIBUTING.md</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/LICENSE</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/MAINTAINERS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/README.md</span><br><span class="line">/var/lib/registry <span class="comment">#存储用户pull下来的所有镜像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置文件</span><br><span class="line">[root@centos7 ~]<span class="comment"># vim /etc/docker-distribution/registry/config.yml</span></span><br><span class="line">version: 0.1  <span class="comment">#版本</span></span><br><span class="line"><span class="built_in">log</span>:          <span class="comment">#日志</span></span><br><span class="line">  fields:     <span class="comment">#存储</span></span><br><span class="line">    service: registry </span><br><span class="line">storage:</span><br><span class="line">    cache:      <span class="comment">#使用本地内存做缓存</span></span><br><span class="line">        layerinfo: inmemory</span><br><span class="line">    filesystem: <span class="comment">#用户所有pull下来的文件存放在/var/lib/registry</span></span><br><span class="line">        rootdirectory: /var/lib/registry</span><br><span class="line">http:           <span class="comment">#仅提供http协议的传输</span></span><br><span class="line">    addr: :5000 <span class="comment">#默认监听本机的所有地址的5000端口</span></span><br><span class="line"></span><br><span class="line">启动docker-distribution服务</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl start docker-distribution</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ss -tnl</span></span><br><span class="line">LISTEN      0      128     :::5000                :::*  </span><br><span class="line">distribution的registry做的非常简单</span><br><span class="line"><span class="comment">#无用户名认证</span></span><br><span class="line"><span class="comment">#默认情况下不区分任何用户空间</span></span><br><span class="line"><span class="comment">#仅有顶层仓库，仅供公司内部临时使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####################发送镜像端##############################</span></span><br><span class="line"><span class="comment">###################打标签发送###############################</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#打标签时指明distribution服务器地址、端口（确认可以名字解析解析到distribution服务器地址）</span></span><br><span class="line"></span><br><span class="line">打标签</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker tag lamp:v0.1 www.centos7.com:5000/myimg:v0.1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">www.centos7.com:5000/myimg   v0.1                f3c216eb1c6f        6 hours ago         279MB</span><br><span class="line"></span><br><span class="line">上传到distribution服务器（失败原因是默认使用的https发送的请求，对端使用的是http接收双方不匹配）</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker push www.centos7.com:5000/myimg:v0.1 </span></span><br><span class="line">The push refers to repository [www.centos7.com:5000/myimg]</span><br><span class="line">Get https://www.centos7.com:5000/v2/: dial tcp 172.18.135.2:5000: connect: no route to host</span><br><span class="line"></span><br><span class="line">编辑daemon.json 开启明文不安装的仓库传输，默认使用https加密协议，使用明文http协议</span><br><span class="line">[root@centos7 ~]<span class="comment"># vim /etc/docker/daemon.json </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xr8r3tc3.mirror.aliyuncs.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>: [<span class="string">"www.centos7.com:5000"</span>]</span><br><span class="line">&#125;</span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line"></span><br><span class="line">推镜像</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker push www.centos7.com:5000/myimg:v0.1</span></span><br><span class="line">The push refers to repository [www.centos7.com:5000/myimg]</span><br><span class="line">a92cb897b523: Pushed </span><br><span class="line">071d8bd76517: Pushed </span><br><span class="line">v0.1: digest: sha256:274298eab95626cb7c4f0bbb7684d813037650bc11b527e6f31c99910ae28e68 size: 741</span><br><span class="line"></span><br><span class="line"><span class="comment">####################接收镜像的节点distribution服务器#########</span></span><br><span class="line"><span class="comment">###############################安装docker##################</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line">查看是否推送成功</span><br><span class="line">[root@centos7 ~]<span class="comment"># ls /var/lib/registry/</span></span><br><span class="line">docker</span><br><span class="line">root@centos7 ~]<span class="comment"># tree /var/lib/registry/</span></span><br><span class="line">/var/lib/registry/</span><br><span class="line">└── docker</span><br><span class="line">    └── registry</span><br><span class="line">        └── v2</span><br><span class="line">            ├── blobs</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 27</span><br><span class="line">            │       │   └── 274298eab95626cb7c4f0bbb7684d813037650bc11b527e6f31c99910ae28e68</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── a0</span><br><span class="line">            │       │   └── a02a4930cb5d36f3290eb84f4bfa30668ef2e9fe3a1fb73ec015fc58b9958b17</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       ├── ab</span><br><span class="line">            │       │   └── ab9147d4eb81842f3eccbb7c75ef8cad91a9dadfd22233050acae0d2f37d9fba</span><br><span class="line">            │       │       └── data</span><br><span class="line">            │       └── f3</span><br><span class="line">            │           └── f3c216eb1c6f3fe2e271835d79e94e9ede430d7cd75f9734cf44dd9c5fbf095c</span><br><span class="line">            │               └── data</span><br><span class="line">            └── repositories</span><br><span class="line">                └── myimg</span><br><span class="line">                    ├── _layers</span><br><span class="line">                    │   └── sha256</span><br><span class="line">                    │       ├── a02a4930cb5d36f3290eb84f4bfa30668ef2e9fe3a1fb73ec015fc58b9958b17</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       ├── ab9147d4eb81842f3eccbb7c75ef8cad91a9dadfd22233050acae0d2f37d9fba</span><br><span class="line">                    │       │   └── link</span><br><span class="line">                    │       └── f3c216eb1c6f3fe2e271835d79e94e9ede430d7cd75f9734cf44dd9c5fbf095c</span><br><span class="line">                    │           └── link</span><br><span class="line">                    ├── _manifests</span><br><span class="line">                    │   ├── revisions</span><br><span class="line">                    │   │   └── sha256</span><br><span class="line">                    │   │       └── 274298eab95626cb7c4f0bbb7684d813037650bc11b527e6f31c99910ae28e68</span><br><span class="line">                    │   │           └── link</span><br><span class="line">                    │   └── tags</span><br><span class="line">                    │       └── v0.1</span><br><span class="line">                    │           ├── current</span><br><span class="line">                    │           │   └── link</span><br><span class="line">                    │           └── index</span><br><span class="line">                    │               └── sha256</span><br><span class="line">                    │                   └── 274298eab95626cb7c4f0bbb7684d813037650bc11b527e6f31c99910ae28e68</span><br><span class="line">                    │                       └── link</span><br><span class="line">                    └── _uploads</span><br><span class="line"></span><br><span class="line">31 directories, 10 files</span><br><span class="line"></span><br><span class="line">使用此镜像（可以解析到本机域名）</span><br><span class="line"><span class="comment">#本身也不支持httpds修改daemon.json </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xr8r3tc3.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="string">"insecure-registries"</span>:[<span class="string">"www.centos7.com:5000"</span>]</span><br><span class="line">&#125;</span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker info</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker pull www.centos7.com:5000/myimg:v0.1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">www.centos7.com:5000/myimg   v0.1                f3c216eb1c6f        7 hours ago         279MB</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">将别人的镜像推送到自己的仓库中使用（本地的centos7打个标签传到自己本地的仓库）</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker tag centos:7 www.centos7.com:5000/centos:7</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">www.centos7.com:5000/myimg    v0.1                f3c216eb1c6f        7 hours ago         279MB</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker push www.centos7.com:5000/centos:7</span></span><br></pre></td></tr></table></figure><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a><code>Harbor</code></h3><p>源代码托管在github:<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></p><ul><li><p>Harbor是一个开源的可信云本机注册表项目，用于存储，签名和扫描内容。Harbor通过添加用户通常需要的功能（如安全性，身份和管理）来扩展开源Docker Distribution。使注册表更接近构建和运行环境可以提高图像传输效率。Harbor支持在注册表之间复制映像，还提供高级安全功能，如用户管理，访问控制和活动审计。</p></li><li><p>Harbour由Cloud Native Computing Foundation（CNCF）托管。如果您是一个希望帮助塑造云原生技术发展的组织，请考虑加入CNCF。有关谁参与以及Harbour如何扮演角色的详细信息，请阅读CNCF 公告。</p></li></ul><p><img src="/2019/01/03/docker私有仓库和资源限制/harbor.png" alt=""></p><ul><li><p>系统要求：</p><ul><li><p>在Linux主机上： docker 17.03.0-ce +和docker-compose 1.10.0+。</p></li><li><p>下载Harbor版本的二进制文件，然后按照安装和配置指南安装Harbour。</p></li><li><p>如果您想在Kubernetes上部署Harbour，请使用Harbor图表。</p></li><li><p>有关如何使用Harbor的更多详细信息，请参阅用户指南。</p></li></ul></li></ul><p><img src="/2019/01/03/docker私有仓库和资源限制/1.png" alt=""><br><img src="/2019/01/03/docker私有仓库和资源限制/2.png" alt=""><br><img src="/2019/01/03/docker私有仓库和资源限制/3.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Harbor服务传输使用的也是https协议传输，可以将此功能关掉,生产中若使用Harbor建议启用https加密以及从节点复制功能。</span></span><br><span class="line">港口可以通过以下三种方法之一安装：</span><br><span class="line">    1.在线安装程序：安装程序从Docker hub下载Harbor的图像。因此，安装程序的尺寸非常小。</span><br><span class="line">    2.脱机安装程序：当主机没有Internet连接时使用此安装程序。安装程序包含预先构建的图像，因此其大小更大。</span><br><span class="line"></span><br><span class="line">安装步骤归结为以下内容：</span><br><span class="line">    1.下载安装程序</span><br><span class="line">    2.配置harbor.cfg </span><br><span class="line">        配置参数位于文件harbor.cfg中。</span><br><span class="line">        在harbor.cfg中有两类参数，必需参数和可选参数</span><br><span class="line">    3.运行install.sh安装并启动Harbor</span><br><span class="line"></span><br><span class="line">第一步：</span><br><span class="line">安装docker-compose(epel源)</span><br><span class="line">    [root@centos7 ~]<span class="comment"># yum install docker-compose</span></span><br><span class="line"></span><br><span class="line">第二步：</span><br><span class="line">下载离线安装程序包，并解压</span><br><span class="line">    下载地址：https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.0.tgz</span><br><span class="line">    [root@centos7 <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">    /usr/<span class="built_in">local</span></span><br><span class="line">    [root@centos7 <span class="built_in">local</span>]<span class="comment"># tar xvf harbor-offline-installer-v1.7.0.tgz </span></span><br><span class="line"></span><br><span class="line">第三步：编辑harbor配置文件、并运行装载harbor（详细设置参考github中harbor安装手册）</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># pwd</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/harbor</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># vim harbor.cfg </span></span><br><span class="line">    8行 hostname = www.centos7.com <span class="comment">#修改主机名，确保此名称可以解析</span></span><br><span class="line">    [root@centos7 harbor]<span class="comment"># systemctl start docker   #运行 ./install.sh 前确保docker已经启动</span></span><br><span class="line">    [root@centos7 harbor]<span class="comment"># pwd</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/harbor</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># ./install.sh </span></span><br><span class="line">    [root@centos7 harbor]<span class="comment"># docker image ls  #可以查看默认的离线下载下来的镜像</span></span><br><span class="line"></span><br><span class="line">第四步：此时默认的运行的https容器已经启动，以及访问查看</span><br><span class="line">[root@centos7 harbor]<span class="comment"># ss -tnl  #监听的端口默认映射为宿主机的端口</span></span><br><span class="line">    LISTEN      0      128            :::80                         :::*     </span><br><span class="line">    LISTEN      0      128            :::443                        :::*                  </span><br><span class="line">    LISTEN      0      128            :::4443                       :::*     </span><br><span class="line"></span><br><span class="line">http://172.18.135.2/harbor/sign-in</span><br><span class="line"><span class="comment">#使用默认的账号和密码登陆</span></span><br><span class="line">账号admin</span><br><span class="line">密码Harbor12345</span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/03/docker私有仓库和资源限制/登陆.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己创建账号并定义项目名称并向自己定义的仓库中推送镜像</span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/03/docker私有仓库和资源限制/推镜像.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第五步：推送镜像到自己创建的harbor仓库中</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># vim /etc/docker/daemon.json </span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xr8r3tc3.mirror.aliyuncs.com"</span>],</span><br><span class="line">     <span class="string">"insecure-registries"</span>:[<span class="string">"www.centos7.com"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># systemctl restart docker</span></span><br><span class="line"></span><br><span class="line">    查看本地已有的镜像</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># docker image ls</span></span><br><span class="line">    REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">    goharbor/harbor-db              v1.7.0              45d94fe5fee5        3 weeks ago         133MB</span><br><span class="line"></span><br><span class="line">    打标签</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># docker tag goharbor/harbor-db:v1.7.0 www.centos7.com/public/harbor:v0.1</span></span><br><span class="line"></span><br><span class="line">    登陆、推送到harbor</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># docker login www.centos7.com</span></span><br><span class="line">    Username: daizhe</span><br><span class="line">    Password: </span><br><span class="line">    WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">    Configure a credential helper to remove this warning. See</span><br><span class="line">    https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line">    Login Succeeded</span><br><span class="line">    [root@centos7 harbor]<span class="comment"># docker push www.centos7.com/public/harbor:v0.1</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/01/03/docker私有仓库和资源限制/成功推送.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker私有仓库&quot;&gt;&lt;a href=&quot;#docker私有仓库&quot; class=&quot;headerlink&quot; title=&quot;docker私有仓库&quot;&gt;&lt;/a&gt;docker私有仓库&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/03/docker私有仓库和资源限制/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>dockerfile详解</title>
    <link href="https://9527dz.top/2019/01/02/dockerfile%E8%AF%A6%E8%A7%A3/"/>
    <id>https://9527dz.top/2019/01/02/dockerfile详解/</id>
    <published>2019-01-02T11:20:29.105Z</published>
    <updated>2019-01-05T03:56:29.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dockerfile详解"><a href="#dockerfile详解" class="headerlink" title="dockerfile详解"></a>dockerfile详解</h1><p><img src="/2019/01/02/dockerfile详解/图标.png" alt=""><br><a id="more"></a></p><h2 id="docker的镜像分层"><a href="#docker的镜像分层" class="headerlink" title="docker的镜像分层"></a>docker的镜像分层</h2><ul><li><p>分层</p><ul><li>Cow</li><li>联合挂载</li><li>base image ,app image = base image</li></ul></li><li><p>docker里的镜像绝大部分都是在别的镜像的基础上去进行创建的，也就是使用镜像的分层结构。</p></li><li>那么为什么会有两个镜像呢？这是由于docker的镜像分层结构所导致的，如下图所示。</li></ul><p><img src="/2019/01/02/dockerfile详解/分层.png" alt=""></p><ul><li><p>一个docker镜像由多个可读的镜像层组成，然后运行的容器会在这个docker的镜像上面多加一层可写的容器层，任何的对文件的更改都只存在此容器层。因此任何对容器的操作均不会影响到镜像。</p></li><li><p>至于容器如何获取镜像层文件而又不影响到是镜像层的呢？docker是这样实现的？</p></li><li>如果需要获取某个文件，那么容器曾会从上到下去下一层的镜像层去获取文件，如果该层文件不存在，那么就会去下一镜像层去寻找，直到最后一层。</li><li>对于用户而言，用户面向的是一个叠加后的文件系统。</li><li>而任何对于文件的操作都会记录在容器层，例如说修改文件，容器层会把在镜像层找到的文件拷贝到容器层然后进行修改，删除文件则会在容器层内记录删除文件的记录。</li></ul><p><img src="/2019/01/02/dockerfile详解/镜像分层.png" alt=""></p><h2 id="About-Dockerfile"><a href="#About-Dockerfile" class="headerlink" title="About Dockerfile"></a>About Dockerfile</h2><ul><li>Dockerfile只不过是建造码头工人的源代码自动图像码头工人可以构建图像读取指令从Dockerfile。<ul><li>Dockerfile是一个文本文件,包含所有的命令在命令行用户可以叫组装一个图像型码头工人建立用户可以创建一个自动构建执行一些命令行指令</li></ul></li></ul><p><img src="/2019/01/02/dockerfile详解/关于dockerfile.png" alt=""></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>Dockerfile其实可以看做一个命令集。每行均为一条命令。每行的第一个单词，就是命令command。</li><li>后面的字符串是该命令所要接收的参数。</li><li>比如ENTRYPOINT /bin/bash。ENTRYPOINT命令的作用就是将后面的参数设置为镜像的entrypoint。</li><li>至于现有命令的含义，这里不再详述。</li><li>DockOne上有很多的介绍。</li></ul><p>一、Docker Image building</p><ul><li><p>宿主机指定工作目录：</p><ul><li>1.此文件中仅用于放置Dockerfile以及Dockerfile文件中指定要被依赖到的文件，不要放置其他文件或目录。</li><li>2.此宿主机的工作目录相当于隐式运行的容器的卷，仅能从此卷中复制文件到容器中。</li></ul></li><li><p>Dockerfile的文件名也只能叫做Dockerfile，放置在宿主机上的工作目录中。</p></li></ul><p>二、Dockerfile文件格式</p><ul><li>格式（Format）<ul><li>#注释</li><li>指令参数</li></ul></li><li>该指令本身不区分字符大小<ul><li>惯例要求的指令要写成纯大写</li><li>以便更容易地与参数区分开来</li></ul></li><li>dockerfile文件本身没有循环、选择等分支，也没有跳转语句<ul><li>一般来讲在dockerfile文件中的第一条指令是“FROM”（新版的dockerfile有松动，早期的dockerfile把第一条执行的第一条指令必须是“FROM”），因为“FROM”就是我们用来指定基础镜像的。</li></ul></li></ul><p>三、Dockerfile的镜像层构建</p><ul><li>在dockerfile中构建镜像，与我们手动的显式的启动一个容器构建镜像不同的是dockerfile文件中的每一条指令都会生成一个新的单有的镜像层。<ul><li>分层过多会导致在读写访问过程中的效率降低，因为首次访问镜像一定是Cow机制完成</li><li>镜像分的过于精细的好处是可以其他让镜像让享同一层底层的镜像即镜像层越精细越多越容易共享，越容易共享代表在镜像仓库与客户端和dockerhost之间传输时可以单独传输，传输的过程越易控，起码在打包、分发。</li><li>应该把关系比较紧密的操作放置在一层操作当中。</li></ul></li></ul><h3 id="docker镜像制作的两种运行场景"><a href="#docker镜像制作的两种运行场景" class="headerlink" title="docker镜像制作的两种运行场景"></a><code>docker镜像制作的两种运行场景</code></h3><ul><li>制作新镜像的过程</li><li>运行新镜像的阶段</li></ul><p><img src="/2019/01/02/dockerfile详解/docker镜像制作的两种运行场景.png" alt=""></p><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>环境变量(用ENV语句声明)也可以在某些指令中使用，因为Dockerfile将解释的变量在Dockerfile中以$variable名或${variable_name标记<ul><li>${variable_name} 语法还支持一些标准的bash修饰符<ul><li><code>$ivariable:-word} 表示如果设置了变量，则结果将是该值。如果变量没有设置，那么结果将是word</code>  </li><li>${variable:+word} 表示如果设置了变量，则word为结果，否则结果为空字符串</li></ul></li></ul></li></ul><h3 id="dockerignore-file"><a href="#dockerignore-file" class="headerlink" title=".dockerignore file"></a>.dockerignore file</h3><p>在docker CLI将上下文发送给docker守护进程之前，它将查找一个名为。如果该文件存在，CLI将修改该上下文以排除与其模式匹配的文件和目录。dockerignore file是一个以新行分隔的模式列表，类似于Unix shell的文件全局</p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a><code>Dockerfile指令</code></h2><h3 id="build阶段Dockerfile文件中的指令"><a href="#build阶段Dockerfile文件中的指令" class="headerlink" title="build阶段Dockerfile文件中的指令"></a><code>build阶段Dockerfile文件中的指令</code></h3><p>(build阶段：做很多设定以便于在目标镜像文件中可以打包进入所期望的文件或者程序文件)</p><ul><li><p><code>FROM</code> </p><ul><li>FROM指令是最重的一个且必须为Dockerfile文件开篇的第一个非注释行，用于 为映像文件构建过程指定基准镜像，后续的指令运行于此基准镜像所提供的运 行环境 </li><li>实践中，基准镜像可以是任何可用镜像文件，默认情况下，docker build会在 docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry 上拉取所需的镜像文件 <ul><li>如果找不到指定的镜像文件，docker build会返回一个错误信息 </li></ul></li><li>Syntax(语法)(repository仓库、tag标签、digest唯一标识id即镜像校验码)<ul><li><code>FROM &lt;repository&gt;[:&lt;tag&gt;] 或</code> </li><li><code>FROM &lt;resository&gt;@&lt;digest&gt;</code> <ul><li><code>&lt;reposotiry&gt;：指定作为base image的名称；</code> </li><li><code>&lt;tag&gt;：base image的标签，为可选项，省略时默认为latest；</code></li></ul></li></ul></li></ul></li><li><p><code>LABEL</code></p><ul><li>用于让Dockerfile制作者提供本人的详细信息(支持提供此镜像的任何制作的附加介绍信息以及附加的元数据)</li><li><code>Syntax: LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li></ul></li><li><p><code>COPY</code> </p><ul><li>用于从Docker主机复制文件至创建的新映像文件 </li><li>Syntax(语法) <ul><li><code>COPY &lt;src&gt; ... &lt;dest&gt; 或</code> </li><li><code>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> <ul><li><code>&lt;src&gt;：要复制的源文件或目录，支持使用通配符</code> </li><li><code>&lt;dest&gt;：目标路径，即正在创建的image的文件系统路径；建议为&lt;dest&gt;使用绝对路径，否则， COPY指定则以WORKDIR为其起始路径；</code> </li></ul></li><li>注意：在路径中有空白字符时，通常使用第二种格式 </li></ul></li><li>文件复制准则 <ul><li><code>&lt;src&gt;必须是build上下文中的路径，不能是其父目录中的文件</code> </li><li><code>如果&lt;src&gt;是目录，则其内部文件或子目录会被递归复制，但&lt;src&gt;目录自身不会被复制</code> </li><li><code>如果指定了多个&lt;src&gt;，或在&lt;src&gt;中使用了通配符，则&lt;dest&gt;必须是一个目录，且必须以/ 结尾</code> </li><li><code>如果&lt;dest&gt;事先不存在，它将会被自动创建，这包括其父目录路径</code></li></ul></li></ul></li><li><p><code>ADD</code> </p><ul><li>ADD指令类似于COPY指令，ADD支持使用TAR文件和URL路径 </li><li>Syntax <ul><li><code>ADD &lt;src&gt; ... &lt;dest&gt; 或</code> </li><li><code>ADD [&quot;&lt;src&gt;&quot;,...  &quot;&lt;dest&gt;&quot;]</code> </li></ul></li><li>操作准则 <ul><li>同COPY指令 </li><li><code>如果&lt;src&gt;为URL且&lt;dest&gt;不以/结尾，则&lt;src&gt;指定的文件将被下载并直接被创建为&lt;dest&gt; ；如果&lt;dest&gt;以/结尾，则文件名URL指定的文件将被直接下载并保存为&lt;dest&gt;/&lt;filename&gt;</code> </li><li><code>如果&lt;src&gt;是一个本地系统上的压缩格式的tar文件，它将被展开为一个目录，其行为类似于 “tar -x”命令；然而，通过URL获取到的tar文件将不会自动展开</code>； </li><li><code>如果&lt;src&gt;有多个，或其间接或直接使用了通配符，则&lt;dest&gt;必须是一个以/结尾的目录路径 ；如果&lt;dest&gt;不以/结尾，则其被视作一个普通文件，&lt;src&gt;的内容将被直接写入到&lt;dest&gt;；</code></li></ul></li></ul></li></ul><ul><li><p><code>WORKDIR</code> </p><ul><li>用于为Dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY和ADD指定 设定工作目录 </li><li>Syntax <ul><li><code>WORKDIR &lt;dirpath&gt;</code> </li><li>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，不过，其是相对此前 一个WORKDIR指令指定的路径 </li><li>另外，WORKDIR也可调用由ENV指定定义的变量 </li></ul></li><li>例如 <ul><li>WORKDIR /var/log </li><li>WORKDIR $STATEPATH</li></ul></li></ul></li><li><p><code>VOLUME 存储卷</code></p><ul><li>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其它容器上的 卷 </li><li>Syntax <ul><li><code>VOLUME &lt;mountpoint&gt; 或</code> </li><li><code>VOLUME [&quot;&lt;mountpoint&gt;&quot;]</code></li></ul></li><li>如果挂载点目录路径下此前在文件存在，docker run命令会在卷挂载完成后将此 前的所有文件复制到新挂载的卷中</li></ul></li><li><p><code>EXPOSE</code> </p><ul><li><code>用于为容器打开指定要监听的端口以实现与外部通信</code></li><li>Syntax <ul><li><code>EXPOSE &lt;port&gt;[/&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;] ...]</code><ul><li><code>&lt;protocol&gt;用于指定传输层协议，可为tcp或udp二者之一，默认为TCP协议,空格分隔可以创建多个</code> </li></ul></li></ul></li><li>EXPOSE指令可一次指定多个端口，<ul><li>例如 </li><li>EXPOSE 11211/udp 11211/tcp</li></ul></li></ul></li><li><p><code>ENV</code> </p><ul><li>用于为镜像定义所需的环境变量，并可被Dockerfile文件中位于其后的其它指令 （如ENV、ADD、COPY等）所调用 <ul><li>调用格式为$variable_name或${variable_name} </li><li>Syntax <ul><li><code>ENV &lt;key&gt; &lt;value&gt; 或</code> </li><li><code>ENV &lt;key&gt;=&lt;value&gt; ...</code> </li><li><code>第一种格式中，&lt;key&gt;之后的所有内容均会被视作其&lt;value&gt;的组成部分，因此，一次只 能设置一个变量；</code> </li><li><code>第二种格式可用一次设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果 &lt;value&gt;中包含空格，可以以反斜线(\)进行转义，也可通过对&lt;value&gt;加引号进行标识；另 外，反斜线也可用于续行；</code> </li><li><code>定义多个变量时，建议使用第二种方式，以便在同一层中完成所有功能</code></li></ul></li></ul></li></ul></li><li><p><code>ARG</code></p><ul><li>ARG指令定义了一个变量，用户可以在构建时将该变量传递给然后使用 `–bulis-arg<varname>=<value> flag</value></varname></li><li><p>如果用户指定了一个没有在dockerfile中定义的构建参数,构建输出一个警告.`</p></li><li><p>syntax</p><ul><li><code>ARG&lt;name&gt;[&lt;default value&gt;]</code></li></ul></li></ul></li></ul><p><code>1.使用FROM、LABEL、COPY制作镜像</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment">##########################创建docker的工作目录#################</span></span><br><span class="line"><span class="comment">##############################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir /docker/</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /docker/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################################</span></span><br><span class="line"><span class="comment">#########################编写dockerfile#######################</span></span><br><span class="line"><span class="comment">##############################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile</span></span><br><span class="line"></span><br><span class="line">FROM     busybox:latest             <span class="comment">#对宿主机上已有的哪个镜像进行创建</span></span><br><span class="line"></span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span>  <span class="comment">#作者描述</span></span><br><span class="line"></span><br><span class="line">COPY    index.html /data/web/html/       <span class="comment">#将宿主机上docker目录下的index.html文件复制到容器中的/data/web/html/目录。如果写为/data/web/html则代表将 index.html改名为html，在容器中的/data/web/html/获取并未存在，可以自动创建。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line"><span class="comment">##################查看宿主机上的dockerfile的工作目录#############</span></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /docker/</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># echo "123456" &gt; index.html</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># ls</span></span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#########################构建新的镜像############################</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">dicker image build = docker build</span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build -h</span></span><br><span class="line">Usage:docker image build [OPTIONS] PATH | URL | -</span><br><span class="line">Options:</span><br><span class="line">      --add-host list           添加自定义主机到ip映射(主机:ip)</span><br><span class="line">      --build-arg list          设置构建时变量</span><br><span class="line">      --cache-from strings      将图像视为缓存源</span><br><span class="line">      --rm                      成功构建后删除中间容器(默认为<span class="literal">true</span>)</span><br><span class="line">  -t, --tag list                制定的新的镜像设置新的仓库名和标签<span class="string">'name:tag'</span> </span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.1        #执行命令的目录，要求写dockerfile文件所在的目录中</span></span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/3 : FROM busybox:latest</span><br><span class="line"> ---&gt; 3a093384ac30</span><br><span class="line">Step 2/3 : LABEL maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 746880c7205c</span><br><span class="line">Removing intermediate container 746880c7205c</span><br><span class="line"> ---&gt; 7ccdca9907ce</span><br><span class="line">Step 3/3 : COPYindex.html /data/web/html/</span><br><span class="line"> ---&gt; 7062cd4f08e0</span><br><span class="line">Successfully built 7062cd4f08e0</span><br><span class="line">Successfully tagged mybox:v0.1</span><br><span class="line">    </span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mybox                    v0.1                7062cd4f08e0 </span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">############基于创建的镜像启动容器查看COPY的文件是否存在############</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm mybox:v0.1 /bin/sh</span></span><br><span class="line">/ <span class="comment"># cat /data/web/html/index.html </span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure></p><p><code>2.COPY本身也是可以是可以支持通配符</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##############################################################</span></span><br><span class="line"><span class="comment">####################使用.dockerignore限制copy的文件#############</span></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># pwd</span></span><br><span class="line">/docker</span><br><span class="line">[root@centos7 docker]<span class="comment"># mkdir /docker/data/</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># cd !$</span></span><br><span class="line"><span class="built_in">cd</span> /docker/data/</span><br><span class="line">[root@centos7 data]<span class="comment"># echo "123" &gt; test1.html</span></span><br><span class="line">[root@centos7 data]<span class="comment"># echo "123" &gt; test2.html</span></span><br><span class="line">[root@centos7 data]<span class="comment"># echo "123" &gt; test3.html</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── test1.html</span><br><span class="line">│   ├── test2.html</span><br><span class="line">│   └── test3.html</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">##打算将/docker/data/目录下的文件全部复制到容器中排除test3.html文件##</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim .dockerignore    #定义的.dockerignore 文件要写Dockerfile的相对路径，文件内也支持通配符</span></span><br><span class="line">data/test3.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">######################编辑Dockerfile文件##########################</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim /docker/Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">COPY    data /data/web/html/                <span class="comment">#如果源是目录会cp源目录下的文件不会cp目录本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">##########################创建新的镜像###########################</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.4</span></span><br><span class="line">Sending build context to Docker daemon  5.632kB</span><br><span class="line">Step 1/3 : FROM busybox:latest</span><br><span class="line"> ---&gt; 3a093384ac30</span><br><span class="line">Step 2/3 : LABEL maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ccdca9907ce</span><br><span class="line">Step 3/3 : COPYdata /data/web/html/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5b5cd427fb81</span><br><span class="line">Successfully built 5b5cd427fb81</span><br><span class="line">Successfully tagged mybox:v0.4</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line"><span class="comment">##############################创建容器查看######################</span></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm mybox:v0.4 /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /data/web/html/*</span></span><br><span class="line">/data/web/html/test1.html  /data/web/html/test2.html</span><br></pre></td></tr></table></figure></p><p><code>3.Dockerflie文件中ADD指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 docker]<span class="comment"># pwd</span></span><br><span class="line">/docker</span><br><span class="line">[root@centos7 docker]<span class="comment"># ls</span></span><br><span class="line">Dockerfile  wordpress-4.9-zh_CN.tar.gz</span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz /data/ <span class="comment">#将网上的url打入镜像中，并运行容器是自动下载此压缩包放置在容器中的/data目录中</span></span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz /data2/  <span class="comment">#此压缩包是放置在docker的工作目录中，会在容器运行时解压到容器中/data2目录中。</span></span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.3</span></span><br><span class="line">Sending build context to Docker daemon  10.13MB</span><br><span class="line">Step 1/4 : FROM busybox:latest</span><br><span class="line"> ---&gt; 3a093384ac30</span><br><span class="line">Step 2/4 : LABEL maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ccdca9907ce</span><br><span class="line">Step 3/4 : ADD http://nginx.org/download/nginx-1.14.2.tar.gz /data/</span><br><span class="line">Downloading  1.015MB/1.015MB</span><br><span class="line"> ---&gt; 62b1d80179e4</span><br><span class="line">Step 4/4 : ADD wordpress-4.9-zh_CN.tar.gz /data2/</span><br><span class="line"> ---&gt; 6bfaa9b46d21</span><br><span class="line">Successfully built 6bfaa9b46d21</span><br><span class="line">Successfully tagged mybox:v0.3</span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm mybox:v0.3 /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls /data</span></span><br><span class="line">data/   data2/</span><br><span class="line">/ <span class="comment"># ls /data</span></span><br><span class="line">nginx-1.14.2.tar.gz</span><br><span class="line">/ <span class="comment"># ls /data2</span></span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure></p><p><code>4.Dockerfile文件中WORKDIR指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">###########################定义工作目录##########################</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">WORKDIR /         <span class="comment">#定义工作目录，表示/data/</span></span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz data/</span><br><span class="line">WORKDIR /data/    <span class="comment">#定义工作目录，表示/data/haha/</span></span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz haha/</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">###########################制作镜像并运行查看######################</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.4</span></span><br><span class="line">Sending build context to Docker daemon  10.13MB</span><br><span class="line">Step 1/6 : FROM busybox:latest</span><br><span class="line"> ---&gt; 3a093384ac30</span><br><span class="line">Step 2/6 : LABEL maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ccdca9907ce</span><br><span class="line">Step 3/6 : WORKDIR /</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> a9ef74256526</span><br><span class="line">Removing intermediate container a9ef74256526</span><br><span class="line"> ---&gt; 89e2798cf96c</span><br><span class="line">Step 4/6 : ADD http://nginx.org/download/nginx-1.14.2.tar.gz data/</span><br><span class="line">Downloading  1.015MB/1.015MB</span><br><span class="line"> ---&gt; 653df7aeb99b</span><br><span class="line">Step 5/6 : WORKDIR /data/</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 55e4223e543c</span><br><span class="line">Removing intermediate container 55e4223e543c</span><br><span class="line"> ---&gt; 471c356643dc</span><br><span class="line">Step 6/6 : ADD wordpress-4.9-zh_CN.tar.gz haha/</span><br><span class="line"> ---&gt; c1d30647ca27</span><br><span class="line">Successfully built c1d30647ca27</span><br><span class="line">Successfully tagged mybox:v0.4</span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm  mybox:v0.4 /bin/sh</span></span><br><span class="line">/data <span class="comment"># ls /data/</span></span><br><span class="line">haha                 nginx-1.14.2.tar.gz</span><br><span class="line">/data <span class="comment"># ls /data/haha/</span></span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure></p><p><code>5.Dockerfile文件中VOLUME指定存储卷指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">docker管理的卷（要是想要指定绑定在宿主机的某个目录进行映射关联关系的存储卷继续使用-v选项指定）</span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"><span class="comment">##############################docker管理的卷#############################</span></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">WORKDIR /</span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz data/</span><br><span class="line">WORKDIR /data/</span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz haha/</span><br><span class="line">VOLUME /data/web/html          <span class="comment">#指定容器中的此目录与宿主机上的某一个目录做存储卷映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"><span class="comment">###############################打镜像--运行容器########################</span></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.5</span></span><br><span class="line">Sending build context to Docker daemon  10.15MB</span><br><span class="line">Step 1/7 : FROM busybox:latest</span><br><span class="line"> ---&gt; 3a093384ac30</span><br><span class="line">Step 2/7 : LABEL maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ccdca9907ce</span><br><span class="line">Step 3/7 : WORKDIR /</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 89e2798cf96c</span><br><span class="line">Step 4/7 : ADD http://nginx.org/download/nginx-1.14.2.tar.gz data/</span><br><span class="line">Downloading  1.015MB/1.015MB</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 653df7aeb99b</span><br><span class="line">Step 5/7 : WORKDIR /data/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 471c356643dc</span><br><span class="line">Step 6/7 : ADD wordpress-4.9-zh_CN.tar.gz haha/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; c1d30647ca27</span><br><span class="line">Step 7/7 : VOLUME /data/web/html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 388c0312f897</span><br><span class="line">Removing intermediate container 388c0312f897</span><br><span class="line"> ---&gt; 54cf9694d119</span><br><span class="line">Successfully built 54cf9694d119</span><br><span class="line">Successfully tagged mybox:v0.5</span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm  mybox:v0.5 /bin/sh</span></span><br><span class="line">/data <span class="comment"># ls /data/web/html/</span></span><br><span class="line">/data <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment">##########################宿主机上查看对应的随机的存储卷##################</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image inspect mybox:v0.5</span></span><br><span class="line">            <span class="string">"Volumes"</span>: &#123;</span><br><span class="line">                <span class="string">"/data/web/html/"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect pc1</span></span><br><span class="line">        <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"177fd037174ad4af75866df8d07c575f1e4dbee2ee65613c6e36842b4e6de49e"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/177fd037174ad4af75866df8d07c575f1e4dbee2ee65613c6e36842b4e6de49e/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/data/web/html"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p><code>6.Dockerfile中EXPOSE指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment">#########################编写Dockerfile端口暴露tcp80####################</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">WORKDIR /</span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz data/</span><br><span class="line">WORKDIR /data/</span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz haha/</span><br><span class="line">VOLUME /data/web/html</span><br><span class="line">EXPOSE 80/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment">#########################创建镜像并运行查看端口是否暴露###################</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.6</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it --rm  mybox:v0.6 /bin/sh</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect pc1</span></span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"b8bb78bbe2fb"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"ExposedPorts"</span>: &#123;</span><br><span class="line">                <span class="string">"80/tcp"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">[root@centos7 _data]<span class="comment"># docker container port pc1</span></span><br><span class="line"><span class="comment">#默认没有端口暴露，虽然在Dockerfile文件中已经定义，由于网络风险需要在启动容器是指定端口暴露</span></span><br><span class="line">这种暴露和存储卷相同，都是宿主机随机动态</span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment">#####################此时可以手动指定开始端口暴漏##########################</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc1 -it -P --rm  mybox:v0.6 /bin/sh</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container port pc1</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure></p><p><code>7.Dockerfile文件中ENV指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">ENV     webhome=<span class="string">"/data/web/html/"</span></span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">WORKDIR <span class="variable">$&#123;webhome&#125;</span></span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz <span class="variable">$&#123;webhome&#125;</span></span><br><span class="line">WORKDIR <span class="variable">$&#123;webhome&#125;</span>      </span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz ./       </span><br><span class="line">VOLUME <span class="variable">$&#123;webhome&#125;</span></span><br><span class="line">EXPOSE 80/tcp</span><br><span class="line"></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.7</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc2 -it --rm mybox:v0.7 /bin/sh</span></span><br></pre></td></tr></table></figure></p><p><code>8.Dockerfile文件中ARG指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">build的时对变量传值的做法</span><br><span class="line"><span class="comment">#Dockerfile中定义了创建容器时的变量参数。如果想临时修改参数可以在命令行中使用ARG定义变量，--build-arg,在执行docker image buil 命令命令行选项可以改变变量的值（docker新版本中支持）</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">##############################使用ARG定义变量##############################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /docker/</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM     busybox:latest</span><br><span class="line">ARG     webhome=<span class="string">"/data/web/html/"</span></span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">WORKDIR <span class="variable">$&#123;webhome&#125;</span>         </span><br><span class="line">ADD http://nginx.org/download/nginx-1.14.2.tar.gz <span class="variable">$&#123;webhome&#125;</span>                 </span><br><span class="line">WORKDIR <span class="variable">$&#123;webhome&#125;</span></span><br><span class="line">ADD wordpress-4.9-zh_CN.tar.gz ./     </span><br><span class="line">VOLUME <span class="variable">$&#123;webhome&#125;</span></span><br><span class="line">EXPOSE 80/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment">#############打镜像，并使用--build-arg指定新的便令再次打镜像################</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build /docker/ -t mybox:v0.8</span></span><br><span class="line"><span class="comment">#这个镜像执行与EVN执行的镜像一样</span></span><br><span class="line"><span class="comment">#使用--build-arg指定新的变量的值</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker image build --build-arg webhome="/var/www/html" /docker/ -t mybox:v0.7</span></span><br><span class="line">[root@centos7 docker]<span class="comment"># docker run --name pc2 -it --rm mybox:v0.7 /bin/sh</span></span><br><span class="line">/var/www/html <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h3 id="run阶段Dockerfile文件中的指令"><a href="#run阶段Dockerfile文件中的指令" class="headerlink" title="run阶段Dockerfile文件中的指令"></a><code>run阶段Dockerfile文件中的指令</code></h3><p><img src="/2019/01/02/dockerfile详解/2019-01-02_143308.png" alt=""></p><p>(run阶段：指明在bulid时做一些通过运行shell命令来达到去设定目标镜像的目的）</p><ul><li><p><code>RUN</code> </p><ul><li>用于指定docker build过程中运行的程序，其可以是任何命令（run的任何命令代表基础镜像支持的命令） </li><li>Syntax <ul><li><code>RUN &lt;command&gt; 或</code> #以shell解释运行</li><li><code>RUN  [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]</code> #不以shell解释运行</li></ul></li><li><code>第一种格式中，&lt;command&gt;通常是一个shell命令，且以“/bin/sh -c”来运行它，这意味着此进程 在容器中的PID不为1，不能接收Unix信号，因此，当使用docker stop &lt;container&gt;命令停止容器 时，此进程接收不到SIGTERM信号；</code> </li><li><code>第二种语法格式中的参数是一个JSON格式的数组，其中&lt;executable&gt;为要运行的命令，后面的 &lt;paramN&gt;为传递给命令的选项或参数；然而，此种格式指定的命令不会以“/bin/sh -c”来发起 ，因此常见的shell操作如变量替换以及通配符(?,*等)替换将不会进行；不过，如果要运行的命令 依赖于此shell特性的话，可以将其替换为类似下面的格式。</code> <ul><li><code>RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;]</code><ul><li>注意：json数组中，要使用双引号</li></ul></li></ul></li></ul></li><li><p><code>CMD</code></p><ul><li>类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，不过，二者 的运行时间点不同 <ul><li>RUN指令运行于映像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新映像 文件启动一个容器时 </li><li>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也 将终止；不过，CMD指定的命令其可以被docker run的命令行选项所覆盖 </li><li>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效 </li></ul></li><li>Syntax <ul><li><code>CMD &lt;command&gt; 或</code>   #以shell运行</li><li><code>CMD [“&lt;executable&gt;”, “&lt;param1&gt;”, “&lt;param2&gt;”] 或</code>    #不以shell解释运行</li><li><code>CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]</code></li></ul></li><li>前两种语法格式的意义同RUN </li><li>第三种则用于为ENTRYPOINT指令提供默认参数</li></ul></li><li><p><code>ENTRYPOINT</code> </p><ul><li>类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个 单独的可执行程序 </li><li>与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的 参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定 指定的程序 <ul><li>不过，docker run命令的–entrypoint选项的参数可覆盖ENTRYPOINT指令指定的程序 </li></ul></li><li>Syntax <ul><li><code>ENTRYPOINT &lt;command&gt;</code> </li><li><code>ENTRYPOINT [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]</code></li></ul></li><li>docker run命令传入的命令参数会覆盖CMD指令的内容并且附加到 ENTRYPOINT命令最后做为其参数使用 </li><li>Dockerfile文件中也可以存在多个ENTRYPOINT指令，但仅有最后一个会生效</li></ul></li></ul><p><code>Dockerfile文件中RUN指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行起来的命令还是shell</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># pwd</span></span><br><span class="line">/dockerlamp</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># cat Dockerfile </span></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN  yum makecache &amp;&amp; \</span><br><span class="line">yum -y install httpd php php-mysql &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; \</span><br><span class="line">rm -rf /var/cache/yum/* <span class="comment">#删除yum生成的缓存不免刻录至镜像中</span></span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 --rm -it lamp:v0.1 /bin/sh</span></span><br><span class="line">sh-4.2<span class="comment"># rpm -q httpd php</span></span><br><span class="line">httpd-2.4.6-88.el7.centos.x86_64</span><br><span class="line">php-5.4.16-46.el7.x86_64</span><br></pre></td></tr></table></figure></p><p><code>Dockerfile文件中CMD指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RUN在bulid阶段</span></span><br><span class="line"><span class="comment">#CMD在run阶段</span></span><br><span class="line"><span class="comment">#实现容器运行起来不是shell而是httpd，实现httpd运行在前台</span></span><br><span class="line"><span class="comment">###################################################################</span></span><br><span class="line">如何实现将httpd实现前台运行</span><br><span class="line">cat /usr/lib/systemd/system/httpd.service </span><br><span class="line">ExecStart=/usr/sbin/httpd <span class="variable">$OPTIONS</span> -DFOREGROUND</span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /dockerlamp/</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># cat Dockerfile </span></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN  yum makecache &amp;&amp; \</span><br><span class="line">yum -y install httpd php php-mysql &amp;&amp; \</span><br><span class="line">yum clean all &amp;&amp; \</span><br><span class="line">rm -rf /var/cache/yum/*</span><br><span class="line">CMD [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]</span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker image build /dockerlamp/ -t lamp:v0.2</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc2 -it --rm lamp:v0.2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#烟验证</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES</span><br><span class="line">f6b5dd3c9664        lamp:v0.2           <span class="string">"usr/sbin/httpd -DFO…"</span>   About a minute ago   Up About a minute                       pc2</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker exec -it pc2  /bin/bash</span></span><br><span class="line">[root@f6b5dd3c9664 /]<span class="comment"># netstat -tnl</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################################</span></span><br><span class="line"><span class="comment">####################################改进###################################</span></span><br><span class="line"><span class="comment">##################制作Dockerfile文件并添加测试页打包至镜像###################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># pwd</span></span><br><span class="line">/dockerlamp</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># vim php.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN      yum makecache &amp;&amp; \</span><br><span class="line">        yum -y install httpd php php-mysql &amp;&amp; \</span><br><span class="line">        yum clean all &amp;&amp; \</span><br><span class="line">        rm -rf /var/cache/yum/*</span><br><span class="line">ADD php.php <span class="variable">$&#123;root&#125;</span></span><br><span class="line">CMD [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###############################打镜像并运行容器测试########################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker image build /dockerlamp/ -t lamp:v0.3</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc3 -it --rm lamp:v0.3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker exec -it pc3 /bin/bash</span></span><br><span class="line">[root@b1da3c0ce6d8 /]<span class="comment"># curl 172.17.0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###############################说明#######################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">此时也可以用户在命令行中运行指定使用/bin/bash运行的</span><br><span class="line"><span class="comment">##可以手动指定命令来覆盖镜像Dockerfile文件中CMD的</span></span><br><span class="line"><span class="comment">##上一个镜像文件中默认已经定义运行容器默认运行的进程为httpd的，可以手动运行/bin/bash</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc3 -it --rm lamp:v0.3 /bin/bash</span></span><br><span class="line">[root@97ef0a13d4fc /]<span class="comment"># </span></span><br><span class="line">[root@97ef0a13d4fc /]<span class="comment"># ps aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.1  0.1  11820  1884 pts/0    Ss   07:48   0:00 /bin/bash</span><br><span class="line">root         16  0.0  0.0  51740  1732 pts/0    R+   07:49   0:00 ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment">#Dokcerfile文件中定义的运行httpd已经被覆盖，查看进程httpd进程未被启动，如果想要CMD不被覆盖则此时应该用到ENTRYPOINT</span></span><br></pre></td></tr></table></figure></p><p><code>Dockerfile文件中ENTRYPOINT指令( --entrypoint )</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ENTRYPOINT单独使用情况下作用于CMD大致相同除了不可被用户命令行运行容器时任意被覆盖</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###########################常见Dockerfile文件##############################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># pwd</span></span><br><span class="line">/dockerlamp</span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># vim Dockerfile </span></span><br><span class="line"></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN      yum makecache &amp;&amp; \</span><br><span class="line">        yum -y install httpd php php-mysql &amp;&amp; \</span><br><span class="line">        yum clean all &amp;&amp; \</span><br><span class="line">        rm -rf /var/cache/yum/*</span><br><span class="line">ADD php.php <span class="variable">$&#123;root&#125;</span></span><br><span class="line">EXPOSE 80/tcp</span><br><span class="line">VOLUME <span class="variable">$&#123;root&#125;</span></span><br><span class="line">ENTRYPOINT [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]</span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># ls</span></span><br><span class="line">Dockerfile  php.php</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###########################打镜像运行容器##################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker image build /dockerlamp/ -t lamp:v0.4</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -it -P --rm lamp:v0.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###########################宿主机检测######################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker container  ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0031f963fce6        lamp:v0.4           <span class="string">"usr/sbin/httpd -DFO…"</span>   41 seconds ago      Up 41 seconds       80/tcp              pc1</span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker container port pc1</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:32769</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># curl 172.18.135.1:32769</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">############测试试图覆盖Docker文件中定义的执行的ENTRYPOINT指令###############</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -P -it --rm lamp:v0.4 /bin/bash</span></span><br><span class="line">Usage: usr/sbin/httpd [-D name] [-d directory] [-f file]</span><br><span class="line"></span><br><span class="line"><span class="comment">#报错拒绝覆盖Docker文件中定义的执行的ENTRYPOINT指令</span></span><br><span class="line"><span class="comment">#命令行运行时添加的/bin/bash则当作了Docker文件中定义的执行的ENTRYPOINT指令后面的参数（httpd不支持/bin/bash当作参数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">########用户执行命令时如何指明强制覆盖Docker文件中定义的执行的ENTRYPOINT指令##</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -P -it --rm --entrypoint "/bin/bash" lamp:v0.4</span></span><br><span class="line">[root@5de1663077eb /]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><code>Dockerfile文件中ENTRYPOINT指令于CMD指令同时使用</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMD定义的命令都要统统作为ENTRYPOINT的参数</span></span><br><span class="line"><span class="comment">#一下两种格式意义相同</span></span><br><span class="line">CMD [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]   <span class="comment">#CMD作为ENTRYPOINT的参数执行</span></span><br><span class="line">ENTRYPOINT [<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>]</span><br><span class="line">=========================================================================</span><br><span class="line">CMD /usr/bin/httpd -DFOREGROUD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">ENTRYPOINT与CMD分隔开来写的意义：</span><br><span class="line">    在ENTRYPOINT运行一个脚本，CMD的指令会被当作脚本的参数传递给脚本，脚本作为传统应用程序和容器化运行的中间层，来处理配置文件的，同时此配置文件是可以接受环境变量为参数来设置配置文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###############Dockerfile文件中ENTRYPOINT指令于CMD指令同时使用############</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># vim Dockerfile </span></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN      yum makecache &amp;&amp; \</span><br><span class="line">        yum -y install httpd php php-mysql &amp;&amp; \</span><br><span class="line">        yum clean all &amp;&amp; \</span><br><span class="line">        rm -rf /var/cache/yum/*</span><br><span class="line">ADD php.php <span class="variable">$&#123;root&#125;</span></span><br><span class="line">ADD ent.sh /bin/</span><br><span class="line">EXPOSE 8080/tcp</span><br><span class="line">VOLUME <span class="variable">$&#123;root&#125;</span></span><br><span class="line">CMD [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">"/bin/ent.sh"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编写的脚本的解释器一定是基础镜像中所被支持解释的类型</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># vim ent.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#如果用户没定义此为默认的变量</span></span><br><span class="line">listen_port=<span class="variable">$&#123;LISTEN_PORT:-8080&#125;</span></span><br><span class="line">server_name=<span class="variable">$&#123;SERVER_NAME:-localhost&#125;</span></span><br><span class="line">doc_root=<span class="variable">$&#123;DOC_ROOT:-/var/www/html&#125;</span></span><br><span class="line"></span><br><span class="line">cat &gt; /etc/httpd/conf.d/myweb.conf &lt;&lt;EOF</span><br><span class="line">listen <span class="variable">$listen_port</span></span><br><span class="line">&lt;VirtualHost *:<span class="variable">$&#123;listen_port&#125;</span>&gt;</span><br><span class="line">        ServerName <span class="string">"<span class="variable">$server_name</span>"</span></span><br><span class="line">        DocumentRoot <span class="string">"<span class="variable">$doc_root</span>"</span></span><br><span class="line">        &lt;Directory <span class="string">"<span class="variable">$doc_root</span>"</span>&gt;</span><br><span class="line">                Options none</span><br><span class="line">                AllowOverride none</span><br><span class="line">                Require all granted</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">&lt;/Virtualhost&gt;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">#引用一个脚本的所有参数,默认的httpd进程/bin/bash的子进程&gt;，要想使得httpd作为init下的一级进程则如下写法(目标进程替换shell进程,让shell自动退出)</span></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># chmod +x /dockerlamp/ent.sh </span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker image build /dockerlamp/ -t lamp:v0.5</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -it --rm lamp:v0.5(可以在命令行中使用-e选项对容器中的环境变量传值 使用printenv命令可以查看传入变量的值 </span></span><br><span class="line">)</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container port pc1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># curl 172.18.135.1:32777</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it pc1 /bin/bash</span></span><br><span class="line">[root@5b32b59d73ef /]<span class="comment"># cat /etc/httpd/conf.d/myweb.conf </span></span><br><span class="line">listen 8080</span><br><span class="line">&lt;VirtualHost *:8080&gt;</span><br><span class="line">        ServerName <span class="string">"localhost"</span></span><br><span class="line">        DocumentRoot <span class="string">"/var/www/html"</span></span><br><span class="line">        &lt;Directory <span class="string">"/var/www/html"</span>&gt;</span><br><span class="line">                Options none</span><br><span class="line">                AllowOverride none</span><br><span class="line">                Require all granted</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">&lt;/Virtualhost&gt;</span><br><span class="line"><span class="comment">#httpd的进程号为1</span></span><br><span class="line">[root@2967451fc4a9 /]<span class="comment"># ps aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.7 408092 13436 pts/0    Ss+  09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache        8  0.0  0.3 408092  6748 pts/0    S+   09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache        9  0.0  0.3 408092  6748 pts/0    S+   09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache       10  0.0  0.3 408092  6748 pts/0    S+   09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache       11  0.0  0.3 408092  6748 pts/0    S+   09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache       12  0.0  0.3 408092  6748 pts/0    S+   09:19   0:00 usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">###############run是使用-e选项对容器进行变量复制############################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">(可以在命令行中使用-e选项对容器中的环境变量传值 使用printenv命令可以查看传入变量的值 )</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -it --rm -P -e LISTEN_PORT=1010 lamp:v0.10</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it pc1 /bin/bash</span></span><br><span class="line">[root@067566aa1878 /]<span class="comment"># printenv </span></span><br><span class="line">    LISTEN_PORT=1010</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -it --rm -P -e hi=hehe  lamp:v0.10</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it pc1 /bin/bash</span></span><br><span class="line">[root@2967451fc4a9 /]<span class="comment"># echo $hi</span></span><br><span class="line">    hehe</span><br></pre></td></tr></table></figure></p><ul><li><p><code>USER</code> </p><ul><li>用于指定运行image时的或运行Dockerfile中任何RUN、CMD或ENTRYPOINT 指令指定的程序时的用户名或UID </li><li>默认情况下，container的运行身份为root用户 </li><li>Syntax <ul><li>USER <uid>|<username> </username></uid></li><li>需要注意的是，<uid>可以为任意数字，但实践中其必须为/etc/passwd中某用户的有效 UID，否则，docker run命令将运行失败</uid></li></ul></li></ul></li><li><p><code>HEALTHCHECK健康状态检测（新版支持）</code></p><ul><li>HEALTHCHECK指令告诉Docker如何测试一个容器，以检查它是否仍在工作。这可以检测出一些情况，比如web服务器陷入无限循环，无法处理新连接，即使服务器进程仍在运行。 </li><li><p>HEALTHCHECK指令有两种形式:</p><ul><li>HEALTHCHECK [OPTIONS] CMD命令(通过在容器内运行命令来检查容器的健康状况)</li><li>HEALTHCHECK NONE(不做任何健康检测)</li></ul></li><li><p>HEALTHCHECK(2) </p></li><li>在CMD之前可以出现的选项有:<ul><li>–interval=DURATION (default: 30s) #每隔多久检测一次，检测频率默认为30秒</li><li>–timeout=DURATION (default: 30s)  #相对方发起检测请求，等待超时时长默认为30秒</li><li>–start-period=DURATION (default: 0s) #在什么时间开始进程健康检测，0表示容易以启动立刻做第一次健康检测</li><li>–retries=N (default: 3) #检测失败，重试检测多少吃后失败再判定为失败，默认为检测3次</li></ul></li><li>命令的退出状态指示容器的健康状态。可能的值是:<ul><li>0: success 成功</li><li>1: unhealthy 不健康</li><li>2: reserved 保留</li></ul></li><li>范例：<ul><li>HEALTHCHECK –interval=5m –timeout=3s \         <ul><li>CMD curl -f <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</li></ul></li></ul></li></ul></li></ul><p><code>Dockerfile文件中HEALTHCHECK健康状态检测指令（新版支持）</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">##########################定制健康检查计划##################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># vim /dockerlamp/Dockerfile </span></span><br><span class="line">FROM centos:7</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">ARG root=/var/www/html/</span><br><span class="line">RUN      yum makecache &amp;&amp; \</span><br><span class="line">        yum -y install httpd php php-mysql curl &amp;&amp; \</span><br><span class="line">        yum clean all &amp;&amp; \</span><br><span class="line">        rm -rf /var/cache/yum/*</span><br><span class="line">ADD ok.html php.php <span class="variable">$&#123;root&#125;</span></span><br><span class="line">ADD ent.sh /bin/</span><br><span class="line">EXPOSE 8080/tcp</span><br><span class="line">VOLUME <span class="variable">$&#123;root&#125;</span></span><br><span class="line">HEALTHCHECK --interval=3s --timeout=3s --start-period=2s CMD curl -f http://localhost/ok.html || <span class="built_in">exit</span> 1</span><br><span class="line">CMD [<span class="string">"usr/sbin/httpd"</span>,<span class="string">"-DFOREGROUND"</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">"/bin/ent.sh"</span>]</span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># ls</span></span><br><span class="line">Dockerfile  ent.sh  php.php</span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># echo "ok" &gt; ok.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">######################打镜像测试健康计划##################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker image build /dockerlamp/ -t lamp:v1.0</span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --name pc1 -it --rm lamp:v1.0 </span></span><br><span class="line"><span class="comment">#查看状态健康的</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS               NAMES</span><br><span class="line">763a1536b62d        lamp:v1.0           <span class="string">"/bin/ent.sh usr/sbi…"</span>   6 seconds ago       Up 5 seconds (healthy)   8080/tcp            pc1</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"><span class="comment">####################删除文件查看是否不健康##################################</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it pc1 /bin/bash</span></span><br><span class="line">[root@763a1536b62d /]<span class="comment"># rm -rf /var/www/html/ok.html </span></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">763a1536b62d        lamp:v1.0           <span class="string">"/bin/ent.sh usr/sbi…"</span>   3 minutes ago       Up 3 minutes (unhealthy)   8080/tcp            pc1</span><br><span class="line"></span><br><span class="line"><span class="comment">#一旦发现容器出错时，手动将容器杀死重新构建，此功能是容器引擎做不到的，需要借助容器编排工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果再构建镜像的时候未构建也可以再运行命令行运行容器时手动指定（人为的在外部定义）</span></span><br><span class="line"></span><br><span class="line">[root@centos7 dockerlamp]<span class="comment"># docker run --help</span></span><br><span class="line"></span><br><span class="line">Usage:docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">      --health-cmd string              Command to run to check health</span><br><span class="line">      --health-interval duration       Time between running the check (ms|s|m|h)</span><br><span class="line">                                       (default 0s)</span><br><span class="line">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-start-period duration   Start period <span class="keyword">for</span> the container to initialize</span><br><span class="line">                                       before starting health-retries countdown</span><br><span class="line">                                       (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-timeout duration        Maximum time to allow one check to run</span><br></pre></td></tr></table></figure></p><ul><li><p><code>SHELL</code></p><ul><li>指令允许覆盖命令的SHELL形式所使用的默认SHELL。</li><li>Linux上的默认shell是[“/bin/sh”， “-c”]</li><li>Windows上的默认shell是[“cmd”， “/S”， “/C”]</li><li>SHELL指令必须以JSON格式写入Dockerfile中</li><li>语法:SHELL[“可执行”，”参数”]</li><li>外壳指令可以出现多次。每个SHELL指令覆盖前面的所有SHELL指令，并影响后面的所有指令。</li></ul></li><li><p><code>STOPSIGNAL</code></p><ul><li>指令设置将发送到容器的系统调用信号以退出</li><li>这个信号可以是一个有效的无符号数字</li><li>它匹配内核的syscall表中的一个位置，例如9</li><li>也可以是SIGNAME格式的一个信号名，例如SIGKILL。</li><li>Syntax: <ul><li>STOPSIGNAL signal</li></ul></li></ul></li><li><p><code>ONBUILD</code> </p><ul><li>用于在Dockerfile中定义一个触发器 </li><li>Dockerfile用于build映像文件，此映像文件亦可作为base image被另一个Dockerfile 用作FROM指令的参数，并以之构建新的映像文件 </li><li>在后面的这个Dockerfile中的FROM指令在build过程中被执行时，将会“触发”创 建其base image的Dockerfile文件中的ONBUILD指令定义的触发器 </li><li>Syntax <ul><li>ONBUILD <instruction> </instruction></li><li>尽管任何指令都可注册成为触发器指令，但ONBUILD不能自我嵌套，且不会触发FROM和 MAINTAINER指令 </li><li>使用包含ONBUILD指令的Dockerfile构建的镜像应该使用特殊的标签，例如ruby:2.0-onbuild </li><li>在ONBUILD指令中使用ADD或COPY指令应该格外小心，因为新构建过程的上下文在缺少指 定的源文件时会失败</li></ul></li></ul></li></ul><p><code>Dockerfile文件中的ONBUILD指令</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当别人利用自己的镜像做基础镜像</span><br><span class="line">你自己先前定义好的dockerfile，当别人拿自己镜像做基础镜像再次创建的dockerfile文件，自己填写的ONBUILD指令在自己run的时候不会运行，当别人拿自己镜像在此基础上创建的dockerfile执行的时候才会运行自己定义的ONBUILD指令。</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义ONBUILD，当别人拿自己的镜像做基础镜像再次做dockerfile执行时则在/data/data目录中下载URL，自己run时则不执行</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir /test</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /test/</span></span><br><span class="line">[root@centos7 <span class="built_in">test</span>]<span class="comment"># vim Dockerfile</span></span><br><span class="line"></span><br><span class="line">FROM busybox:latest</span><br><span class="line">LABEL   maintainer=<span class="string">"daizhe&lt;daizhe@9527dz.top&gt;"</span></span><br><span class="line">RUN mkdir -p /data/data</span><br><span class="line">ONBUILD ADD http://nginx.org/download/nginx-1.2.9.tar.gz /data/data</span><br><span class="line"><span class="comment">#打镜像</span></span><br><span class="line">[root@centos7 <span class="built_in">test</span>]<span class="comment"># docker image build /test/ -t haha:v0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在自己制作的基础上再次制作</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir /test1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd !$</span></span><br><span class="line"><span class="built_in">cd</span> /test1</span><br><span class="line">[root@centos7 test1]<span class="comment"># vim Dockerfile</span></span><br><span class="line">FROM  haha:v0.1</span><br><span class="line">RUN mkdir -p /data/haha</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时第一次制作的镜像定义的ONBUILD 会执行</span></span><br><span class="line">[root@centos7 test1]<span class="comment"># docker image build /test1/ -t hehe:v0.1</span></span><br></pre></td></tr></table></figure></p><h3 id="如何将自己本地制作的镜像分享给别人"><a href="#如何将自己本地制作的镜像分享给别人" class="headerlink" title="如何将自己本地制作的镜像分享给别人"></a><code>如何将自己本地制作的镜像分享给别人</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">此场景适用于内部临时是使用、本地间的节点间共享</span><br><span class="line"></span><br><span class="line">将本地的镜像文件打包，剥离远程镜像仓库的格式，打包未tar文件，实现节点共享</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################抽取本地上的镜像######################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hehe                     v0.1                e75cb1954996        7 minutes ago       1.93M</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image save hehe:v0.1 -o ./jingxiang.tar</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ls</span></span><br><span class="line">jingxiang.tar</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################复制到其他节点，使用此镜像#################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image load -i jingxiang.tar</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dockerfile详解&quot;&gt;&lt;a href=&quot;#dockerfile详解&quot; class=&quot;headerlink&quot; title=&quot;dockerfile详解&quot;&gt;&lt;/a&gt;dockerfile详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/02/dockerfile详解/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker存储卷</title>
    <link href="https://9527dz.top/2019/01/01/docker%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    <id>https://9527dz.top/2019/01/01/docker存储卷/</id>
    <published>2019-01-01T05:33:50.632Z</published>
    <updated>2019-01-05T09:52:04.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器存储卷"><a href="#docker容器存储卷" class="headerlink" title="docker容器存储卷"></a>docker容器存储卷</h1><p><img src="/2019/01/01/docker存储卷/图标.png" alt=""><br><a id="more"></a></p><h2 id="一、什么是存储卷"><a href="#一、什么是存储卷" class="headerlink" title="一、什么是存储卷"></a>一、什么是存储卷</h2><ul><li>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜 像层并在镜像栈顶部添加一个读写层 </li><li>如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会 从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在， 只是已经被读写层中该文件的副本所隐藏，此即“写时复制(COW)”机制</li></ul><p><img src="/2019/01/01/docker存储卷/存储卷.png" alt=""></p><ul><li>关闭并重启容器，其数据不受影响；但删除Docker容器，则其更改将会 全部丢失 </li><li><p>存在的问题    </p><ul><li>存储于联合文件系统中，不易于宿主机访问； •容器间数据共享不便 </li><li>删除容器其数据会丢失 </li><li>解决方案：“卷(volume)” </li><li>“卷”是容器上的一个或多个“目录”，此类目录可绕过联合文件系统，与宿主机 上的某目录“绑定(关联)”</li></ul></li><li><p>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在 宿主机上的位置有所不同； </p><ul><li><code>绑定挂载的卷</code><ul><li>宿主机上的目录是用户指定的，在容器中的目录也是用户指定的</li></ul></li><li><code>docker管理的卷</code><ul><li>容器中的目录是用户指定的，在宿主机上的目录是在固定目录下自动生成的</li></ul></li></ul></li><li><code>脱离容器的生命周期，也可以脱离节点的生命周期</code></li></ul><h2 id="二-、存储卷实现"><a href="#二-、存储卷实现" class="headerlink" title="二 、存储卷实现"></a><code>二 、存储卷实现</code></h2><p><img src="/2019/01/01/docker存储卷/卷类型.png" alt=""></p><h3 id="1-docker管理的卷"><a href="#1-docker管理的卷" class="headerlink" title="1.docker管理的卷"></a><code>1.docker管理的卷</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"><span class="comment">#########################docker管理的卷####################</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.容器中的目录是用户指定的，在宿主机上的目录是在固定目录下自动生成的，-v选项指定绑定的卷，自动在容器中创建对应的目录，并且指定的容器中的目录与宿主机上目录建立了关联关系</span></span><br><span class="line"><span class="comment">#2.创建容器的命令行中使用--rm选项则退出容器时删除容器，宿主机上对应的存储卷则也将删除</span></span><br><span class="line"><span class="comment">#3.停止容器宿主机上的存储卷不会被删除</span></span><br><span class="line"><span class="comment">#3.如果使用docker container rm 容器，宿主机上对应的存储卷不会被删除</span></span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it  -v /mydata busybox</span></span><br><span class="line"> <span class="comment"># ls</span></span><br><span class="line">mydata </span><br><span class="line"></span><br><span class="line"><span class="comment">#可查看pc1容器对应的宿主机上的目录的关联关系</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker volume ls</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect pc1</span></span><br><span class="line">        <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"29fd92b6acf728b23323168ff82e7e34b588b46f1698db2adb6fe3d6bc9713d0"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/29fd92b6acf728b23323168ff82e7e34b588b46f1698db2adb6fe3d6bc9713d0/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/mydata"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#容器中创建文件</span></span><br><span class="line">/ <span class="comment"># cd /mydata/</span></span><br><span class="line">/mydata <span class="comment"># ls</span></span><br><span class="line">/mydata <span class="comment"># touch a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机在关联的目录中查看文件是否存在</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /var/lib/docker/volumes/29fd92b6acf728b23323168ff82e7e34b588b46f1698db2adb6fe3d6bc9713d0/_data</span></span><br><span class="line">[root@centos7 _data]<span class="comment"># ls</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line">/mydata <span class="comment"># exit</span></span><br><span class="line"><span class="comment">#宿主机上查看对应的目录</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps -a</span></span><br><span class="line">[root@centos7 _data]<span class="comment"># ls</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container rm pc1</span></span><br><span class="line">pc1</span><br><span class="line"><span class="comment">#宿主机上查看对应的存储卷目录</span></span><br><span class="line">[root@centos7 _data]<span class="comment"># ls</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="2-绑定挂载的卷"><a href="#2-绑定挂载的卷" class="headerlink" title="2.绑定挂载的卷"></a><code>2.绑定挂载的卷</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#######################绑定挂载的卷#########################</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机上的目录是用户指定的，在容器中的目录也是用户指定的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主上指定目录</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir /daizhe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建容器并指定宿主机上的存储卷和指定容器中的目录进行关联</span></span><br><span class="line"><span class="comment">#/daizhe为手动指定的宿主机的目录</span></span><br><span class="line"><span class="comment">#/mydata为手动指定的容器中的目录</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it -v /daizhe:/mydata busybox</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">mydata</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">/ <span class="comment"># cd /mydata/</span></span><br><span class="line">/mydata <span class="comment"># touch a</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ls /daizhe/</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器卷不会被删除</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container rm pc1</span></span><br><span class="line">pc1</span><br><span class="line">[root@centos7 ~]<span class="comment"># ls /daizhe/</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="3-多个容器挂载到宿主机上的同一个存储卷上"><a href="#3-多个容器挂载到宿主机上的同一个存储卷上" class="headerlink" title="3.多个容器挂载到宿主机上的同一个存储卷上"></a><code>3.多个容器挂载到宿主机上的同一个存储卷上</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#################多个容器挂载到宿主机上的同一个存储卷上########</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#创建三个容器，同时容器到宿主机的存储卷指定为同一个目录</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it -v /daizhe:/mydata busybox</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc2 -it -v /daizhe:/mydata2 busybox</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc3 -it -v /daizhe:/mydata3 busybox</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试是否同时挂载上宿主机上的同一个卷</span></span><br><span class="line"><span class="comment">#宿主机在此目录下创建文件</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /daizhe/</span></span><br><span class="line">[root@centos7 daizhe]<span class="comment"># touch a c ddd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检测宿主机上文件是否存在</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec pc1 ls /mydata</span></span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">ddd</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec pc2 ls /mydata2</span></span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">ddd</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec pc3 ls /mydata3</span></span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><ul><li>利用存储卷实现容器间共享数据</li><li>名称空间共享<ul><li>可共享<ul><li>Net、IPC、UTS</li></ul></li><li>不可共享<ul><li>Mount、User、PID</li></ul></li></ul></li></ul><p>-v,<br>      –volume list                    绑定安装卷<br>      –volume-driver string         容器的可选卷驱动程序<br>      –volumes-from list            从指定安装卷  </p><p><img src="/2019/01/01/docker存储卷/docker容器存储卷/2018-12-28_180239.png" alt=""></p><h3 id="4-容器间共享存储卷即容器间复制存储卷"><a href="#4-容器间共享存储卷即容器间复制存储卷" class="headerlink" title="4.容器间共享存储卷即容器间复制存储卷"></a><code>4.容器间共享存储卷即容器间复制存储卷</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器，将容器中的/mydata目录与宿主机的/daizhe进行挂载实现存储卷</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it -v /daizhe:/mydata busybox </span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">mydata </span><br><span class="line">/ <span class="comment"># touch /mydata/a c ddd</span></span><br><span class="line">/ <span class="comment"># ls /mydata/</span></span><br><span class="line">a    c    ddd</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个容器命令为pc2复制pc1的存储卷</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc2 -it --volumes-from pc1 busybox</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin     etc     mydata  root    tmp     var</span><br><span class="line">dev     home    proc    sys     usr</span><br><span class="line">/ <span class="comment"># ls /mydata/</span></span><br><span class="line">a    c    ddd</span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机上查看</span></span><br><span class="line">[root@centos7 daizhe]<span class="comment"># ls</span></span><br><span class="line">a  c  ddd</span><br></pre></td></tr></table></figure><h3 id="在容器中使用Volumes"><a href="#在容器中使用Volumes" class="headerlink" title="在容器中使用Volumes"></a><code>在容器中使用Volumes</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 为docker run命令使用-v选项即可使用Volume   </span><br><span class="line">    - Docker-managed volume   </span><br><span class="line">        - ~]<span class="comment"># docker  run  -it  -name bbox1 –v /data  busybox   </span></span><br><span class="line">        - ~]<span class="comment"># docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox1   </span></span><br><span class="line">- 查看bbox1容器的卷、卷标识符及挂载的主机目录   </span><br><span class="line">    - Bind-mount Volume   </span><br><span class="line">        - ~]<span class="comment"># docker run -it -v HOSTDIR:VOLUMEDIR --name bbox2   busybox   </span></span><br><span class="line">        - ~]<span class="comment"># docker inspect -f &#123;&#123;.Mounts&#125;&#125; bbox2</span></span><br></pre></td></tr></table></figure><p><code>详细信息过滤</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示的文件为json的文件格式</span></span><br><span class="line">- 字段内嵌</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect pc1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用一级字段过滤</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect -f &#123;&#123;.NetworkSettings&#125;&#125; pc1</span></span><br><span class="line">&#123;&#123; c01b6a9b6146da49e5374db58e8aae168286c29b5b2fb0a814673415a4e4d796 <span class="literal">false</span>  0 map[] /var/run/docker/netns/c01b6a9b6146 [] []&#125; &#123;3db3b94ed903cdc6e5dfa72af482b30ff16faf23a08d697e4e3d3f0c01175e42 172.17.0.1  0 172.17.0.2 16  02:42:ac:11:00:02&#125; map[bridge:0xc4205aa000]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#引用二级字段过滤</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container inspect -f &#123;&#123;.NetworkSettings.Networks.bridge.IPAddress&#125;&#125; pc1</span></span><br><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure></p><p><code>josn格式文件美观显示</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># yum install jq -y</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker容器存储卷&quot;&gt;&lt;a href=&quot;#docker容器存储卷&quot; class=&quot;headerlink&quot; title=&quot;docker容器存储卷&quot;&gt;&lt;/a&gt;docker容器存储卷&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/01/docker存储卷/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker网络模型</title>
    <link href="https://9527dz.top/2018/12/31/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    <id>https://9527dz.top/2018/12/31/docker网络模型及存储卷/</id>
    <published>2018-12-31T07:04:09.152Z</published>
    <updated>2018-12-31T13:14:06.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker网络模型"><a href="#docker网络模型" class="headerlink" title="docker网络模型"></a>docker网络模型</h1><p><img src="/2018/12/31/docker网络模型及存储卷/图标.png" alt=""><br><a id="more"></a></p><h2 id="Docker网络模型详解"><a href="#Docker网络模型详解" class="headerlink" title="Docker网络模型详解"></a>Docker网络模型详解</h2><ul><li><code>四种网络</code><ul><li>桥网络bridge：<ul><li>默认docker0 NET桥</li></ul></li><li>共享桥、共享接口：（共享网络名称空间）<ul><li>联盟式网络</li></ul></li><li>容器直接使用宿主机网络的共享<ul><li>host网络</li></ul></li><li>空网络、无网络、none网络<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看docker可以使用的网络类型</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">38c0658bea06        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">9b7ecc0031ef        host                host                <span class="built_in">local</span></span><br><span class="line">c0de873b7341        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>共享桥<br><img src="/2018/12/31/docker网络模型及存储卷/2018-12-28_161058.png" alt=""></p><ul><li>无网络：仅lo,仅自己通讯<ul><li>–network none</li></ul></li><li>桥网络 (详情查看 dacker network inspact brige)<ul><li>–network  brige (默认)</li></ul></li><li>容器间共享网络（联盟式网络）<ul><li>–network contariner:指定已有网容器（相同主机名，不同容器，但是网络是共享，仅共享网络，可以基于127.0.0.1通讯）</li></ul></li><li>共享主机网络<ul><li>–network host</li></ul></li></ul><p><code>无网络</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it --rm --network none busybox:latest</span></span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure></p><p><code>桥网络</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (默认docker0 NET桥,详情查看 dacker network inspact brige)</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc2 -it --rm --network bridge busybox:latest</span></span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:508 (508.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看默认的net桥的详情</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network inspect bridge</span></span><br></pre></td></tr></table></figure></p><p><code>容器间共享网络</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#容器间共享：NET,IPC,UTS</span></span><br><span class="line"></span><br><span class="line">第一个容器</span><br><span class="line">  [root@centos7 ~]<span class="comment"># docker run --name pc2 -it --rm --network bridge busybox:latest</span></span><br><span class="line">  / <span class="comment"># ifconfig</span></span><br><span class="line">  eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:7 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:578 (578.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">  lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">  / <span class="comment"># hostname</span></span><br><span class="line">  45ec3fb534cd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个容器（共享第一个容器的地址）</span><br><span class="line">  [root@centos7 ~]<span class="comment"># docker run --name pc3 -it --rm --network container:pc2 busybox:latest</span></span><br><span class="line">  / <span class="comment"># ifconfig</span></span><br><span class="line">  eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">  lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">  / <span class="comment"># hostname</span></span><br><span class="line">  45ec3fb534cd</span><br></pre></td></tr></table></figure></p><p><code>共享宿主机网络</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  [root@centos7 ~]<span class="comment"># docker run --name pc4 -it --rm --network host  busybox:latest</span></span><br><span class="line">  / <span class="comment"># ifconfig</span></span><br><span class="line">  docker0   Link encap:Ethernet  HWaddr 02:42:D4:BB:AF:CF  </span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:d4ff:febb:afcf/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:21 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:41 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:3522 (3.4 KiB)  TX bytes:3758 (3.6 KiB)</span><br><span class="line"></span><br><span class="line">  ens33     Link encap:Ethernet  HWaddr 00:0C:29:14:4D:62  </span><br><span class="line">          inet addr:192.168.52.1  Bcast:192.168.52.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::bbfd:d184:6a67:3c45/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:264 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:38 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:29263 (28.5 KiB)  TX bytes:4779 (4.6 KiB)</span><br><span class="line"></span><br><span class="line">  ens37     Link encap:Ethernet  HWaddr 00:0C:29:14:4D:6C  </span><br><span class="line">          inet addr:172.18.135.1  Bcast:172.18.135.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::4587:5c47:4c05:570b/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:33565 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8191 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:14694609 (14.0 MiB)  TX bytes:1013772 (990.0 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:98 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:98 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:10996 (10.7 KiB)  TX bytes:10996 (10.7 KiB)</span><br><span class="line"></span><br><span class="line">  veth7ff20ba Link encap:Ethernet  HWaddr C2:81:A1:34:BA:5F  </span><br><span class="line">          inet6 addr: fe80::c081:a1ff:fe34:ba5f/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">  virbr0    Link encap:Ethernet  HWaddr 52:54:00:FF:0B:1F  </span><br><span class="line">          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">  </span><br><span class="line">  / <span class="comment"># hostname</span></span><br><span class="line">  centos7.com</span><br></pre></td></tr></table></figure></p><h3 id="其他网络相关的命令"><a href="#其他网络相关的命令" class="headerlink" title="其他网络相关的命令"></a><code>其他网络相关的命令</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################指定主机名##########################</span></span><br><span class="line">  -h, --hostname string                </span><br><span class="line">      Container host name</span><br><span class="line"><span class="comment">#默认的主机名是docker容器对应的id</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name p1 -it --rm --hostname p1.com busybox:latest </span></span><br><span class="line">/ <span class="comment"># hostname</span></span><br><span class="line">p1.com</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################外部指定host文件以及文件的内容############</span></span><br><span class="line"> --add-host list                  </span><br><span class="line">      Add a custom host-to-IP mapping (host:ip)</span><br><span class="line"><span class="comment">#适用于容器间使用主机名通信，可多次使用</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name p1 -it --rm --hostname p1.com --add-host wg.p1.com:172.18.0.1 busybox:latest </span></span><br><span class="line">/ <span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.18.0.1wg.p1.com</span><br><span class="line">172.17.0.2p1.com p1</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name p1 -it --rm --hostname p1.com --add-host wg.p1.com:172.18.0.1 --add-host www.p1.com:8.8.8.8 busybox:latest </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#############创建容器时指定NDS服务器地址以及搜索域#################</span></span><br><span class="line">  --dns list                       Set custom DNS servers</span><br><span class="line">  --dns-search list                Set custom DNS search domains</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 -it --rm --hostname pc1.com --add-host www.pc1.com:1.1.1.1 --dns 8.8.8.8 --dns 114.114.114.114 --dns-search com busybox</span></span><br><span class="line">/ <span class="comment"># cat /etc/hosts </span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">1.1.1.1www.pc1.com</span><br><span class="line">172.17.0.2pc1.com pc1</span><br><span class="line">/ <span class="comment"># cat /etc/resolv.conf </span></span><br><span class="line">search com</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><h2 id="服务暴漏-expose-public"><a href="#服务暴漏-expose-public" class="headerlink" title="服务暴漏 expose,public"></a><code>服务暴漏 expose,public</code></h2><p>让私有网络中的主机上的服务被外部主机访问到—DNAT</p><ul><li><p><code>-p选项的使用格式</code> </p><ul><li><code>-p &lt;containerPort&gt;</code><ul><li><code>将指定的容器端口映射至宿主机所有地址的一个动态端口</code></li></ul></li><li><code>-p  &lt;hostPort&gt;:&lt;containerPort&gt;</code> <ul><li><code>将容器端口&lt;containerPort&gt;映射至宿主机上指定的主机端口&lt;hostPort&gt;（宿主机上所有地址的此端口）</code> </li></ul></li><li><p><code>-p &lt;ip&gt;::&lt;containerPort&gt;</code> </p><ul><li><code>将指定的容器端口&lt;containerPort&gt;映射至宿主机指定&lt;ip&gt;的动态端口</code> </li></ul></li><li><code>-p &lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;</code> <ul><li><code>将指定的容器端口&lt;containerPort&gt;映射至宿主机指定&lt;ip&gt;的端口&lt;hostPort&gt;</code> </li><li><code>“动态端口”指随机端口，具体的映射结果可使用docker port命令查看</code></li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">-p选项的使用演示，可重复使用多次</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment">########docker容器的80端口映射宿主机上的随机端口#####################</span></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container run --name pc5 -it -p 80 busybox</span></span><br><span class="line"><span class="comment">#ctrl + p ctrl + q</span></span><br><span class="line"><span class="comment">#宿主机查看防火墙</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 214 packets, 20360 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:32770 to:172.17.0.2:80</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以访问宿主机的映射的端口从而访问容器的httpd服务</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it  pc5  /bin/sh</span></span><br><span class="line">/ <span class="comment"># /bin/httpd -h /etc</span></span><br><span class="line">/ <span class="comment"># ps</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 sh</span><br><span class="line">    7 root      0:00 /bin/sh</span><br><span class="line">   13 root      0:00 /bin/httpd -h /etc</span><br><span class="line">   14 root      0:00 ps</span><br><span class="line">/ <span class="comment"># read escape sequence</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># curl 172.18.135.1:32770</span></span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;404 Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;&lt;H1&gt;404 Not Found&lt;/H1&gt;</span><br><span class="line">The requested URL was not found</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">###########docker容器的80端口映射宿主机上的所有地址的80端口#########</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc2 -it --network bridge -p 80:80 busybox</span></span><br><span class="line">/ <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看防火墙</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 42 packets, 3276 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                NAMES</span><br><span class="line">7e622f638dba        busybox             <span class="string">"sh"</span>                3 minutes ago       Up 3 minutes        0.0.0.0:80-&gt;80/tcp   pc2</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">##########docker容器的80端口映射宿主机上的指定地址的80端口##########</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment">#第一个端口为宿主机的端口，第二个端口为容器的端口</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container run --name pc1 -it --rm --network bridge -p 172.18.135.1:80:80 busybox</span></span><br><span class="line">/ <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器的80地址绑定到宿主机的135.1地址的80端口</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 9 packets, 702 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            172.18.135.1         tcp dpt:80 to:172.17.0.2:80</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                     NAMES</span><br><span class="line">e87a037e4348        busybox             <span class="string">"sh"</span>                About a minute ago   Up About a minute   172.18.135.1:80-&gt;80/tcp   pc1</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"><span class="comment">##########docker容器的80端口映射宿主机上的指定地址的随机端口#########</span></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container run --name pc1 -it --rm --network bridge -p 172.18.135.1::80 busybox</span></span><br><span class="line">/ <span class="comment"># [root@centos7 ~]# </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机检验</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 15 packets, 1151 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            172.18.135.1         tcp dpt:32768 to:172.17.0.2:80</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                        NAMES</span><br><span class="line">8dd54f2321cd        busybox             <span class="string">"sh"</span>                About a minute ago   Up About a minute   172.18.135.1:32768-&gt;80/tcp   pc1</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment">######################端口映射关系查看##############################</span></span><br><span class="line"><span class="comment">###################################################################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container port pc2</span></span><br><span class="line">443/tcp -&gt; 192.168.52.1:443</span><br><span class="line">80/tcp -&gt; 172.18.135.1:80</span><br></pre></td></tr></table></figure><p>范例：-p 选项多重复使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># docker container run --name pc2 -it --rm --network bridge -p 172.18.135.1:80:80 -p 192.168.52.1:443:443 busybox</span></span><br><span class="line">/ <span class="comment"># [root@centos7 ~]# </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                                NAMES</span><br><span class="line">028e3e9f581f        busybox             <span class="string">"sh"</span>                13 seconds ago      Up 13 seconds       172.18.135.1:80-&gt;80/tcp, 192.168.52.1:443-&gt;443/tcp   pc2</span><br><span class="line">8dd54f2321cd        busybox             <span class="string">"sh"</span>                5 minutes ago       Up 5 minutes        172.18.135.1:32768-&gt;80/tcp                           pc1</span><br></pre></td></tr></table></figure></p><h3 id="自建网络类型"><a href="#自建网络类型" class="headerlink" title="自建网络类型"></a><code>自建网络类型</code></h3><ul><li>docker network create [OPTIONS] NETWORK<ul><li>-d, –driver string     #指定网络类型，默认为bridge，NET</li><li>–subnet strings        #指定子网地址，默认第一个地址设置为桥接口（网关）的地址</li><li>–gateway strings       #不使用默认的手动指定网关</li><li>–ip-range strings      #指定网络分配的地址，如果不指定则除网关外全部分配</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################自建网络地址######################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network create -d bridge --subnet 10.0.0.0/24 mybr0</span></span><br><span class="line">9902c4e06158ac6bcbabd2aa917b421e3b90d10100c7c457214da834268946e2</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">499e8e1a5fe6        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">9b7ecc0031ef        host                host                <span class="built_in">local</span></span><br><span class="line">9902c4e06158        mybr0               bridge              <span class="built_in">local</span></span><br><span class="line">c0de873b7341        none                null                <span class="built_in">local</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ifconfig</span></span><br><span class="line">br-9902c4e06158: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.0.1  netmask 255.255.255.0  broadcast 10.0.0.255</span><br><span class="line">        ether 02:42:c9:35:05:ce  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 384  bytes 43480 (42.4 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 38  bytes 4779 (4.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment">####################将新创建的容器添加到自建的网络中###############</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name pc1 --rm -it --network mybr1  busybox</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec -it pc1 /bin/sh</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec pc1 ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:02:02  </span><br><span class="line">          inet addr:192.168.2.2  Bcast:192.168.2.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:24 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:2650 (2.5 KiB)  TX bytes:0 (0.0 B)</span><br><span class="line"><span class="comment">#可以自己修改网卡名字</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ifconfig br-9902c4e06158 down</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ip link set br-9902c4e06158 name mybr0</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># ifconfig mybr0 up</span></span><br><span class="line"><span class="comment">#但是要重新启动docker</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl daemon-reload </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################将此容器连接到bridge网络中#################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network connect bridge pc1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec pc1 ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:02:02  </span><br><span class="line">          inet addr:192.168.2.2  Bcast:192.168.2.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:24 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:2650 (2.5 KiB)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:7 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:578 (578.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"><span class="comment">#####################将一个网络接口从此容器中拆除###################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network disconnect bridge pc1</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker exec pc1 ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:02:02  </span><br><span class="line">          inet addr:192.168.2.2  Bcast:192.168.2.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:24 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:2650 (2.5 KiB)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><h3 id="修改默认的docker0桥"><a href="#修改默认的docker0桥" class="headerlink" title="修改默认的docker0桥"></a><code>修改默认的docker0桥</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">自定义docker0桥的网络属性信息：/etc/docker/daemon.json文件</span><br><span class="line">[root@centos7 ~]<span class="comment"># vim /etc/docker/daemon.json </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xr8r3tc3.mirror.aliyuncs.com"</span>],</span><br><span class="line">            <span class="string">"bip"</span>: <span class="string">"192.168.1.5/24"</span>,</span><br><span class="line">            <span class="string">"fixed-cidr"</span>: <span class="string">"10.20.0.0/16"</span>,</span><br><span class="line">            <span class="string">"fixed-cidr-v6"</span>: <span class="string">"2001:db8::/64"</span>,</span><br><span class="line">            <span class="string">"mtu"</span>: 1500,</span><br><span class="line">            <span class="string">"default-gateway"</span>: <span class="string">"10.20.1.1"</span>,</span><br><span class="line">            <span class="string">"default-gateway-v6"</span>: <span class="string">"2001:db8:abcd::89"</span>,</span><br><span class="line">            <span class="string">"dns"</span>: [<span class="string">"10.20.1.2"</span>,<span class="string">"10.20.1.3"</span>]</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        核心选项为bip，即bridge ip之意，用于指定docker0桥自身的IP地址；其它选项可通过此地址计算得出。</span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl daemon-reload </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line"></span><br><span class="line">文档路径：</span><br><span class="line">            https://docs.docker.com/engine/userguide/networking/default_network/custom-docker0/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker网络模型&quot;&gt;&lt;a href=&quot;#docker网络模型&quot; class=&quot;headerlink&quot; title=&quot;docker网络模型&quot;&gt;&lt;/a&gt;docker网络模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/31/docker网络模型及存储卷/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker应用基础</title>
    <link href="https://9527dz.top/2018/12/30/docker%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://9527dz.top/2018/12/30/docker应用基础/</id>
    <published>2018-12-30T06:38:28.238Z</published>
    <updated>2018-12-31T07:03:13.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker应用基础"><a href="#docker应用基础" class="headerlink" title="docker应用基础"></a>docker应用基础</h1><p><img src="/2018/12/30/docker应用基础/图标.png" alt=""><br><a id="more"></a><br><img src="/2018/12/30/docker应用基础/a.png" alt=""></p><ul><li>docker：容器使用的前端工具<ul><li>组件：(彼此间通过http/https协议进行通讯)<ul><li>Client : 客户端</li><li>Daemon ：docker守护进程、服务端</li><li>Registry : docker镜像仓库</li></ul></li></ul></li></ul><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##########################确保时间同步########################</span></span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># ntpdata ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################下载docker yum源######################</span></span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># pwd</span></span><br><span class="line">/etc/yum.repos.d</span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo     #下载的docker源为阿里云</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################安装docker社区版########################</span></span><br><span class="line">如果有报错</span><br><span class="line">Error: Package: 3:docker-ce-18.09.0-3.el7.x86_64 (docker-ce-stable)</span><br><span class="line">           Requires: container-selinux &gt;= 2.9</span><br><span class="line"> You could try using --skip-broken to work around the problem</span><br><span class="line"> You could try running: rpm -Va --nofiles --nodigest</span><br><span class="line"></span><br><span class="line">yum install http://vault.centos.org/centos/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">[root@centos7 yum.repos.d]<span class="comment"># yum install docker-ce</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################使用镜像加速#####################</span></span><br><span class="line">方式一：aliyun官网镜像加速</span><br><span class="line">  https://cr.console.aliyun.com</span><br><span class="line">方式二：docker公共加速器</span><br><span class="line">  http://www.docker-cn.com/registry-mirror</span><br><span class="line">支持两种方式同时使用</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir -p /etc/docker</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xr8r3tc3.mirror.aliyuncs.com"</span>,<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###################查看docker客户端版本和服务端版本############</span></span><br><span class="line">查看版本信息</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker version</span></span><br><span class="line">Client: <span class="comment">#客户端版本</span></span><br><span class="line"> Version:           18.09.0</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.4</span><br><span class="line"> Git commit:        4d60db4</span><br><span class="line"> Built:             Wed Nov  7 00:48:22 2018</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community <span class="comment">#服务端版本</span></span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.0</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.4</span><br><span class="line">  Git commit:       4d60db4</span><br><span class="line">  Built:            Wed Nov  7 00:19:08 2018</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">查看更详细的docker环境信息</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker info</span></span><br><span class="line">Containers: 0 <span class="comment">#系统上总共有多少个容器</span></span><br><span class="line"> Running: 0 <span class="comment">#容器运行态个数</span></span><br><span class="line"> Paused: 0  <span class="comment">#容器暂停态个数</span></span><br><span class="line"> Stopped: 0 <span class="comment">#容器停止态个数</span></span><br><span class="line">Images: 0 <span class="comment">#当前系统上镜像的个数</span></span><br><span class="line">Server Version: 18.09.0</span><br><span class="line">Storage Driver: overlay2  <span class="comment">#存储驱动</span></span><br><span class="line"> Backing Filesystem: xfs  <span class="comment">#放置在本地的文件系统的格式，建议使用xfs</span></span><br><span class="line"> Supports d_type: <span class="literal">true</span></span><br><span class="line"> Native Overlay Diff: <span class="literal">true</span></span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs <span class="comment">#资源配额功能，需要的虚拟文件系统格式</span></span><br><span class="line">Plugins:  <span class="comment">#插件</span></span><br><span class="line"> Volume: <span class="built_in">local</span>  <span class="comment">#存储卷的插件，仅支持本地</span></span><br><span class="line"> Network: bridge host macvlan null overlay  <span class="comment">#网络插件，支持桥接、主机、叠加、不使用等</span></span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald  json-file <span class="built_in">local</span> logentries splunk syslog <span class="comment">#日志系统插件</span></span><br><span class="line">Swarm: inactive <span class="comment">#集群管理工具</span></span><br><span class="line">Runtimes: runc  <span class="comment">#运行时环境</span></span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: c4446665cb9c30056f4998ed953e6d4ff22c7c39</span><br><span class="line">runc version: 4fc53a81fb7c994640722ac585fa9ca548971871</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 3.10.0-862.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 2</span><br><span class="line">Total Memory: 1.779GiB</span><br><span class="line">Name: centos7.com</span><br><span class="line">ID: CUT4:A7LF:QJ4B:OORH:POA7:AZ7I:SWFT:7F4H:YKBQ:YFXH:BBBV:WGNQ</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): <span class="literal">false</span></span><br><span class="line">Debug Mode (server): <span class="literal">false</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: <span class="literal">false</span></span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors: <span class="comment">#镜像加速服务</span></span><br><span class="line"> https://xr8r3tc3.mirror.aliyuncs.com/</span><br><span class="line">Live Restore Enabled: <span class="literal">false</span></span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h2 id="docker资源管理"><a href="#docker资源管理" class="headerlink" title="docker资源管理"></a>docker资源管理</h2><ul><li>两类资源<ul><li>images:镜像资源管理（静态）<ul><li>docker image -h</li><li>Usage:    docker image COMMAND</li><li>Commands:<ul><li>build      </li><li>history    </li><li>import    </li><li>inspect  </li><li>load    </li><li>ls         </li><li>prune       </li><li>pull    #从远程下载镜像</li><li>push    #将本地的镜像上传</li><li>rm      #删除 docker image rm = docker rmi</li><li>save    </li><li>tag     #给镜像打标签,一个镜像可以有多个标签</li></ul></li></ul></li><li>container：容器管理（动态）<ul><li>Usage:    docker container COMMAND</li><li>Commands:<ul><li>attach      </li><li>commit     #保存镜像</li><li>cp      </li><li>create     #创建容器</li><li>diff      </li><li>exec       #执行容器中的命令</li><li>export  </li><li>inspect     </li><li>kill       #杀死容器</li><li>logs      </li><li>ls         </li><li>pause     #暂停容器</li><li>port      </li><li>prune     </li><li>rename    #重命名容器</li><li>restart   #重启容器</li><li>rm        #删除容器</li><li>run        </li><li>start     #启动容器</li><li>stats      </li><li>stop      #停止容器</li><li>top      </li><li>unpause   #继续容器</li><li>update  </li><li>wait      </li></ul></li></ul></li></ul></li></ul><h2 id="docker容器状态"><a href="#docker容器状态" class="headerlink" title="docker容器状态"></a>docker容器状态</h2><ul><li>容器的状态docker container ps = docker ps<ul><li>running 运行态</li><li>stopped 停止态</li><li>paused  暂停态</li><li>created 创建态</li><li>deleted 删除态</li></ul></li></ul><p><img src="/2018/12/30/docker应用基础/容器的状态.png" alt=""></p><ul><li>OOM:内存耗尽</li></ul><h2 id="docker容器命令使用"><a href="#docker容器命令使用" class="headerlink" title="docker容器命令使用"></a>docker容器命令使用</h2><ul><li>创建容器<ul><li>docker create</li><li>docker run<ul><li>-t,tty</li><li>-i,–interactive</li><li>–name  #容器的名字一定不要同名</li></ul></li><li>docker0 : 桥<ul><li>172.17.0.0/16</li></ul></li><li>–network : 指定网络接口</li><li>–rm : 如果容器停止寓意容器引擎立即将其容器删除 # 适用于临时的容器与-d 选项项抵触</li><li>-d,detach : 守护，运行在后台剥离与当前终端的关系  #与–rm选项相抵触不可同时使用</li></ul></li><li>容器中执行命令   #只有终端id号为1 的进程则此容器才会停止<ul><li>docker container exec = docker exec<ul><li>-i:交互式接口</li><li>-t:分配终端</li></ul></li></ul></li><li>docker常用命令<ul><li>docker stop  #停止容器的运行</li><li>docker rm    #删除容器，直接删除则容器中的数据也将删除，代表容器内的存储单元也被删除掉，且慎用。</li></ul></li><li>查看容器的日志信息<ul><li>docker container logs = docker logs<ul><li>docker日志是直接发往终端控制台</li></ul></li></ul></li><li><p>查看容器使用占用的内存空间</p><ul><li>docker container stats = docker stats</li></ul></li><li><p>显示容器运行的所有的进程的相关信息</p><ul><li>docker container  top = docker top  </li></ul></li><li>列出所有的相关镜像<ul><li>docker images = docker image ls</li></ul></li><li><p>返回容器的终端</p><ul><li>docker container attach = docker attach </li></ul></li><li><p>去docker hub中下载nginx镜像时：最后一位数字为奇数数位金丝雀版，非稳定版，开发版。生产中最好使用偶数或者stable</p></li><li>某一程序如果运行在容器中，并且id号为1的进程时，此进程必须运行在前台。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################根据关键字来了解镜像################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker search redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###################拖取镜像到本地######################</span></span><br><span class="line"><span class="comment">###################默认从hub.docker.com拖取###########</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image pull centos:7</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker pull redis:4-alpine</span></span><br><span class="line">4-alpine: Pulling from library/redis</span><br><span class="line">cd784148e348: Pull complete   <span class="comment">#分层拖下来的，每一个都是一个层</span></span><br><span class="line">48d4c7155ddc: Pull complete </span><br><span class="line">6d908603dbe8: Pull complete </span><br><span class="line">fd4371c1c78e: Pull complete </span><br><span class="line">e6818dc808c2: Pull complete </span><br><span class="line">f1884d594f6f: Pull complete </span><br><span class="line">Digest: sha256:775bbf766a5b711acce88e4142faf56cd587d63ddc4d57b49f7872f71d56fab6</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:4-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">###################显示本地镜像########################</span></span><br><span class="line">REPOSITORY：镜像仓库仓库名</span><br><span class="line">TAG：标签</span><br><span class="line">IMAGE ID: 镜像id</span><br><span class="line">CREATED: 镜像的创建时间</span><br><span class="line">SIZE：镜像存储在本地的大小</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               4-alpine            37abb58bfd68        9 days ago          30MB</span><br><span class="line"></span><br><span class="line"><span class="comment">######################删除镜像#########################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image rm   镜像名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################查看镜像的详细信息###############</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image inspect redis:4-alpine</span></span><br><span class="line"><span class="comment">#显示一个jesn格式镜像信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################启动容器######################</span></span><br><span class="line">docker run = docker container run </span><br><span class="line">- it :交互式，并附加终端</span><br><span class="line">--name:容器名字</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container run -it --name c1 centos:7 /bin/bash</span></span><br><span class="line">[root@3aee0a6acdfd /]<span class="comment"># </span></span><br><span class="line">[root@3aee0a6acdfd /]<span class="comment"># yum install net-tools</span></span><br><span class="line">[root@3aee0a6acdfd /]<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">[root@3aee0a6acdfd /]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line">如果运行容器主机上默认生成一docker0的桥，默认网段172.17.0.0 ，随后创建的容器都会加载到此桥上，此桥为NET桥</span><br><span class="line">[root@centos7 ~]<span class="comment"># ifconfig</span></span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:ddff:fed7:23fb  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:dd:d7:23:fb  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 14  bytes 1770 (1.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[root@centos7 ~]<span class="comment"># brctl show  #容器引擎动态实现</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.0242ddd723fbno</span><br><span class="line"></span><br><span class="line">启动容器后也会生成默认防火墙规则</span><br><span class="line">  前期使用建议关闭firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">##################查看所有运行状态的容器#####################</span></span><br><span class="line">- docker ps = docker container ps</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps -a  #查看容器的所有状态</span></span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">3aee0a6acdfd        centos:7            <span class="string">"/bin/bash"</span>         12 minutes ago      Up 12 minutes                           c1</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################显示当前docker支持的网络接口#############</span></span><br><span class="line">- 默认bridge,代表docker0桥</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">777fc349679b        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">9b7ecc0031ef        host                host                <span class="built_in">local</span></span><br><span class="line">c0de873b7341        none                null                <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################运行redis进程且放到后台不影响当前终端########</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name redis -d redis:4-alpine </span></span><br><span class="line">100f426c23ae6f50e015e7ad5fd13cdee33180c9ac43835f7d6ecef422b38f1c</span><br><span class="line"></span><br><span class="line">- CONTAINER ID：短格式id</span><br><span class="line">- IMAGE :容器启动用的镜像</span><br><span class="line">- COMMAND：容器运行的命令</span><br><span class="line">- CREATED：容器创建的时间</span><br><span class="line">- STATUS：容器运行的状态</span><br><span class="line">- PORTS：容器监听的端口，监听的端口是在容器内部的</span><br><span class="line">- NAMES：容器的名称</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">100f426c23ae        redis:4-alpine      <span class="string">"docker-entrypoint.s…"</span>   8 seconds ago       Up 6 seconds        6379/tcp            redis</span><br><span class="line"></span><br><span class="line"><span class="comment">######################删除正在运行容器#########################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container stop redis</span></span><br><span class="line">redis</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container rm redis   #如果容器停止寓意容器引擎立即将其容器删除</span></span><br><span class="line">redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################外部在容器中执行命令##################</span></span><br><span class="line">以交互式接口中运行bash</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec -it redis /bin/sh</span></span><br><span class="line">/data <span class="comment"># </span></span><br><span class="line">/data <span class="comment"># ps aux</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 redis     0:00 redis-server <span class="comment">#只有终端id号为1 的进程则此容器才会停止，所以退出交互式终端并非结束了次容器</span></span><br><span class="line">   17 root      0:00 /bin/sh</span><br><span class="line">   23 root      0:00 ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################w外部终端查看容器运行状态#############</span></span><br><span class="line">- 在不进入容器的交互式接口，显示的信息为容器内部的运行状态信息</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec redis ps aux</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 redis     0:00 redis-server</span><br><span class="line">   24 root      0:00 ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment">######################创建容器在停止状态是自动删除###########</span></span><br><span class="line">- 拉取一个nginx的镜像</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image pull nginx:1.15-alpine</span></span><br><span class="line">- 运行执行的/bin/sh,并且退出终端时结束删除此进程</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name web -it --rm nginx:1.15-alpine /bin/sh</span></span><br><span class="line">/ <span class="comment"># </span></span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps -a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################以守护进程运行nginx#####################</span></span><br><span class="line">-d与--rm 选项不可同时使用</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name web -d nginx:1.15-alpine </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container exec web ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">[root@centos7 ~]<span class="comment"># curl 172.17.0.2         #外部主机访问容器中的服务</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># wget -O - -q 172.17.0.2</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># elinks -dump 172.17.0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################查看容器的日志信息#######################</span></span><br><span class="line">- docker日志是直接发往终端控制台，</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container logs web</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################显示容器运行的所有的进程的相关信息###########</span></span><br><span class="line">- 仅显示指定的容器的运行的进程的相关信息</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker  top web</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line"><span class="comment">###########################attach#########################</span></span><br><span class="line"><span class="comment"># 剥离容器当前运行的终端，但是容器仅是退出了运行的终端，但不停止容器</span></span><br><span class="line"><span class="comment"># 剥离终端 ctrl+p ,ctrl+q</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name c2 centos:7</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">2b5aa9c9e6ad        centos:7            <span class="string">"/bin/bash"</span>              8 seconds ago       Exited (0) 6 seconds ago                       c2</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker rm c2</span></span><br><span class="line">c2</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name c2 -it centos:7</span></span><br><span class="line">[root@49e278ef42ca /]<span class="comment"># [root@centos7 ~]# </span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">49e278ef42ca        centos:7            <span class="string">"/bin/bash"</span>              40 seconds ago      Up 39 seconds                                 c2</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container attach c2</span></span><br><span class="line">[root@49e278ef42ca /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h2><ul><li>About Docker Images <ul><li>Docker镜像含有启动容器所需要的文件系统及其内容，因此，其用 于创建并启动docker容器 </li><li>采用分层构建机制，最底层为bootfs，其之为rootfs <ul><li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以 节约内存资源； </li><li>rootfs：位于bootfs之上，表现为docker容器的根文件系统; <ul><li>传统模式中，系统启动之时，内核挂载rootfs时会首先将其挂载为“只读”模式，完整性自检完成 后将其重新挂载为读写模式； </li><li>docker中，rootfs由内核挂载为“只读”模式，而后通过“联合挂载 ”技术额外挂载一个“可写”层。</li></ul></li></ul></li></ul></li></ul><p><img src="/2018/12/30/docker应用基础/实现1.png" alt=""></p><ul><li>Docker Image Layer（层） <ul><li>位于下层的镜像称为父镜像(parent image)，最底层的称为基础镜像(base image) -</li><li>最上层为“可读写”层，其下的均为“只读”层</li><li>wirtable最上面的可写层并非镜像提供，而是容器提供的</li><li>建构在本地的二级文件系统<ul><li>/var/lib/docker/image/overlay2/<ul><li>distribution  imagedb  layerdb  repositories.json</li></ul></li></ul></li></ul></li></ul><p><img src="/2018/12/30/docker应用基础/实现.png" alt=""></p><h2 id="Aufs"><a href="#Aufs" class="headerlink" title="Aufs"></a>Aufs</h2><ul><li>advanced multi-layered unification filesystem：高级多层统一文件系统 <ul><li>用于为Linux文件系统实现“联合挂载” </li><li>aufs是之前的UnionFS的重新实现，2006年由Junjiro Okajima开发；  </li><li>Docker最初使用aufs作为容器文件系统层，它目前仍作为存储后端之一来支持； </li><li>aufs的竞争产品是overlayfs，后者自从3.18版本开始被合并到Linux内核； </li><li>docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs等 <ul><li>在Ubuntu系统下，docker默认Ubuntu的 aufs；而在CentOS7上，用的是devicemapper。<h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2></li></ul></li></ul></li><li>启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像 不存在时，其将从Registry中下载该镜像并保存到本地。</li></ul><p><img src="/2018/12/30/docker应用基础/b.png" alt=""></p><ul><li><p>分类 </p><ul><li>Registry用于保存docker镜像，包括镜像的层次结构和元数据 </li><li>用户可自建Registry，也可使用官方的Docker Hub <ul><li>Sponsor Registry：第三方的registry，供客户和Docker社区使用 </li><li>Mirror Registry：第三方的registry，只让客户使用 </li><li>Vendor Registry：由发布Docker镜像的供应商提供的registry </li><li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供的registry</li></ul></li></ul></li><li><p>Docker Registry中的镜像通常由开发人员制作，而后推送至“公共”或“ 私有”Registry上保存，供其他人员使用，例如“部署”到生产环境.</p></li></ul><p><img src="/2018/12/30/docker应用基础/c.png" alt=""></p><h2 id="制作docker仓库"><a href="#制作docker仓库" class="headerlink" title="制作docker仓库"></a>制作docker仓库</h2><h3 id="docker-Hub"><a href="#docker-Hub" class="headerlink" title="docker Hub"></a>docker Hub</h3><ul><li><a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li></ul><p><code>麻雀虽小五脏俱全的linux发行版--很忙的盒子</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># docker image pull busybox:latest</span></span><br><span class="line">busybox:一个微型的linux发行版（很忙的盒子）</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">busybox             latest              758ec7f3a1ee        4 days ago          1.15M</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name box1 -it busybox:latest /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin   dev   etc   home  proc  root  sys   tmp   usr   var</span><br></pre></td></tr></table></figure></p><h3 id="范例：制作镜像仓库"><a href="#范例：制作镜像仓库" class="headerlink" title="范例：制作镜像仓库"></a><code>范例：制作镜像仓库</code></h3><p>docker container commit –help<br>Usage:    docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br>Options:<br>  -a, –author string  #指定镜像的作者<br>  -c, –change list    #对底层镜像默认运行的程序 进行修改<br>  -m, –message string<br>  -p, –pause        #表示制作镜像的时候将容器暂时暂停，避免数据结构不一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########对本地很忙的盒子进行修改并推送到自己docker hub镜像仓库#######</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name box1 -it busybox:latest /bin/sh</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin   dev   etc   home  proc  root  sys   tmp   usr   var</span><br><span class="line">/ <span class="comment"># mkdir /daizhe</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin     dev     home    root    tmp     var</span><br><span class="line">daizhe  etc     proc    sys     usr</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################保存修改的镜像并打标签#######################</span></span><br><span class="line"><span class="comment">#确保容器终端不要关闭</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker container commit box1 docker19980110/mybox:v0.1</span></span><br><span class="line">sha256:42956b7e3ff8df5b77abd5b44654aac46bc00fd2ec2e690f1e92847e9879fd99</span><br><span class="line">[root@centos7 ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker19980110/mybox        v0.1                c6a32f929f07        15 seconds ago      1.15MB</span><br><span class="line"></span><br><span class="line"><span class="comment">###############本机启动测试查看保存的数据数据结构是否存在#############</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker run --name mybox -it docker19980110/mybox:v0.1 </span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin     dev     home    root    tmp     var</span><br><span class="line">daizhe  etc     proc    sys     usr</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################登陆docker hub###############################</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># docker login</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="string">'t have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: docker19980110</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span></span><br><span class="line"><span class="string">Configure a credential helper to remove this warning. See</span></span><br><span class="line"><span class="string">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Login Succeeded</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#####################将本地的镜像推送到docker hub####################</span></span><br><span class="line"><span class="string">#如果原仓库总有相同的镜像，当推送时，仅推送变化的那一层</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker image push docker19980110/mybox:v0.1 </span></span><br><span class="line"><span class="string">The push refers to repository [docker.io/docker19980110/mybox]</span></span><br><span class="line"><span class="string">5190a84cd271: Pushed </span></span><br><span class="line"><span class="string">23bc2b70b201: Mounted from library/busybox </span></span><br><span class="line"><span class="string">v0.1: digest: sha256:05ce13e43087ab6249c717c3278e9f2c8d1199310447ac806c527ee85b0dfcb8 size: 734</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/30/docker应用基础/box.png" alt=""></p><h3 id="范例：制作镜像并对底层镜像默认运行的程序-进行修改以及标签设置"><a href="#范例：制作镜像并对底层镜像默认运行的程序-进行修改以及标签设置" class="headerlink" title="范例：制作镜像并对底层镜像默认运行的程序 进行修改以及标签设置"></a><code>范例：制作镜像并对底层镜像默认运行的程序 进行修改以及标签设置</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################很忙的盒子中默认带有http程序####################</span></span><br><span class="line">/ <span class="comment"># /bin/httpd -h</span></span><br><span class="line">/bin/httpd: option requires an argument -- h</span><br><span class="line">BusyBox v1.29.3 (2018-12-24 21:25:20 UTC) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: httpd [-ifv[v]] [-c CONFFILE] [-p [IP:]PORT] [-u USER[:GRP]] [-r REALM] [-h HOME]</span><br><span class="line">or httpd -d/-e/-m STRING</span><br><span class="line"></span><br><span class="line">Listen <span class="keyword">for</span> incoming HTTP requests</span><br><span class="line"></span><br><span class="line">-iInetd mode</span><br><span class="line">-fDon<span class="string">'t daemonize</span></span><br><span class="line"><span class="string">-v[v]Verbose</span></span><br><span class="line"><span class="string">-p [IP:]PORTBind to IP:PORT (default *:80)</span></span><br><span class="line"><span class="string">-u USER[:GRP]Set uid/gid after binding to port</span></span><br><span class="line"><span class="string">-r REALMAuthentication Realm for Basic Authentication</span></span><br><span class="line"><span class="string">-h HOMEHome directory (default .)</span></span><br><span class="line"><span class="string">-c FILEConfiguration file (default &#123;/etc,HOME&#125;/httpd.conf)</span></span><br><span class="line"><span class="string">-m STRINGMD5 crypt STRING</span></span><br><span class="line"><span class="string">-e STRINGHTML encode STRING</span></span><br><span class="line"><span class="string">-d STRINGURL decode STRING</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">####################对很忙的盒子进行修改，启动默认运行httpd###########</span></span><br><span class="line"><span class="string">#保存原有的镜像</span></span><br><span class="line"><span class="string">#启动运行http</span></span><br><span class="line"><span class="string">    -f 前台运行，不适用守护进行</span></span><br><span class="line"><span class="string">    -h 执行家目录</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker container commit -p -a "daizhe&lt;daizhe.com&gt;" -c '</span>CMD [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"/bin/httpd -f -h /data/web/html"</span>]<span class="string">' mybox</span></span><br><span class="line"><span class="string">sha256:eced8dbd5d14dcb5c4be938d509103a9440cf3d7080620b49dac8fbbbe309974</span></span><br><span class="line"><span class="string">#保存的镜像未打标签</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker image ls</span></span><br><span class="line"><span class="string">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span></span><br><span class="line"><span class="string">&lt;none&gt;                 &lt;none&gt;              eced8dbd5d14        26 seconds ago      1.15MB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##########################将保存的镜像添加标签#####################</span></span><br><span class="line"><span class="string">#使用id号指定镜像来重新添加标签</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker image tag eced8dbd5d14 docker19980110/mybox:v0.2</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker image ls</span></span><br><span class="line"><span class="string">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span></span><br><span class="line"><span class="string">docker19980110/mybox   v0.2                eced8dbd5d14        6 minutes ago       1.15MB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">########################将一个镜像打多个标签######################</span></span><br><span class="line"><span class="string">#latest表示最新的意思</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker tag docker19980110/mybox:v0.2 docker19980110/mybox:latest</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker image ls</span></span><br><span class="line"><span class="string">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span></span><br><span class="line"><span class="string">docker19980110/mybox   latest              eced8dbd5d14        8 minutes ago       1.15MB</span></span><br><span class="line"><span class="string">docker19980110/mybox   v0.2                eced8dbd5d14        8 minutes ago       1.15MB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#########################再次将本地的镜像推送到docker hub仓库########</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker push docker19980110/mybox:v0.</span></span><br><span class="line"><span class="string">v0.1  v0.2  </span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker push docker19980110/mybox:v0.2 </span></span><br><span class="line"><span class="string">The push refers to repository [docker.io/docker19980110/mybox]</span></span><br><span class="line"><span class="string">355c5bc17ee9: Pushed </span></span><br><span class="line"><span class="string">5190a84cd271: Layer already exists </span></span><br><span class="line"><span class="string">23bc2b70b201: Layer already exists </span></span><br><span class="line"><span class="string">v0.2: digest: sha256:ab14ea25f1fbcc40a623343dd44a76224568a0200820f1ee5b61dc81c96ca12a size: 941</span></span><br><span class="line"><span class="string">[root@centos7 ~]# docker push docker19980110/mybox:latest </span></span><br><span class="line"><span class="string">The push refers to repository [docker.io/docker19980110/mybox]</span></span><br><span class="line"><span class="string">355c5bc17ee9: Layer already exists </span></span><br><span class="line"><span class="string">5190a84cd271: Layer already exists </span></span><br><span class="line"><span class="string">23bc2b70b201: Layer already exists </span></span><br><span class="line"><span class="string">latest: digest: sha256:ab14ea25f1fbcc40a623343dd44a76224568a0200820f1ee5b61dc81c96ca12a size: 941</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker应用基础&quot;&gt;&lt;a href=&quot;#docker应用基础&quot; class=&quot;headerlink&quot; title=&quot;docker应用基础&quot;&gt;&lt;/a&gt;docker应用基础&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/30/docker应用基础/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://9527dz.top/2018/12/30/docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://9527dz.top/2018/12/30/docker基础/</id>
    <published>2018-12-30T02:19:46.250Z</published>
    <updated>2018-12-30T06:46:25.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker基础即认识docker"><a href="#docker基础即认识docker" class="headerlink" title="docker基础即认识docker"></a>docker基础即认识docker</h1><p><img src="/2018/12/30/docker基础/图标.png" alt=""><br><a id="more"></a></p><h2 id="先从认识容器开始"><a href="#先从认识容器开始" class="headerlink" title="先从认识容器开始"></a>先从认识容器开始</h2><ul><li>什么是容器？</li><li>先来看看容器较为官方的解释：<ul><li>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</li><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2></li></ul></li><li>再来看看容器较为通俗的解释：<ul><li>如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</li></ul></li><li>容器是一种基础工具；泛指任何可以用于容纳其它物品的工具，可以 部分或完全封闭，被用于容纳、储存、运输物品；物体可以被放置在 容器中，而容器则可以保护内容物； </li><li>人类使用容器的历史至少有十万年，甚至可能有数百万年的历史； </li><li>容器的类型 •<ul><li>瓶 - 指口部比腹部窄小、颈长的容器。 •</li><li>罐 - 指那些开口较大、一般为近圆筒形的器皿。</li><li>箱 - 通常是立方体或圆柱体。形状固定。 </li><li>篮 - 以条状物编织而成。 </li><li>桶 - 一种圆柱形的容器。 </li><li>袋 - 柔性材料制成的容器，形状会受内容物而变化。 </li><li>瓮 - 通常是指陶制，口小肚大的容器。 </li><li>碗 - 用来盛载食物的容器。 </li><li>柜 - 指一个由盒组成的家俱。 </li><li>鞘 - 用于装载刀刃的容器。</li></ul></li></ul><p><img src="/2018/12/30/docker基础/通俗视图.png" alt=""></p><h2 id="图解物理机、虚拟机与容器"><a href="#图解物理机、虚拟机与容器" class="headerlink" title="图解物理机、虚拟机与容器"></a>图解物理机、虚拟机与容器</h2><ul><li>关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解。</li><li>物理机</li></ul><p><img src="/2018/12/30/docker基础/物理机.png" alt=""></p><ul><li>虚拟机</li></ul><p><img src="/2018/12/30/docker基础/物理机.png" alt=""></p><ul><li>容器</li></ul><p><img src="/2018/12/30/docker基础/容器.png" alt=""></p><h2 id="再来谈谈Docker的一些概念"><a href="#再来谈谈Docker的一些概念" class="headerlink" title="再来谈谈Docker的一些概念"></a>再来谈谈Docker的一些概念</h2><ul><li><p>通过上面这三张抽象图，我们大概可以通过类比概括出： 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p></li><li><p>相信通过上面的解释大家对于容器这个既陌生又熟悉的概念有了一个初步的认识，下面我们就来谈谈Docker的一些概念。</p></li></ul><p><img src="/2018/12/30/docker基础/docker概念.png" alt=""></p><ul><li>什么是Docker<ul><li>关于Docker是什么并太好说，下面我通过四点向你说明Docker到底是个什么东西。</li><li>Docker是世界领先的软件容器平台。</li><li>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于LXC。</li><li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li><li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li></ul></li></ul><p><img src="/2018/12/30/docker基础/docker代码.png" alt=""></p><ul><li><p>Docker思想</p><ul><li>集装箱</li><li>标准化： ①运输方式、②存储方式、 ③API接口</li><li>隔离</li></ul></li><li><p>Docker容器的特点</p><ul><li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul></li><li><p>为什么要用Docker</p><ul><li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li><li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li><li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li><li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li><li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li><li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署。</li></ul></li></ul><h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><ul><li>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</li><li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/2018/12/30/docker基础/容器VS虚拟机.png" alt=""></li></ul><h2 id="容器与虚拟机-VM-总结"><a href="#容器与虚拟机-VM-总结" class="headerlink" title="容器与虚拟机 (VM) 总结"></a>容器与虚拟机 (VM) 总结</h2><p><img src="/2018/12/30/docker基础/容器与虚拟机总结.png" alt=""></p><ul><li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。</li><li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li></ul><h2 id="容器与虚拟机（VM）两者是可以共存的"><a href="#容器与虚拟机（VM）两者是可以共存的" class="headerlink" title="容器与虚拟机（VM）两者是可以共存的"></a>容器与虚拟机（VM）两者是可以共存的</h2><p><img src="/2018/12/30/docker基础/共存.png" alt=""></p><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><ul><li>Docker包括三个基本概念：<ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul></li></ul><p><img src="/2018/12/30/docker基础/docker实现方式.png" alt=""><br><img src="/2018/12/30/docker基础/实现.png" alt=""></p><ul><li>镜像（Image）——一个特殊的文件系统<ul><li>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</li><li>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li><li>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。</li><li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li><li>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li></ul></li><li>容器（Container）——镜像运行时的实体<ul><li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</li><li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li><li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li><li>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul></li><li><p>仓库（Repository）——集中存放镜像文件的地方</p><ul><li><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p></li><li><p>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p></li><li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</li></ul></li><li><p>Docker Registry公开服务和私有Docker Registry的概念：</p><ul><li><p>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p></li><li><p>最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。</p></li><li><p>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker基础即认识docker&quot;&gt;&lt;a href=&quot;#docker基础即认识docker&quot; class=&quot;headerlink&quot; title=&quot;docker基础即认识docker&quot;&gt;&lt;/a&gt;docker基础即认识docker&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/30/docker基础/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://9527dz.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://9527dz.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>redis集群</title>
    <link href="https://9527dz.top/2018/12/28/redis%E7%BC%93%E5%AD%982/"/>
    <id>https://9527dz.top/2018/12/28/redis缓存2/</id>
    <published>2018-12-28T11:49:23.463Z</published>
    <updated>2018-12-29T13:42:52.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis集群、架构"><a href="#redis集群、架构" class="headerlink" title="redis集群、架构"></a>redis集群、架构</h1><p><img src="/2018/12/28/redis缓存2/图标.png" alt=""><br><a id="more"></a></p><h2 id="一：-redis-集群"><a href="#一：-redis-集群" class="headerlink" title="一： redis 集群"></a>一： redis 集群</h2><ul><li>上一个步骤的主从架构无法实现master和slave角色的自动切换，即当master出现redis服务异常、主机断电、磁盘损坏等问题导致master无法使用，而redis高可用无法实现自故障转移(将slave提升为master)，需要手动改环境配置才能切换到slave redis服务器，另外也无法横向扩展Redis服务的并行写入性能，当单台Redis服务器性能无法满足业务写入需求的时候就必须需要一种方式解决以上的两个核心问题，即：1.master和slave角色的无缝切换，让业务无感知从而不影响业务使用 2.可以横向动态扩展Redis服务器，从而实现多台服务器并行写入以实现更高并发的目的。</li><li><p>Redis 集群实现方式：客户端分片  代理分片  Redis Cluster（做集群一般使用奇数台服务器做集群，3、5、7,损坏的节点剩余要大于总节点的一半）</p></li><li><p>Sentinel(哨兵)：测试主从是否正常通讯：ping GONG(集群实现的前提是要使主从的版本相同)</p><ul><li>Sentinel 进程是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。一般在生产环境也建议使用Redis的2.8版本的以后版本。哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行多个哨兵(sentinel) 进程，这些进程使用流言协议(gossipprotocols)来接收关于Master主服务器是否下线的信息，并使用投票协议(Agreement Protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。每个哨兵(Sentinel)进程会向其它哨兵(Sentinel)、Master、Slave定时发送消息，以确认对方是否”活”着，如果发现对方在指定配置时间(可配置的)内未得到回应，则暂时认为对方已掉线，也就是所谓的”主观认为宕机” ，英文名称：Subjective Down，简称SDOWN。有主观宕机，肯定就有客观宕机。当“哨兵群”中的多数Sentinel进程在对Master主服务器做出 SDOWN 的判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，这种方式就是“客观宕机”，英文名称是：Objectively Down， 简称 ODOWN。通过一定的vote算法，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。<br>Sentinel 机制可以解决master和slave角色的切换问题。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sentinel(哨兵)：哨兵判断服务器是否存活的方式</span><br><span class="line">  [root@centos7 redis]<span class="comment"># redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line">  127.0.0.1:6379&gt; ping</span><br><span class="line">  PONG</span><br></pre></td></tr></table></figure><p><img src="/2018/12/28/redis缓存2/redis缓存/哨兵架构.png" alt=""></p><h3 id="实现哨兵默认端口26379"><a href="#实现哨兵默认端口26379" class="headerlink" title="实现哨兵默认端口26379"></a><code>实现哨兵默认端口26379</code></h3><p>(在生产中建议哨兵是一台独立的服务器，这里演示的时redis服务器上实现哨兵，哨兵判断节点的存活状态机制：ping :pang)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">实验准备：</span><br><span class="line">  三台主机：全部编译安装，为了避免实验出现差别，尽量使用相同版本</span><br><span class="line"></span><br><span class="line">  主节点：172.18.135.1</span><br><span class="line">  从节点1：172.18.135.2</span><br><span class="line">  从节点2：172.18.135.3</span><br><span class="line"></span><br><span class="line">实验目的如果主节点挂了，自动其中一个从节点上选择一个自动升级为主节点</span><br><span class="line"></span><br><span class="line">第一步：</span><br><span class="line">编辑所有主机的配置文件</span><br><span class="line">  修改本机的监听地址</span><br><span class="line">  76行</span><br><span class="line">  <span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">  修改主从结构的配置</span><br><span class="line">  286  replicaof 192.168.7.103 6379</span><br><span class="line">  293  masterauth 123456 <span class="comment">#master如果密码需要设置</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># systemctl restart redis.service </span></span><br><span class="line"></span><br><span class="line">第二步：</span><br><span class="line">首先实现一主两从架构</span><br><span class="line">  从节点1：</span><br><span class="line">  127.0.0.1:6379&gt; info [</span><br><span class="line">  <span class="comment"># Replication</span></span><br><span class="line">  role:slave</span><br><span class="line">  master_host:172.18.135.1</span><br><span class="line">  master_port:6379</span><br><span class="line">  master_link_status:up</span><br><span class="line"></span><br><span class="line">  从节点2：</span><br><span class="line">  127.0.0.1:6379&gt; info [</span><br><span class="line">  <span class="comment"># Replication</span></span><br><span class="line">  role:slave</span><br><span class="line">  master_host:172.18.135.1</span><br><span class="line">  master_port:6379</span><br><span class="line">  master_link_status:up</span><br><span class="line"></span><br><span class="line">第三步：哨兵可以不和Redis服务器部署在一起</span><br><span class="line">配置哨兵：编辑配置文件sentinel.conf：</span><br><span class="line"></span><br><span class="line">  master 、slave1、slave2 配置：</span><br><span class="line">  [root@centos7 ~]<span class="comment"># cp /usr/local/src/redis-5.0.3/sentinel.conf /usr/local/redis/etc</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># vim /usr/local/redis/etc/sentinel.conf</span></span><br><span class="line">  port 26379</span><br><span class="line">  daemonize yes</span><br><span class="line">  pidfile /usr/<span class="built_in">local</span>/redis/data/redis-sentinel_26379.pid</span><br><span class="line">  logfile <span class="string">"/usr/local/redis/logs/sentinel_26379.log"</span></span><br><span class="line">  dir /usr/<span class="built_in">local</span>/redis/data</span><br><span class="line">  sentinel monitor mymaster 172.18.131.1 6379 2   </span><br><span class="line">  sentinel auth-pass mymaster 123456</span><br><span class="line">  sentinel down-after-milliseconds mymaster 15000   <span class="comment">#15秒</span></span><br><span class="line">  sentinel parallel-syncs mymaster 1</span><br><span class="line">  sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">第四步：启动哨兵</span><br><span class="line"></span><br><span class="line">  每个节点上都启动哨兵</span><br><span class="line">  [root@centos7 ~]<span class="comment"># /usr/local/redis/bin/redis-sentinel  /usr/local/redis/etc/sentinel.conf</span></span><br><span class="line">  [root@centos7 etc]<span class="comment"># ss -tnl       </span></span><br><span class="line">  LISTEN     0      511            *:26379       </span><br><span class="line">  查看哨兵的日志文件</span><br><span class="line"></span><br><span class="line">第五步：哨兵验证</span><br><span class="line">  [root@centos7 ~]<span class="comment"># redis-cli -p 26379</span></span><br><span class="line">  127.0.0.1:26379&gt; info Sentinel</span><br><span class="line">  <span class="comment"># Sentinel</span></span><br><span class="line">  sentinel_masters:1</span><br><span class="line">  sentinel_tilt:0</span><br><span class="line">  sentinel_running_scripts:0</span><br><span class="line">  sentinel_scripts_queue_length:0</span><br><span class="line">  sentinel_simulate_failure_flags:0</span><br><span class="line">  master0:name=mymaster,status=ok,address=172.18.135.1:6379,slaves=2,sentinels=3</span><br><span class="line"></span><br><span class="line">已经实现哨兵</span><br><span class="line">  可以创建值，并停用主节点，哨兵自动选举新的主节点</span><br></pre></td></tr></table></figure></p><p><code>哨兵配置文件详情</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-s1 etc]<span class="comment"># grep "^[a-Z]" /usr/local/redis/etc/sentinel.conf </span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">port 26379</span><br><span class="line">daemonize yes   <span class="comment">#守护进程运行</span></span><br><span class="line">pidfile <span class="string">"/usr/local/redis/redis-sentinel.pid"</span></span><br><span class="line">logfile <span class="string">"/usr/local/redis/sentinel_26379.log"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis"</span>   <span class="comment"># 哨兵运行产生的数据目录</span></span><br><span class="line">sentinel monitor mymaster 192.168.7.101 6379 2<span class="comment">#这里的2表示，多少个哨兵决定主节点挂掉则提升新的主,此实验的哨兵有三个</span></span><br><span class="line">sentinel auth-pass mymaster 123456  <span class="comment">#主节点的密码，为了安全建议添加密码</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000  <span class="comment">#(SDOWN)主观下线的时间，主节点多长时间没有反应则代表下线，根据生产需求设置</span></span><br><span class="line">sentinel parallel-syncs mymaster 1 <span class="comment">#发生故障转移时候同时向新master同步数据的slave数量，数字越小总同步时间越长</span></span><br><span class="line">sentinel failover-timeout mymaster 180000  <span class="comment">#所有slaves指向新的master所需的超时时间（单位秒）</span></span><br><span class="line">sentinel deny-scripts-reconfig yes  <span class="comment">#代表没有调用其他脚本</span></span><br></pre></td></tr></table></figure></p><ul><li>应用程序如何连接redis？：<ul><li>java客户端连接redis是通过jedis来实现的，java代码用的时候只要创建jedis对象就可以建多个jedis连接池来连接redis，应用程序再直接调用连接池即可连接Redis。</li><li>而Redis为了保障高可用,服务一般都是Sentinel部署方式，当Redis服务中的主服务挂掉之后,会仲裁出另外一台Slaves服务充当Master。这个时候,我们的应用即使使用了Jedis连接池,Master服务挂了,我们的应用奖还是无法连接新的Master服务，为了解决这个问题,Jedis也提供了相应的Sentinel实现,能够在Redis Sentinel主从切换时候,通知我们的应用,把我们的应用连接到新的Master服务。</li><li>Jedis Sentinel的使用也是十分简单的,只是在JedisPool中添加了Sentinel和MasterName参数，Jedis Sentinel底层基于Redis订阅实现Redis主从服务的切换通知，当Reids发生主从切换时，Sentinel会发送通知主动通知Jedis进行连接的切换，JedisSentinelPool在每次从连接池中获取链接对象的时候,都要对连接对象进行检测,如果此链接和Sentinel的Master服务连接参数不一致,则会关闭此连接,重新获取新的Jedis连接对象。 </li></ul></li></ul><h2 id="二：-Redis-Cluster部署"><a href="#二：-Redis-Cluster部署" class="headerlink" title="二： Redis Cluster部署"></a>二： Redis Cluster部署</h2><ul><li><p><code>Redis cluster之前的分布式方案：</code></p><ul><li>1) 客户端分区：由客户端程序决定key写分配和写入的redis node，但是需要客户端自己处理写入分配、高可用管理和故障转移等</li><li>2)代理方案：基于三方软件实现redis proxy，客户端先连接之代理层，由代理层实现key的写入分配，对客户端来说是有比较简单，但是对于集群管节点增减相对比较麻烦，而且代理本身也是单点和性能瓶颈。</li></ul></li><li><p>在哨兵sentinel机制中，可以解决redis高可用的问题，即当master故障后可以自动将slave提升为master从而可以保证redis服务的正常使用，但是无法解决redis单机写入的瓶颈问题，即单机的redis写入性能受限于单机的内存大小、并发数量、网卡速率等因素，因此redis官方在redis 3.0版本之后推出了无中心架构的redis cluster机制，在无中心的redis集群汇中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接，特点如下：</p><ul><li>1：所有Redis节点使用(PING-PING机制)互联</li><li>2：集群中某个节点的实效是整个集群中超过半数的节点监测都实效才算真正的实效</li><li>3：客户端不需要proxy即可直接连接redis，且客户端不需要连接集群中的所有节点，只要连接集群中的任何一个节点即可。</li><li>4：redis cluster把所有的redisnode映射到 0-16383个槽位(slot)上，读写需要到指定的redis node上进行操作，因此有多少个reids node相当于redis 并发扩展了多少倍。</li><li>5：Redis集群预先分配16384个(slot)槽位，当需要在redis集群中写入一个key -value的时候，会使用CRC16(key)  mod 16384之后的值，决定将key写入值哪一个槽位从而决定写入哪一个Redis节点上，从而有效解决单机瓶颈。</li></ul></li></ul><p><code>Redis cluster基本架构</code></p><ul><li>假如三个主节点分别是：A, B, C 三个节点，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：<ul><li>节点A覆盖0－5460</li><li>节点B覆盖5461－10922</li><li>节点C覆盖10923－16383</li></ul></li><li>此结构缺点是主节点之间无法数据同步</li></ul><p><img src="/2018/12/28/redis缓存2/图.png" alt=""></p><p><code>Redis cluster主从架构：</code></p><ul><li>Redis cluster的架构虽然解决了并发的问题，但是又引入了一个新的问题，每个Redis master的高可用如何解决？</li></ul><p><img src="/2018/12/28/redis缓存2/图2.png" alt=""></p><h3 id="部署redis集群："><a href="#部署redis集群：" class="headerlink" title="部署redis集群："></a><code>部署redis集群：</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####################环境准备####################</span></span><br><span class="line"></span><br><span class="line">三台服务器，每台服务器启动6379和6380两个redis 服务，生产环境建议直接6台服务器。</span><br><span class="line">另外预留一台服务器做集群添加节点测试。</span><br><span class="line"></span><br><span class="line">实验方式：基于端口的不同实现（生产环境中最好使用6台主机实现）</span><br><span class="line">172.18.135.1:6379/6380  172.18.135.5:6379/6380</span><br><span class="line">172.18.135.2:6379/6380  </span><br><span class="line"></span><br><span class="line"><span class="comment">##############创建redis cluster集群的前提####目前仅有三台节点####</span></span><br><span class="line">1.每个redis node节点采用相同的硬件配置、相同的密码</span><br><span class="line">2.每个节点必须开启参数(确保每台节点都是主节点) <span class="comment">#编辑配置文件</span></span><br><span class="line">507 requirepass 123456  <span class="comment"># 建议每个节点都设置密码，但是保证每个节点的密码保持一致</span></span><br><span class="line">838 cluster-enabled yes <span class="comment">#必须开启集群状态，开启后redis 进程会有cluster显示</span></span><br><span class="line">846 cluster-config-file nodes-6380.conf <span class="comment">#此文件有redis cluster集群自动创建和维护，不需要任何手动操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################模拟一台节点上创建第二个节点###################</span></span><br><span class="line">每台节点上模拟创建第二台节点实现一台机器上两个节点</span><br><span class="line">[root@centos77 ~]<span class="comment"># cp /usr/local/redis/etc/redis.conf /usr/local/redis/etc/redis6380.conf </span></span><br><span class="line"><span class="comment">#对原配置文件拷贝进行简单修改</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">port 6380</span><br><span class="line">pidfile <span class="string">"/var/run/redis_6380.pid"</span></span><br><span class="line">logfile <span class="string">"/usr/local/redis/logs/6380.log"</span></span><br><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line"></span><br><span class="line">创建启动脚本</span><br><span class="line">[root@centos77 ~]<span class="comment"># cp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis6380.service</span></span><br><span class="line">[root@centos77 ~]<span class="comment"># vim !$</span></span><br><span class="line">vim /usr/lib/systemd/system/redis6380</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/etc/redis6380.conf  --supervised systemd</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment">######################## 启动############################</span></span><br><span class="line">[root@centos77 etc]<span class="comment"># scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/</span></span><br><span class="line">[root@centos77 etc]<span class="comment"># scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/</span></span><br><span class="line"></span><br><span class="line">[root@centos77 etc]<span class="comment"># scp /usr/local/redis/etc/redis6380.conf root@172.18.135.1:/usr/local/redis/etc/</span></span><br><span class="line">[root@centos77 etc]<span class="comment"># scp /usr/local/redis/etc/redis6380.conf root@172.18.135.2:/usr/local/redis/etc/</span></span><br><span class="line">[root@centos77 ~]<span class="comment"># scp /usr/lib/systemd/system/redis6380.service root@172.18.135.2:/usr/lib/systemd/system/</span></span><br><span class="line">[root@centos77 ~]<span class="comment"># scp /usr/lib/systemd/system/redis6380.service root@172.18.135.1:/usr/lib/systemd/system/</span></span><br><span class="line"></span><br><span class="line">启动查看端口</span><br><span class="line">[root@centos77 etc]<span class="comment"># ss -tnl          </span></span><br><span class="line">6379                                       </span><br><span class="line">6380</span><br></pre></td></tr></table></figure><p><img src="/2018/12/28/redis缓存2/创建集群的前提.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################创建集群#####################</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456  --cluster create 192.168.7.101:6379   192.168.7.101:6380    192.168.7.102:6379   192.168.7.102:6380   192.168.7.103:6379   192.168.7.103:6380  --cluster-replicas 1 </span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.7.102:6380 to 192.168.7.101:6379</span><br><span class="line">Adding replica 192.168.7.101:6380 to 192.168.7.102:6379</span><br><span class="line">Adding replica 192.168.7.103:6380 to 192.168.7.103:6379</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[OK] Perfect anti-affinity obtained!</span><br><span class="line">M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 <span class="comment">#带M的为master</span></span><br><span class="line">   slots:[0-5460] (5461 slots) master  <span class="comment">#当前master的槽位起始和结束位</span></span><br><span class="line">S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380 <span class="comment">#带S的slave</span></span><br><span class="line">   replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master <span class="comment">#当前master的槽位起始和结束位</span></span><br><span class="line">S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380</span><br><span class="line">   replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master <span class="comment">#当前master的槽位起始和结束位</span></span><br><span class="line">S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380</span><br><span class="line">   replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes <span class="comment">#输入yes自动创建集群</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">.....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.101:6379)</span><br><span class="line">M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379 <span class="comment">#master的ID及端口</span></span><br><span class="line">   slots:[0-5460] (5461 slots) master <span class="comment">#已经分配的槽位</span></span><br><span class="line">   1 additional replica(s) <span class="comment">#分配了一个slave</span></span><br><span class="line">S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380</span><br><span class="line">   slots: (0 slots) slave <span class="comment">#slave没有分配槽位</span></span><br><span class="line">   replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">[OK] All nodes agree about slots configuration. <span class="comment">#所有节点槽位分配完成</span></span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots... <span class="comment">#检查打开的槽位</span></span><br><span class="line">&gt;&gt;&gt; Check slots coverage... <span class="comment">#检查插槽覆盖范围</span></span><br><span class="line">[OK] All 16384 slots covered. <span class="comment">#所有槽位(16384个)分配完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################检查状态######################</span></span><br><span class="line">由于未设置masterauth认证密码，所以主从未建立起来，但是集群已经运行，所以需要在每个slave控制台使用config <span class="built_in">set</span>设置masterauth密码，或者写在每个redis配置文件中，最好是在控制点设置密码之后再写入配置文件当中。</span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/状态检查.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################分别设置masterauth密码#############</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.101  -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.101:6380&gt;  CONFIG SET  masterauth 123456</span><br><span class="line">OK</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.102  -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.102:6380&gt; CONFIG SET  masterauth 123456</span><br><span class="line">OK</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.103  -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.103:6380&gt; CONFIG SET  masterauth 123456</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################确认slave状态为up##################</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/确认状态.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################验证master状态###################</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.101  -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.101:6379&gt; INFO Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.7.102,port=6380,state=online,offset=840,lag=0</span><br><span class="line">master_replid:0aa3281030eb29bf268f3317d4afe401f661a917</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:840</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:4026531840</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:840</span><br><span class="line">192.168.7.101:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">###################管理要用集群的命令管理##############</span></span><br><span class="line"><span class="comment">#########################验证集群状态#################</span></span><br><span class="line">192.168.7.101:6379&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:1474</span><br><span class="line">cluster_stats_messages_pong_sent:1507</span><br><span class="line">cluster_stats_messages_sent:2981</span><br><span class="line">cluster_stats_messages_ping_received:1502</span><br><span class="line">cluster_stats_messages_pong_received:1474</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:2981</span><br><span class="line"></span><br><span class="line"><span class="comment">########################查看集群node对应关系################</span></span><br><span class="line">使用命令cluster nodes：</span><br><span class="line">192.168.7.103:6380&gt; cluster nodes</span><br><span class="line">7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545659135000 4 connected</span><br><span class="line">7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 myself,slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545659135000 6 conne</span><br><span class="line">ctedf4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545659135000 1 connected 0-5460</span><br><span class="line">116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545659136000 3 connected 5461-10922</span><br><span class="line">70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545659134000 5 connected 10923-16383</span><br><span class="line">2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545659135946 5 connected</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################验证集群写入key##################</span></span><br><span class="line">192.168.7.101:6379&gt; SET key1  value1  <span class="comment">#经过算法计算，当前key的槽位需要写入指定的node </span></span><br><span class="line">(error) MOVED 9189 192.168.7.102:6379 <span class="comment">#槽位不在当前node所以无法写入</span></span><br><span class="line">192.168.7.103:6379&gt; SET key1  value1  </span><br><span class="line">(error) MOVED 9189 192.168.7.102:6379  </span><br><span class="line">192.168.7.102:6379&gt; SET key1  value1 <span class="comment">#指定的node就可以写入</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.102:6379&gt; KEYS *</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line"></span><br><span class="line">192.168.7.101:6379&gt; KEYS *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">192.168.7.103:6379&gt; KEYS *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################集群状态监控###################</span></span><br><span class="line"><span class="comment"># redis-cli -a 123456  --cluster check 192.168.7.101:6379</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/集群状态监控.png" alt=""></p><h3 id="Redis-cluster集群节点维护"><a href="#Redis-cluster集群节点维护" class="headerlink" title="Redis cluster集群节点维护"></a><code>Redis cluster集群节点维护</code></h3><ul><li><p>集群运行时间长久之后，难免由于硬件故障、网络规划、业务增长等原因对已有集群进行相应的调整， 比如增加Redis node节点、减少节点、节点迁移、更换服务器等。<br>增加节点和删除节点会涉及到已有的槽位重新分配及数据迁移。</p></li><li><p>集群维护之动态添加节点：</p><ul><li>增加Redis node节点，需要与之前的Redis node版本相同、配置一致，然后分别启动两台Redis node，因为一主一从。</li></ul></li><li>案例：<ul><li>因公司业务发展迅猛，现有的三主三从redis cluster架构可能无法满足现有业务的并发写入需求，因此公司紧急采购一台服务器192.168.7.104，需要将其动态添加到集群当中其不能影响业务使用和数据丢失，则添加过程如下:</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">为了满足生产需求创建新的服务器</span><br><span class="line"><span class="comment">##同步之前Redis node的配置文件到192.168.7.104 Redis编译安装目录，注意配置文件的监听 IP##</span></span><br><span class="line">scp redis.conf  192.168.7.104:/usr/<span class="built_in">local</span>/redis/etc/</span><br><span class="line">scp redis_6380.conf  192.168.7.104:/usr/<span class="built_in">local</span>/redis/etc/</span><br><span class="line"></span><br><span class="line"><span class="comment">##################分别启动redis服务##########################</span></span><br><span class="line">systemctl  daemon-reload</span><br><span class="line">systemctl  restart redis</span><br><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/etc/redis_6380.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">################将新创建的新的服务器添加节点到集群############</span></span><br><span class="line">在新创建的节点上配置（新加入的节点是没有槽位的）</span><br><span class="line">要添加的redis节点IP和端口    添加到的集群中的master IP:端口</span><br><span class="line"><span class="comment"># redis-cli -a 123456 --cluster add-node     192.168.7.104:6379           192.168.7.101:6379</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/28/redis缓存2/加入.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############################分配槽位######################</span></span><br><span class="line">添加主机之后需要对添加至集群种的新主机重新分片否则其没有分片</span><br><span class="line">在新创建的节点上配置（分配的槽位是从以前每个节点上瓜分槽位来给新加入的服务器）</span><br><span class="line">使用命令重新分配槽位:</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456 --cluster reshard  192.168.7.104:6379</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456 --cluster reshard  192.168.7.104:6379 </span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.104:6379)</span><br><span class="line">M: 886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 4096 <span class="comment">#分配多少个槽位192.168.7.104:6379</span></span><br><span class="line">What is the receiving node ID? 886338acd50c3015be68a760502b239f4509881c <span class="comment">#手动输入192.168.7.104的node ID</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: all #将哪些源主机的槽位分配给192.168.7.104:6379，all是自动在所有的redis node选择划分，如果是从redis cluster删除主机可以使用此方式将主机上的槽位全部移动到别的redis主机</span></span><br><span class="line">………………………………..</span><br><span class="line">    Moving slot 6823 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">    Moving slot 6824 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">    Moving slot 6825 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">    Moving slot 6826 from 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">    Moving slot 10923 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">    Moving slot 10924 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">    Moving slot 10925 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">    Moving slot 10926 from 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">…………………………………..</span><br><span class="line">    Moving slot 1364 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)?  yes <span class="comment">#确认分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################验证重新分配槽位之后的集群状态#############</span></span><br><span class="line">重新分配槽位是自动从每个Redis node上移动一些槽位到新的master上</span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/验证.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################为新的master添加slave节点###############</span></span><br><span class="line"><span class="comment">#master节点必须有salvae一但挂掉损失惨重</span></span><br><span class="line">命令格式：(这样加入的192.168.7.104:6380 默认为master)</span><br><span class="line"><span class="comment"># redis-cli -a 123456 --cluster add-node 192.168.7.104:6380 192.168.7.104:6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###################更改新节点更改状态为slave###############</span></span><br><span class="line">需要手动将其指定为某个master 的slave，否则其默认角色为master</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.104 -p 6380 -a 123456 #登录到新添加节点</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.104:6380&gt;  CLUSTER NODES <span class="comment">#查看当前集群节点，找到目标master 的ID</span></span><br><span class="line">7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545700464964 3 connected</span><br><span class="line">116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545700470516 3 connected 6827-10922</span><br><span class="line">2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545700468498 5 connected</span><br><span class="line">b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 myself,master - 0 1545700464000 0 connected</span><br><span class="line">886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 master - 0 1545700465468 7 connected 0-1364 5461-6826 10923-12287</span><br><span class="line">70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545700467489 5 connected 12288-16383</span><br><span class="line">f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545700464461 1 connected 1365-5460</span><br><span class="line">7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545700469508 1 connected</span><br><span class="line">192.168.7.104:6380&gt; CLUSTER  REPLICATE 886338acd50c3015be68a760502b239f4509881c <span class="comment">#将其设置slave，设置为192.168.7.104:6379的slave </span></span><br><span class="line"><span class="comment">#命令格式为cluster replicate MASTERID</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6380&gt; CLUSTER NODES <span class="comment">#再次查看集群节点状态，验证节点是否已经更改为指定master 的slave</span></span><br><span class="line">7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545700517970 3 connected</span><br><span class="line">116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545700514942 3 connected 6827-10922</span><br><span class="line">2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380@16380 slave 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 0 1545700518979 5 connected</span><br><span class="line">b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 myself,slave 886338acd50c3015be68a760502b239f4509881c 0 1545700509000 0 connected</span><br><span class="line">886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 master - 0 1545700516456 7 connected 0-1364 5461-6826 10923-12287</span><br><span class="line">70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545700519988 5 connected 12288-16383</span><br><span class="line">f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379@16379 master - 0 1545700515953 1 connected 1365-5460</span><br><span class="line">7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave f4cfc5cf821c0d855016488d6fbfb62c03a14fda 0 1545700516962 1 connected</span><br><span class="line">192.168.7.104:6380&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################验证当前集群状态########################</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/状态验证.png" alt=""></p><h3 id="集群维护之动态删除节点"><a href="#集群维护之动态删除节点" class="headerlink" title="集群维护之动态删除节点"></a><code>集群维护之动态删除节点</code></h3><ul><li>添加节点的时候是先添加node节点到集群，然后分配槽位，删除节点的操作与添加节点的操作正好相反，是先将被删除的Redis node上的槽位迁移到集群中的其他Redis node节点上，然后再将其删除。<br>如果一个Redis node节点上的槽位没有被完全迁移，删除该node的时候会提升有数据且无法删除。</li><li>案例：<ul><li>由于192.168.7.101服务器使用年限已经超过三年，已经超过厂商质保期而且硬盘出现异常报警，经运维部架构师提交方案并同开发同事开会商议，决定将现有Redis集群的4台服务器分别是192.168.7.101/192.168.7.102/192.168.7.103/192.168.7.104中的192.168.7.101临时下线，三台服务器的并发写入性能足够支出未来1-2年的业务需求，则删除Redis node 192.168.7.101的操作如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##############迁移master 的槽位之其他master##################</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456  --cluster reshard  192.168.7.102:6379</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.102:6379)</span><br><span class="line">M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">S: b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 886338acd50c3015be68a760502b239f4509881c</span><br><span class="line">S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 4096 <span class="comment">#迁移master上的多少个槽位</span></span><br><span class="line">What is the receiving node ID? 886338acd50c3015be68a760502b239f4509881c <span class="comment">#接收槽位的服务器ID</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: f4cfc5cf821c0d855016488d6fbfb62c03a14fda #从哪个服务器迁移4096个槽位</span></span><br><span class="line">Source node <span class="comment">#2: done #写done，表示没有其他master了</span></span><br><span class="line">    Moving slot 5457 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5458 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5459 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5460 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes <span class="comment">#是否继续</span></span><br><span class="line"></span><br><span class="line">迁移完成！</span><br><span class="line"></span><br><span class="line"><span class="comment">######################验证槽位迁移完成########################</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2018/12/28/redis缓存2/验证槽位是否迁移完成.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####################从集群删除服务器##########################</span></span><br><span class="line">虽然槽位已经迁移完成，但是服务器IP信息还在集群当中，因此还需要将IP信息从集群删除</span><br><span class="line">命令格式： redis-cli -a 123456  --cluster  del-node   IP:Port ID</span><br><span class="line"><span class="comment">#删除master：</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456 --cluster del-node 192.168.7.101:6379 f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Removing node f4cfc5cf821c0d855016488d6fbfb62c03a14fda from cluster 192.168.7.101:6379</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除slave：</span></span><br><span class="line">该节点上如果还有其他节点上master 的slave，但是由于服务器下架也要一并删除，因此要提前把保证每个master至少有一个slave。</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456 --cluster del-node 192.168.7.101:6380 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Removing node 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 from cluster 192.168.7.101:6380</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br><span class="line"></span><br><span class="line"><span class="comment">####################验证node 是否删除######################</span></span><br><span class="line">发现192.168.7.101已经被删除，但是由于192.168.7.101:6380之前是192.168.7.103:6379的slave，所以删除后会导致相应的master缺少slave，需要重新为没有slave的master分配slave。</span><br><span class="line">可以发现下图的192.168.7.104有两个slave，分别是192.168.7.102:6380和192.168.7.104:6380，因此需要将其中一个slave转移为192.168.7.103的slave。</span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/node.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####################重新分配slave#########################</span></span><br><span class="line">将192.168.7.104:6380 转移为192.168.7.103的slave</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.104 -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.104:6379&gt;  CLUSTER NODES</span><br><span class="line">116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379@16379 master - 0 1545708439000 3 connected 6827-10922</span><br><span class="line">b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380@16380 slave 886338acd50c3015be68a760502b239f4509881c 0 1545708440717 7 connected</span><br><span class="line">7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380@16380 slave 886338acd50c3015be68a760502b239f4509881c 0 1545708437682 7 connected</span><br><span class="line">886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379@16379 myself,master - 0 1545708439000 7 connected 0-6826 10923-12287</span><br><span class="line">70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379@16379 master - 0 1545708440000 5 connected 12288-16383</span><br><span class="line">7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380@16380 slave 116c4c6de036fdbac5aaad25eb1a61ea262b64af 0 1545708438697 3 connected</span><br><span class="line">192.168.7.104:6380&gt; CLUSTER REPLICATE 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">##################验证集群Master与Slave对应关系#################</span></span><br><span class="line">Redis Slave节点一定不能个master在一个服务器，必须为跨主机交叉备份模式，避免主机故障后主备全部挂掉，如果出现Redis Slave与Redis master在同一台Redis node的情况，则需要安装以上步骤重新进行slave分配，直到不相互交叉备份为止。</span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/再次验证.png" alt=""></p><h3 id="集群维护之模拟Master宕机"><a href="#集群维护之模拟Master宕机" class="headerlink" title="集群维护之模拟Master宕机"></a><code>集群维护之模拟Master宕机</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">目前的架构为三主三从，互为跨主机master slave模式。</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################测试数据写入###########################</span></span><br><span class="line">测试在master写入数据，并在其对应的slave验证数据：</span><br><span class="line">192.168.7.102:6379&gt; SET key1 value1</span><br><span class="line">OK</span><br><span class="line">192.168.7.102:6379&gt; get key1</span><br><span class="line"><span class="string">"value1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################slave验证数据########################</span></span><br><span class="line">192.168.7.103:6380&gt; KEYS *</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line">192.168.7.103:6380&gt; get key1</span><br><span class="line">(error) MOVED 9189 192.168.7.102:6379 <span class="comment">#slave不提供读写，只提供数据备份即master选举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################停止master并验证故障转移################</span></span><br><span class="line">Redis Master服务停止之后，其对应的slave会被选举为master继续处理数据的读写操作。</span><br><span class="line"><span class="comment"># systemctl  stop  redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################验证slave 日志#######################</span></span><br><span class="line"><span class="comment"># tail -f /usr/local/redis/redis_6380.log</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/28/redis缓存2/slave日志.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####################验证slave状态########################</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/slave状态.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################验证数据读写#########################</span></span><br><span class="line">确认slave 192.168.7.103:6380切换为master之后可以继续为业务提供读写业务且数据没有丢失。</span><br><span class="line">192.168.7.103:6380&gt; KEYS *</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line">192.168.7.103:6380&gt; SET aaa bbb</span><br><span class="line">OK</span><br><span class="line">192.168.7.103:6380&gt; get key1</span><br><span class="line"><span class="string">"value1"</span></span><br><span class="line">192.168.7.103:6380&gt; get aaa</span><br><span class="line"><span class="string">"bbb"</span></span><br><span class="line">192.168.7.103:6380&gt;</span><br><span class="line">注：服务恢复之后重新验证各master的slave。</span><br></pre></td></tr></table></figure></p><h3 id="集群维护之导入现有Redis数据"><a href="#集群维护之导入现有Redis数据" class="headerlink" title="集群维护之导入现有Redis数据"></a><code>集群维护之导入现有Redis数据</code></h3><ul><li>导入数据需要redis cluster不能与被导入的数据有重复的key名称，否则导入不成功或中断。</li><li>案例：<ul><li>公司将redis cluster部署完成之后，需要将之前的数据导入之Redis cluster集群，但是由于Redis cluster使用的分片保存key的机制，因此使用传统的AOF文件或RDB快照无法满足需求，因此需要使用集群数据导入命令完成。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################基础环境准备#####################</span></span><br><span class="line"></span><br><span class="line">导入数据之前需要关闭各redis 服务器的密码，包括集群中的各node和源Redis server，避免认证带来的环境不一致从而无法导入，但是可以加参数--cluster-replace 强制替换Redis cluster已有的key。</span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.102 -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.102:6379&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6379&gt; <span class="built_in">exit</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.102 -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.102:6380&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6379&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.103 -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.103:6379&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.103:6379&gt; <span class="built_in">exit</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.103 -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.103:6380&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6379&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.104 -p 6379 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.104:6379&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6379&gt; <span class="built_in">exit</span></span><br><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli  -h 192.168.7.104 -p 6380 -a 123456</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">192.168.7.104:6380&gt; CONFIG SET requirepass <span class="string">""</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.104:6379&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################执行数据导入###########################</span></span><br><span class="line">将源Redis server的数据直接导入之redis cluster。</span><br><span class="line">命令格式：<span class="comment">#redis-cli  --cluster import  集群服务器IP:PORT --cluster-from 外部Redis node-IP:PORT --cluster-copy --cluster-replace</span></span><br><span class="line">[root@redis-s2 redis]<span class="comment"># redis-cli  --cluster import  192.168.7.103:6379 --cluster-from  192.168.7.101:6379  --cluster-copy</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2018/12/28/redis缓存2/数据导入.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####################edis cluster验证数据####################</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/28/redis缓存2/数据验证.png" alt=""></p><h3 id="redis扩展集群方案"><a href="#redis扩展集群方案" class="headerlink" title="redis扩展集群方案"></a><code>redis扩展集群方案</code></h3><ul><li>除了Redis 官方自带的Redis cluster集群之外，还有一写开源的集群解决方案可供参考使用</li><li>codis：<ul><li>Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有显著区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务。</li><li>codis-proxy相当于redis，即连接codis-proxy和连接redis是没有任何区别的，codis-proxy无状态，不负责记录是否在哪保存，数据在zookeeper记录，即codis proxy向zookeeper查询key的记录位置，proxy 将请求转发到一个组进行处理，一个组里面有一个master和一个或者多个slave组成，默认有1024个槽位，redis cluster 默认有16384个槽位，其把不同的槽位的内容放在不同的group。</li></ul></li><li>Github 地址：<a href="https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md" target="_blank" rel="noopener">https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md</a> </li></ul><p><img src="/2018/12/28/redis缓存2/codis.png" alt=""></p><h3 id="twemproxy"><a href="#twemproxy" class="headerlink" title="twemproxy"></a><code>twemproxy</code></h3><ul><li>由Twemproxy代替客户端实现分片，即代替用户将数据分片并到不同的后端服务器进行读写，其还支持memcached，可以为proxy配置算法，缺点为twemproxy是瓶颈，不支持数据迁移</li><li>官方github地址<a href="https://github.com/twitter/twemproxy/" target="_blank" rel="noopener">https://github.com/twitter/twemproxy/</a> </li><li>Github 地址：<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a> </li></ul><p><img src="/2018/12/28/redis缓存2/twemproxy.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis集群、架构&quot;&gt;&lt;a href=&quot;#redis集群、架构&quot; class=&quot;headerlink&quot; title=&quot;redis集群、架构&quot;&gt;&lt;/a&gt;redis集群、架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/28/redis缓存2/图标.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux服务" scheme="https://9527dz.top/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="redis集群" scheme="https://9527dz.top/tags/redis%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存</title>
    <link href="https://9527dz.top/2018/12/26/redis%E7%BC%93%E5%AD%98/"/>
    <id>https://9527dz.top/2018/12/26/redis缓存/</id>
    <published>2018-12-26T12:22:34.208Z</published>
    <updated>2018-12-29T12:56:32.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis缓存及架构"><a href="#redis缓存及架构" class="headerlink" title="redis缓存及架构"></a>redis缓存及架构</h1><p><img src="/2018/12/26/redis缓存/redis标题.png" alt=""><br><a id="more"></a></p><h2 id="一：-缓存概念："><a href="#一：-缓存概念：" class="headerlink" title="一： 缓存概念："></a>一： 缓存概念：</h2><ul><li>缓存概念<ul><li>缓存是为了调节速度不一致的两个或多个不同的物质的速度，在中间对速度较快的一方起到一个加速访问速度较慢的一方的作用，比如CPU的一级、二级缓存是保存了CPU最近经常访问的数据，内存是保存CPU经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的raid 卡有也缓存，都是为了起到加速CPU 访问硬盘数据的目的，因为CPU的速度太快了，CPU需要的数据硬盘往往不能在短时间内满足CPU的需求，因此PCU缓存、内存、Raid 卡以及硬盘缓存就在一定程度上满足了CPU的数据需求，即CPU 从缓存读取数据可以大幅提高CPU的工作效率。</li></ul></li><li><p>系统缓存</p><ul><li>1.buffer与cache：<br>buffer：缓冲也叫写缓冲，一般用于写操作，可以将数据先写入内存在写入磁盘，buffer 一般用于写缓冲，用于解决不同介质的速度不一致的缓冲，先将数据临时写入到里自己最近的地方，以提高写入速度，CPU会把数据线写到内存的磁盘缓冲区，然后就认为数据已经写入完成看，然后内核的线程在后面的时间在写入磁盘，所以服务器突然断电会丢失内存中的部分数据。<br>cache：缓存也叫读缓存，一般用于读操作，CPU读文件从内存读，如果内存没有就先从硬盘读到内存再读到CPU，将需要频繁读取的数据放在里自己最近的缓存区域，下次读取的时候即可快速读取。</li><li><p>2.cache的保存位置：</p><ul><li>客户端：浏览器</li><li>内存：本地服务器、远程服务器</li><li>硬盘：本机硬盘、远程服务器硬盘</li><li>速度对比：</li><li>客户端浏览器-内存-远程内存-硬盘-远程硬盘。</li></ul></li><li><p>3.cache的特性：</p><ul><li>过期时间</li><li>强制过期，源网站更新图片后CDN是不会更新的，需要强制是图片缓存过期</li><li>命中率，即缓存的读取命中率</li></ul></li></ul></li><li><p>用户层缓存：</p><ul><li>1.DNS缓存：<ul><li>默认为60秒，即60秒之内在访问同一个域名就不在进行 </li><li>DNS解析：</li><li>查看chrome浏览器的DNS缓存：</li><li>chrome://net-internals/#dns</li></ul></li></ul></li></ul><p><img src="/2018/12/26/redis缓存/chrome浏览器缓存.png" alt=""></p><ul><li>浏览器缓存过期机制：<ul><li>最后修改时间：<ul><li>系统调用会获取文件的最后修改时间，如果没有发生变化就返回给浏览器304的状态码，表示没有发生变化，然后浏览器就使用的本地的缓存展示资源，</li></ul></li></ul></li></ul><p><img src="/2018/12/26/redis缓存/最后修改时间.png" alt=""></p><ul><li>Etag标记：<ul><li>基于Etag标记是否一致做判断页面是否发生过变化</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/etag标记.png" alt=""></p><ul><li>过期时间：<ul><li>以上两种都需要发送请求，即不管资源是否过期都要发送请求进行协商，这样会消耗不必要的时间，因此有了缓存的过期时间，即第一次请求资源的时候带一个资源的过期时间，默认为30天，当前这种方式使用的比表较多，但是无法保证客户的时间都是准确并且一致的，因此假如一个最大生存周期，使用用户本地的时间计算缓存数据是否超过多少天，下面的过期时间为2027年，但是缓存的最大生存周期计算为天等于3650天即10年，过期时间如下：</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/过期时间.png" alt=""></p><ul><li><p>CDN缓存：</p><ul><li>什么是CND：<ul><li>内容分发网络（Content Delivery Network），通过将服务内容分发至全网加速节点，利用全球调度系统使用户能够就近获取，有效降低访问延迟，提升服务可用性，CDN 第一降低机房的使用带宽，因为很多资源通过CDN就直接返回用户了，第二解决不同运营商之间的互联，因为可以让联通的网络访问联通让电信的网络访问电信，起到加速用户访问的目的， 第三：解决用户访问的地域问题，就近返回用户资源。    </li><li>百度CDN：<a href="https://cloud.baidu.com/product/cdn.html" target="_blank" rel="noopener">https://cloud.baidu.com/product/cdn.html</a> </li><li>阿里CDN：<a href="https://www.aliyun.com/product/cdn?spm=5176.8269123.416540.50.728y8n" target="_blank" rel="noopener">https://www.aliyun.com/product/cdn?spm=5176.8269123.416540.50.728y8n</a> </li><li>腾讯CDN：<a href="https://www.qcloud.com/product/cdn" target="_blank" rel="noopener">https://www.qcloud.com/product/cdn</a> </li></ul></li></ul></li><li><p>用户请求CDN流程：</p><ul><li>提前对静态内容进行预缓存，避免大量的请求回源，导致主站网络带宽被打满而导致数据无法更新，另外CDN可以将数据根据访问的热度不同而进行不同级别的缓存，例如访问量最高的资源访问CDN 边缘节点的内存，其次的放在SSD或者SATA，再其次的放在云存储，这样兼顾了速度与成本。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/用户请求CDN流程.png" alt=""></p><ul><li><p>CDN主要优势：</p><ul><li>提前对静态内容进行预缓存，避免大量的请求回源，导致主站网络带宽被打满而导致数据无法更新，另外CDN可以将数据根据访问的热度不通而进行不通级别的缓存，例如访问量最高的资源访问CDN 边缘节点的内存，其次的放在SSD或者SATA，再其次的放在云存储，这样兼顾了速度与成本。缓存-缓存到最快的地方如内存，缓存的数据准确命中率高，访问速度就快</li><li>调度准确-将用户调度到最近的边缘节点</li><li>性能优化-CDN 专门用于缓存响应速度快</li><li>安全相关-抵御攻击</li><li>节省带宽：由于用户请求由边缘节点响应，因此大幅降低到源站带宽。</li></ul></li><li><p>应用层缓存：</p><ul><li>Nginx、PHP等web服务可以设置应用缓存以加速响应用户请求，另外有些解释性语言比如PHP/Python不能直接运行，需要先编译成字节码，但字节码需要解释器解释为机器码之后才能执行，因此字节码也是一种缓存，有时候会出现程序代码上线后字节码没有更新的现象。</li></ul></li><li><p>其他层面缓存：</p><ul><li>CPU缓存(L1的数据缓存和L1的指令缓存)、二级缓存、三级缓存</li><li>磁盘缓存</li><li>RAID卡</li><li>分布式缓存：redis、memcache</li><li># MegaCli64 -LDinfo -Lall -aAll</li></ul></li></ul><h2 id="二：-redis部署与使用："><a href="#二：-redis部署与使用：" class="headerlink" title="二： redis部署与使用："></a>二： redis部署与使用：</h2><ul><li><p>redis基础：</p><ul><li>官网地址：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a> </li><li>Redis和Memcached是非关系型数据库也成为NoSQL，MySQL、Mariadb、SQL Server、PostgreSQL、Oracle 数据库属于关系型数据(RDBMS, Relational Database Management System)</li></ul></li><li><p>redis简介：</p><ul><li>Redis(Remote Dictionary Server)在2009年发布，开发者Salvatore Sanfilippo是意大利开发者，他本想为自己的公司开发一个用于替换MySQL的产品Redis，但是没有想到他把Redis开源后大受欢迎，短短几年，Redis就有了很大的用户群体，目前国内外使用的公司有知乎网、新浪微博、GitHub等</li><li>redis是一个开源的、遵循BSD协议的、基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis提供将内存通过网络远程共享的一种服务，提供类似功能的还有memcache，但相比memcache，redis还提供了易扩展、高性能、具备数据持久性等功能。<br>Redis在高并发、低延迟环境要求比较高的环境使用量非常广泛，目前redis在DB-Engine月排行榜<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">https://db-engines.com/en/ranking</a> 中一直比较靠前，而且一直是键值型存储类的首位。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/redis简介.png" alt=""></p><ul><li><p>redis对比memcached：</p><ul><li>支持数据的持久化：可以将内存中的数据保持在磁盘中，重启redis服务或者服务器之后可以从备份文件中恢复数据到内存继续使用。</li><li>支持更多的数据类型：支持string(字符串)、hash(哈希数据)、list(列表)、set(集合)、zet(有序集合)</li><li>支持数据的备份：可以实现类似于数据的master-slave模式的数据备份，另外也支持使用快照+AOF。</li><li>支持更大的value数据：memcache单个key value最大，支持1MB，而redis最大支持512MB。</li><li>Redis 是单线程，而memcache是多线程，所以单机情况下没有memcache并发高，但redis 支持分布式集群以实现更高的并发，单Redis实例可以实现数万并发。</li><li>支持集群横向扩展：基于redis cluster的横向扩展，可以实现分布式集群，大幅提升性能和数据安全性。</li><li>都是基于C语言开发。</li></ul></li><li><p>redis 典型应用场景：</p><ul><li>Session 共享：常见于web集群中的Tomcat或者PHP中多web服务器session共享</li><li>消息队列：ELK的日志缓存、部分业务的订阅发布系统</li><li>计数器：访问排行榜、商品浏览数等和次数相关的场景</li><li>缓存：数据查询、电商网站商品信息、新闻内容</li><li>微博/微信社交场合：共同好友、点赞评论等</li></ul></li><li><p><code>Redis安装及使用：</code></p><ul><li>官方下载地址：<a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></li></ul></li><li><p><code>yum安装redis</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># yum list redis</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Available Packages</span><br><span class="line">redis.x86_64                            3.2.12-2.el7    </span><br><span class="line">[root@centos7 ~]<span class="comment"># yum install redis -y</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># systemctl start redis &amp;&amp; systemctl enable redis</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>编译安装redis</code></p></li></ul><p><img src="/2018/12/26/redis缓存/编译安装redis.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">官方的安装命令：</span><br><span class="line">  https://redis.io/download </span><br><span class="line"></span><br><span class="line">创建一个适合自己程序防止路径</span><br><span class="line">  [root@centos7 ~]<span class="comment"># mkdir -pv /usr/local/src</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># cd !$</span></span><br><span class="line">  <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">  [root@centos7 src]<span class="comment"># pwd</span></span><br><span class="line">  /usr/<span class="built_in">local</span>/src</span><br><span class="line">  [root@centos7 src]<span class="comment"># ls</span></span><br><span class="line">  redis-5.0.3.tar.gz</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">  [root@centos7 src]<span class="comment"># tar xvf redis-5.0.3.tar.gz </span></span><br><span class="line">  </span><br><span class="line">安装开发包组</span><br><span class="line">  [root@centos7 redis-5.0.3]<span class="comment"># yum groupinstall "Development Tools"</span></span><br><span class="line"></span><br><span class="line">编译安装（大小写敏感）</span><br><span class="line">  [root@centos7 redis-5.0.3]<span class="comment"># make PREFIX=/usr/local/redis install</span></span><br><span class="line"></span><br><span class="line">  [root@centos7 redis]<span class="comment"># cd /usr/local/redis/bin/</span></span><br><span class="line">  [root@centos7 bin]<span class="comment"># ls</span></span><br><span class="line">  redis-benchmark  redis-check-rdb  redis-sentinel</span><br><span class="line">  redis-check-aof  redis-cli        redis-server</span><br><span class="line"></span><br><span class="line">创建主配置文件以及程序文件</span><br><span class="line">  [root@centos7 ~]<span class="comment"># cd /usr/local/redis/</span></span><br><span class="line">  [root@centos7 redis]<span class="comment"># ls</span></span><br><span class="line">  bin</span><br><span class="line">  [root@centos7 redis]<span class="comment"># mkdir etc logs run data</span></span><br><span class="line">  root@centos7 redis]<span class="comment"># cp /usr/local/src/redis-5.0.3/redis.conf /usr/local/redis/etc/</span></span><br><span class="line">  [root@centos7 redis]<span class="comment"># ln -sv /usr/local/redis/bin/* /usr/bin/</span></span><br><span class="line"></span><br><span class="line">初次启动解决当前警报启动</span><br><span class="line">  [root@centos7 redis]<span class="comment"># redis-server /usr/local/redis/etc/redis.conf </span></span><br><span class="line">  34186:C 26 Dec 2018 22:10:01.659 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">  34186:C 26 Dec 2018 22:10:01.659 <span class="comment"># Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=34186, just started</span></span><br><span class="line">  34186:C 26 Dec 2018 22:10:01.659 <span class="comment"># Configuration loaded</span></span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.660 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">                  _._                                                  </span><br><span class="line">             _.-``__ <span class="string">''</span>-._                                             </span><br><span class="line">        _.-``    `.  `_.  <span class="string">''</span>-._           Redis 5.0.3 (00000000/0) 64 bit</span><br><span class="line">    .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._                                   </span><br><span class="line">   (    <span class="string">'      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string">   |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: 6379</span></span><br><span class="line"><span class="string">   |    `-._   `._    /     _.-'</span>    |     PID: 34186</span><br><span class="line">    `-._    `-._  `-./  _.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">   |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string">   |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io        </span></span><br><span class="line"><span class="string">    `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">   |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string">   |    `-._`-._        _.-'</span>_.-<span class="string">'    |                                  </span></span><br><span class="line"><span class="string">    `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">       `-._    `-.__.-<span class="string">'    _.-'</span>                                       </span><br><span class="line">           `-._        _.-<span class="string">'                                           </span></span><br><span class="line"><span class="string">               `-.__.-'</span>                                               </span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.662 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.662 <span class="comment"># Server initialized</span></span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.662 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span></span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.662 <span class="comment"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span></span><br><span class="line">  34186:M 26 Dec 2018 22:10:01.662 * Ready to accept connections</span><br><span class="line"></span><br><span class="line">解决第一次启动出现的三个报警</span><br><span class="line">  [root@centos7 ~]<span class="comment"># vim /etc/sysctl.conf </span></span><br><span class="line">  net.core.somaxconn = 512</span><br><span class="line">  vm.overcommit_memory = 1</span><br><span class="line">  [root@centos7 ~]<span class="comment"># sysctl -p</span></span><br><span class="line">  net.core.somaxconn = 512</span><br><span class="line">  vm.overcommit_memory = 1</span><br><span class="line">  [root@centos7 ~]<span class="comment"># echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span></span><br><span class="line">  永久生效写进配置文件间，开机自动加载</span><br><span class="line">  vim /etc/rc.d/rc.local </span><br><span class="line">  <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">  chmod a+x /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line">再次启动则无报警</span><br><span class="line">  [root@centos7 ~]<span class="comment"># /usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf </span></span><br><span class="line">  35112:C 27 Dec 2018 10:17:12.662 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">  35112:C 27 Dec 2018 10:17:12.662 <span class="comment"># Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=35112, just started</span></span><br><span class="line">  35112:C 27 Dec 2018 10:17:12.662 <span class="comment"># Configuration loaded</span></span><br><span class="line">  35112:M 27 Dec 2018 10:17:12.663 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">                  _._                                                  </span><br><span class="line">             _.-``__ <span class="string">''</span>-._                                             </span><br><span class="line">        _.-``    `.  `_.  <span class="string">''</span>-._           Redis 5.0.3 (00000000/0) 64 bit</span><br><span class="line">    .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._                                   </span><br><span class="line">   (    <span class="string">'      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string">   |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: 6379</span></span><br><span class="line"><span class="string">   |    `-._   `._    /     _.-'</span>    |     PID: 35112</span><br><span class="line">    `-._    `-._  `-./  _.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">   |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string">   |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io        </span></span><br><span class="line"><span class="string">    `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">   |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string">   |    `-._`-._        _.-'</span>_.-<span class="string">'    |                                  </span></span><br><span class="line"><span class="string">    `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">       `-._    `-.__.-<span class="string">'    _.-'</span>                                       </span><br><span class="line">            `-._        _.-<span class="string">'                                           </span></span><br><span class="line"><span class="string">                `-.__.-'</span>                                               </span><br><span class="line">  35112:M 27 Dec 2018 10:17:12.667 <span class="comment"># Server initialized</span></span><br><span class="line">  35112:M 27 Dec 2018 10:17:12.667 * Ready to accept connections</span><br></pre></td></tr></table></figure></p><ul><li><p><code>解决当前的警告提示：</code></p><ul><li><p>警报：tcp-backlog：</p><ul><li>backlog参数控制的是三次握手的时候server端收到client ack确认号之后的队列值。</li><li>net.core.somaxconn = 512</li></ul></li><li><p>警报：vm.overcommit_memory：</p><ul><li>0、表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li><li>1、表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</li><li>2、表示内核允许分配超过所有物理内存和交换空间总和的内存</li><li>vm.overcommit_memory = 1</li></ul></li><li>警报：transparent hugepage：<ul><li>开启大页内存动态分配，需要关闭让redis 负责内存管理。<ul><li>临时生效</li></ul></li><li>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<ul><li>永久生效写进配置文件间，开机自动加载</li></ul></li><li>vim /etc/rc.d/rc.local <ul><li>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul></li><li>chmod a+x /etc/rc.d/rc.local<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">redis启动默认使再前台工作，编写启动脚本将服务的启动送往后台执行</span><br><span class="line"></span><br><span class="line">服务启动对应的端口已经默认监听的端口</span><br><span class="line">  [root@centos7 ~]<span class="comment"># ss -tnl</span></span><br><span class="line">  LISTEN      0      511    127.0.0.1:6379    </span><br><span class="line"></span><br><span class="line">编辑redis服务启动脚本</span><br><span class="line">  服务的配置文件放在了/usr/<span class="built_in">local</span>/redis/bin/redis-servier</span><br><span class="line">  服务的主配置文件放在了/usr/<span class="built_in">local</span>/redis/etc/redis.conf</span><br><span class="line"></span><br><span class="line">  [root@centos7 ~]<span class="comment"># vim /usr/lib/systemd/system/redis.service</span></span><br><span class="line">  [Unit]</span><br><span class="line">  Description=Redis persistent key-value database</span><br><span class="line">  After=network.target</span><br><span class="line">  After=network-online.target</span><br><span class="line">  Wants=network-online.target</span><br><span class="line"></span><br><span class="line">  [Service]</span><br><span class="line">  ExecStart=/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/etc/redis.conf  --supervised systemd</span><br><span class="line">  ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">  ExecStop=/bin/<span class="built_in">kill</span> -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">  Type=notify</span><br><span class="line">  User=redis</span><br><span class="line">  Group=redis</span><br><span class="line">  RuntimeDirectory=redis</span><br><span class="line">  RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">  [Install]</span><br><span class="line">  WantedBy=multi-user.target</span><br><span class="line">编辑主配置文件</span><br><span class="line">  vim /usr/<span class="built_in">local</span>/redis/etc/redis.conf </span><br><span class="line">  daemonize yes <span class="comment">#让redis作为守护进程运行</span></span><br><span class="line"></span><br><span class="line">创建redis 用户和数据目录：</span><br><span class="line">  [root@centos7 ~]<span class="comment"># useradd redis -s /sbin/nologin </span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># chown -R redis.redis /usr/local/redis/</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># systemctl start redis.service </span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># ss -tnl</span></span><br><span class="line">  LISTEN      0      511    127.0.0.1:6379  </span><br><span class="line"></span><br><span class="line">创建命令软连接</span><br><span class="line">  [root@centos7 ~]<span class="comment"># ln -sv /usr/local/redis/bin/* /usr/bin/</span></span><br><span class="line"></span><br><span class="line">修改服务器的监听端口，默认监听在本机的127.0.0.1</span><br><span class="line">  [root@centos7 ~]<span class="comment"># vim /usr/local/redis/etc/redis.conf </span></span><br><span class="line">  <span class="built_in">bind</span> 127.0.0.1 172.18.135.1   (<span class="built_in">bind</span> 地址绑定到本机哪个地址供谁可以访问0.0.0.0代表本机监听在本机的所有的地址)</span><br><span class="line"></span><br><span class="line">使用客户端连接本机的redis服务器</span><br><span class="line">  [root@centos7 ~]<span class="comment"># redis-cli -h 172.18.135.1 -p 6379</span></span><br><span class="line">  172.18.135.1:6379&gt; info</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>编译安装后的命令：</code></p><ul><li>[root@redis-s1 ~]# ll /usr/local/redis/bin/<br>total 32656</li><li>-rwxr-xr-x 1 redis redis 4365488 Dec 13 09:21 redis-benchmark #redis性能测试工具</li><li>-rwxr-xr-x 1 redis redis 8088920 Dec 13 09:21 redis-check-aof #AOF文件检查工具</li><li>-rwxr-xr-x 1 redis redis 8088920 Dec 13 09:21 redis-check-rdb #RDB文件检查工具</li><li>-rwxr-xr-x 1 redis redis 4800752 Dec 13 09:21 redis-cli #redis #客户端工具</li><li>lrwxrwxrwx 1 redis redis   12 Dec 13 09:21 redis-sentinel -&gt; redis-server #哨兵，软连接到</li></ul></li><li><p><code>使用客户端连接redis：</code></p><ul><li>#/usr/local/redis/bin/redis-cli  -h  IP/HOSTNAME -p PORT -a PASSWORD</li></ul></li><li><p><code>redis配置文件：</code></p></li><li><p>redis主要配置项：</p><ul><li>bind 0.0.0.0  #监听地址，可以用空格隔开后多个监听IP</li><li>protected-mode yes  #redis3.2 之后加入的新特性，在没有设置bind IP和密码的时候只允许访问127.0.0.1:6379</li><li>port 6379 #监听端口</li><li>tcp-backlog 511  #三次握手的时候server端收到client ack确认号之后的队列值。</li><li>timeout 0 #客户端和Redis服务端的连接超时时间，默认是0，表示永不超时。 </li><li>tcp-keepalive 300  #tcp 会话保持时间</li><li>daemonize no  #认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes,当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面</li><li>supervised no  #和操作系统相关参数，可以设置通过upstart和systemd管理Redis守护进程，centos 7以后都使用systemd</li><li>pidfile /var/run/redis_6379.pid  #pid文件路径,确定生成的日志目录是有权限的，实际上存放的就是进程号。</li><li>loglevel notice #日志级别</li><li>logfile “” #日志路径</li><li>databases 16  #设置db 库数量，默认16个库，可以连接到redis后使用select # ,切换库</li><li>always-show-logo yes #在启动redis 时是否显示log</li><li>save 900 1   #在900秒内有一个键内容发生更改就出就快照机制</li><li>save 300 10</li><li>save 60 10000</li><li>stop-writes-on-bgsave-error yes  #快照出错时是否禁止redis 写入操作（默认为yes，建议使用no，出错的原因，磁盘满了，权限问题，改为no的原因是系统是由监控的，所以不会等磁盘满了防止数据丢失）</li><li>rdbcompression yes     #持久化到RDB文件时，是否压缩，”yes”为压缩，”no”则反之</li><li>rdbchecksum yes      #是否开启RC64校验，默认是开启（检查RDB文件是否完整）</li><li>dbfilename dump.rdb #快照文件名</li><li>dir ./                  #快照文件保存路径</li><li>replica-serve-stale-data yes #当从库同主库失去连接或者复制正在进行，从机库有两种运行方式：1) 如果replica-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果replica-serve-stale-data设置为no，除去指定的命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</li><li>replica-read-only yes #是否设置从库只读</li><li><p>repl-diskless-sync no #是否使用socket方式复制数据，目前redis复制提供两种方式，disk和socket，如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件，有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave，socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave，disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件，socket的方式就是一个个slave顺序复制，只有在磁盘速度缓慢但是网络相对较快的情况下才使用socket方式，否则使用默认的disk方式</p></li><li><p>repl-diskless-sync-delay 5  #diskless复制的延迟时间，设置0为关闭，一旦复制开始还没有结束之前，master节点不会再接收新slave的复制请求，直到下一次开始</p></li><li>repl-ping-slave-period 10 #slave根据master指定的时间进行周期性的PING 监测</li><li>repl-timeout 60 #复制链接超时时间，需要大于repl-ping-slave-period，否则会经常报超时</li><li>repl-disable-tcp-nodelay no #在socket模式下是否slave套接字发送SYNC之后禁用 TCP_NODELAY，<br>如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒，如果你选择了 “no” 数据传输到salve的延迟将会减少但要使用更多的带宽</li><li>repl-backlog-size 1mb #复制缓冲区大小，只有在slave连接之后才分配内存。 </li><li>repl-backlog-ttl 3600 #多次时间master没有slave连接，就清空backlog缓冲区。</li><li>replica-priority 100 #当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</li><li>requirepass foobared #设置redis 连接密码</li><li>rename-command #重命名一些高危命令</li><li>maxclients 10000 #最大连接客户端（根据生产进行调整）</li><li>maxmemory #最大内存，单位为bytes字节，8G内存的计算方式8(G)<em>1024(MB)</em>1024(KB)*1024(Kbyte)，需要注意的是slave的输出缓冲区是不计算在maxmemory内。（如果不限制，则redis无限使用物理内存，最后将服务器的进程kill掉，最好给予系统内存的一半，生产使用redis建议服务器16G给redis服务器8G）</li></ul></li></ul><ul><li>appendonly no #是否开启AOF日志记录，默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</li><li>appendfilename “appendonly.aof” #AOF文件名</li><li>appendfsync everysec  #aof持久化策略的配置,no表示不执行fsync,由操作系统保证数据同步到磁盘,always表示每次写入都执行fsync，以保证数据同步到磁盘,everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</li><li>no-appendfsync-on-rewrite no在aof rewrite期间,是否对aof新记录的append暂缓使用文件同步策略,主要考虑磁盘IO开支和请求阻塞时间。默认为no,表示”不暂缓”,新的aof记录仍然会被立即同步，Linux的默认fsync策略是30秒，如果为yes 可能丢失30秒数据，但由于yes性能较好而且会避免出现阻塞因此比较推荐。</li><li>auto-aof-rewrite-percentage 100 # 当Aof log增长超过指定比例时，重写log file， 设置为0表示不自动重写Aof 日志，重写是为了使aof体积保持最小，而确保保存最完整的数据。</li><li>auto-aof-rewrite-min-size 64mb #触发aof rewrite的最小文件尺寸</li><li>aof-load-truncated yes #是否加载由于其他原因导致的末尾异常的AOF文件(主进程被kill/断电等)</li><li>aof-use-rdb-preamble yes #redis4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，这样Redis就可以同时兼有RDB持久化和AOF持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。</li></ul><ul><li>lua-time-limit 5000 #lua脚本的最大执行时间，单位为毫秒</li><li>cluster-enabled yes #是否开启集群模式，默认是单机模式</li><li>cluster-config-file nodes-6379.conf #由node节点自动生成和的集群配置文件</li><li>cluster-node-timeout 15000 #集群中node节点连接超时时间</li><li>cluster-replica-validity-factor 10 #在执行故障转移的时候可能有些节点和master断开一段时间数据比较旧，这些节点就不适用于选举为master，超过这个时间的就不会被进行故障转移</li><li>cluster-migration-barrier 1  #一个主节点拥有的至少正常工作的从节点，即如果主节点的slave节点故障后会将多余的从节点分配到当前主节点成为其新的从节点。</li><li>cluster-require-full-coverage yes #集群槽位覆盖，如果一个主库宕机且没有备库就会出现集群槽位不全，那么yes情况下redis集群槽位验证不全就不再对外提供服务，而no则可以继续使用但是会出现查询数据查不到的情况(因为有数据丢失)。</li><li>cluster-replica-no-failover no#Slow log 是 Redis 用来记录查询执行时间的日志系统，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</li><li>slowlog-log-slower-than 10000 #以微秒为单位的慢日志记录，为负数会禁用慢日志，为0会记录每个命令操作。</li><li>slowlog-max-len 128 #记录多少条慢日志保存在队列，超出后会删除最早的，以此滚动删除</li></ul><h2 id="三：-redis持久化："><a href="#三：-redis持久化：" class="headerlink" title="三： redis持久化："></a>三： redis持久化：</h2><ul><li>redis 虽然是一个内存级别的缓存程序，即redis 是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的，redis支持两种不同方式的数据持久化保存机制，分别是RDB和AOF</li><li><p><code>RDB模式：</code></p><ul><li>RDB：基于时间的快照，只保留当前最新的一次快照，特点是执行速度比较快，缺点是可能会丢失从上次快照到当前快照未完成之间的数据。</li><li><p>RDB实现的具体过程Redis从主进程先fork出一个子进程，使用写时复制机制，子进程将内存的数据保存为一个临时文件，比如dump.rdb.temp，当数据保存完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保存每一次做RDB快照的时候保存的数据都是完整的，因为直接替换RDB文件的时候可能会出现突然断电等问题而导致RDB文件还没有保存完整就突然关机停止保存而导致数据丢失的情况，可以手动将每次生成的RDB文件进程备份，这样可以最大化保存历史数据。</p></li><li><p>RDB模式的优缺点：</p></li><li>优点：<ul><li>RDB快照保存了某个时间点的数据，可以通过脚本执行bgsave(非阻塞)或者save(阻塞)命令自定义时间点北备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本。</li><li>可以最大化o的性能，因为父进程在保存RDB 文件的时候唯一要做的是fork出一个子进程，然后的-操作都会有这个子进程操作，父进程无需任何的IO操作</li><li>RDB在大量数据比如几个G的数据，恢复的速度比AOF的快</li></ul></li><li>缺点：<ul><li>不能时时的保存数据，会丢失自上一次执行RDB备份到当前的内存数据</li><li>数据量非常大的时候，从父进程fork的时候需要一点时间，可能是毫秒或者秒</li></ul></li></ul></li><li><p><code>AOF模式：</code></p><ul><li>AOF:按照操作顺序依次将操作添加到指定的日志文件当中，特点是数据安全性相对较高，缺点是即使有些操作是重复的也会全部记录。</li><li>AOF和RDB一样使用了写时复制机制，AOF默认为每秒钟fsync一次，即将执行的命令保存到AOF文件当中，这样即使redis服务器发生故障的话顶多也就丢失1秒钟之内的数据，也可以设置不同的fsync策略，或者设置每次执行命令的时候执行fsync，fsync会在后台执行线程，所以主线程可以继续处理用户的正常请求而不受到写入AOF文件的IO影响</li></ul><ul><li>AOF模式优缺点：<ul><li>AOF的文件大小要大于RDB格式的文件<ul><li>根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec即每秒执行一次fsync</li></ul></li></ul></li></ul></li></ul><h2 id="四：-redis-数据类型："><a href="#四：-redis-数据类型：" class="headerlink" title="四： redis 数据类型："></a>四： redis 数据类型：</h2><ul><li><p>1.字符串(string)：</p><ul><li>字符串是所有编程语言中最常见的和最常用的数据类型，而且也是redis最基本的数据类型之一，而且redis中所有的key的类型都是字符串。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">连接redis</span><br><span class="line">  [root@centos7 ~]<span class="comment"># redis-cli -h 172.18.135.1 -p 6379</span></span><br><span class="line">  172.18.135.1:6379&gt; </span><br><span class="line"></span><br><span class="line">添加一个key</span><br><span class="line">  172.18.135.1:6379&gt; <span class="built_in">set</span> key1 value1  （后面可以添加过期时间，如果不加则永不过期）</span><br><span class="line">  OK</span><br><span class="line"></span><br><span class="line">查看key对应的值</span><br><span class="line">  172.18.135.1:6379&gt; get key1</span><br><span class="line">  <span class="string">"value1"</span></span><br><span class="line"></span><br><span class="line">查看key的类型</span><br><span class="line">  172.18.135.1:6379&gt; <span class="built_in">type</span> key1</span><br><span class="line">  string（字符串）</span><br><span class="line"></span><br><span class="line">删除key的值 （DEL可以删除任何类型的key）</span><br><span class="line">  172.18.135.1:6379&gt; DEL key1</span><br><span class="line">  (<span class="built_in">integer</span>) 1       (返回值为1，则表示成功，0表示不成功)</span><br><span class="line">  172.18.135.1:6379&gt; get key1</span><br><span class="line">  (nil)</span><br><span class="line"></span><br><span class="line">批量创建多个key</span><br><span class="line">  172.18.135.1:6379&gt; mset key1 value1 key2 value2  ....</span><br><span class="line">  OK</span><br><span class="line"></span><br><span class="line">批量获取多个key的值</span><br><span class="line">  172.18.135.1:6379&gt; mget key1 key2 </span><br><span class="line">  1) <span class="string">"value1"</span></span><br><span class="line">  2) <span class="string">"value2"</span></span><br><span class="line"></span><br><span class="line">批量删除多个key</span><br><span class="line">  172.18.135.1:6379&gt; del key1 key2 </span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  172.18.135.1:6379&gt; mget key1 key2 </span><br><span class="line">  1) (nil)</span><br><span class="line">  2) (nil)</span><br><span class="line"></span><br><span class="line">清空当前库的所有数据</span><br><span class="line">  172.18.135.1:6379&gt; flushdb</span><br><span class="line">  OK</span><br><span class="line"></span><br><span class="line">查看当前数据库的所有key值</span><br><span class="line">  172.18.135.1:6379&gt; keys *</span><br><span class="line">  (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">清空所有数据库的key</span><br><span class="line">  172.18.135.1:6379&gt; FLUSHALL</span><br><span class="line"></span><br><span class="line">数值递增：（必须是数字且数个整数）</span><br><span class="line">  172.18.135.1:6379&gt; SET num 0</span><br><span class="line">  OK</span><br><span class="line">  172.18.135.1:6379&gt; INCR num</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  172.18.135.1:6379&gt; GET num</span><br><span class="line">  <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">数值递减</span><br><span class="line">  172.18.135.1:6379&gt; INCR num</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  172.18.135.1:6379&gt; GET num</span><br><span class="line">  <span class="string">"2"</span></span><br><span class="line">  172.18.135.1:6379&gt; DECR num</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  172.18.135.1:6379&gt; GET num</span><br><span class="line">  <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">向列表追加数据：</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH list1 tom</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  127.0.0.1:6379&gt; RPUSH list1 jack</span><br><span class="line">  (<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">获取列表长度：</span><br><span class="line">  127.0.0.1:6379&gt; LLEN list1</span><br><span class="line">  (<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">移除列表数据：</span><br><span class="line">  127.0.0.1:6379&gt; RPOP list1 <span class="comment">#最后一个</span></span><br><span class="line">  <span class="string">"jack"</span></span><br><span class="line">  127.0.0.1:6379&gt; LPOP list1 <span class="comment">#第一个</span></span><br><span class="line">  <span class="string">"tom"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.集合(set)：</p><ul><li>Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">生成集合key:</span><br><span class="line">SADD：无序集合</span><br><span class="line">  127.0.0.1:6379&gt; SADD set1 v1 </span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; SADD set2 v2 v4</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  127.0.0.1:6379&gt; TYPE set1</span><br><span class="line">  <span class="built_in">set</span></span><br><span class="line">  127.0.0.1:6379&gt; TYPE set2</span><br><span class="line">  <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">查看集合中的所有值</span><br><span class="line">  127.0.0.1:6379&gt; SMEMBERS set1</span><br><span class="line"></span><br><span class="line">追加数值：</span><br><span class="line">追加的时候不能追加已经存在的数值</span><br><span class="line">  127.0.0.1:6379&gt; SADD set1 v2 v3 v4</span><br><span class="line">  (<span class="built_in">integer</span>) 3</span><br><span class="line">  127.0.0.1:6379&gt; SADD set1 v2 <span class="comment">#没有追加成功</span></span><br><span class="line">  (<span class="built_in">integer</span>) 0</span><br><span class="line">  127.0.0.1:6379&gt; TYPE set1</span><br><span class="line">  <span class="built_in">set</span></span><br><span class="line">  127.0.0.1:6379&gt; TYPE set2</span><br><span class="line">  <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">查看集合的所有数据：</span><br><span class="line">同<span class="built_in">set</span>的值不可重复，不同 <span class="built_in">set</span>的值可以相同</span><br><span class="line">  127.0.0.1:6379&gt; SMEMBERS set1</span><br><span class="line">  1) <span class="string">"v4"</span></span><br><span class="line">  2) <span class="string">"v1"</span></span><br><span class="line">  3) <span class="string">"v3"</span></span><br><span class="line">  4) <span class="string">"v2"</span></span><br><span class="line">  127.0.0.1:6379&gt; SMEMBERS set2</span><br><span class="line">  1) <span class="string">"v4"</span></span><br><span class="line">  2) <span class="string">"v2"</span></span><br><span class="line"></span><br><span class="line">获取集合的差集：</span><br><span class="line">差集：已属于A而不属于B的元素称为A与B的（差集）</span><br><span class="line">  127.0.0.1:6379&gt; SDIFF set1 set2</span><br><span class="line">  1) <span class="string">"v1"</span></span><br><span class="line">  2) <span class="string">"v3"</span></span><br><span class="line"></span><br><span class="line">获取集合的交集：</span><br><span class="line">交集：已属于A且属于B的元素称为A与B的(交集）</span><br><span class="line">  127.0.0.1:6379&gt; SINTER set1 set2</span><br><span class="line">  1) <span class="string">"v4"</span></span><br><span class="line">  2) <span class="string">"v2"</span></span><br><span class="line"></span><br><span class="line">获取集合的并集：</span><br><span class="line">并集：已属于A或属于B的元素为称为A与B的(并集）</span><br><span class="line">  127.0.0.1:6379&gt; SUNION  set1 set2</span><br><span class="line">  1) <span class="string">"v2"</span></span><br><span class="line">  2) <span class="string">"v4"</span></span><br><span class="line">  3) <span class="string">"v1"</span></span><br><span class="line">  4) <span class="string">"v3"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.sorted set(有序集合):</p><ul><li>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double(双精度浮点型)类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序，序集合的成员是唯一的,但分数(score)却可以重复，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)， 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">生成有序集合：</span><br><span class="line">  127.0.0.1:6379&gt; ZADD zset1 1 v1 </span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; ZADD zset1 2 v2</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; ZADD zset1 2 v3</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; ZADD zset1 3 v4</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; TYPE zset1</span><br><span class="line">  zset</span><br><span class="line">  127.0.0.1:6379&gt; TYPE zset2</span><br><span class="line">  zset</span><br><span class="line"></span><br><span class="line">排行案例：</span><br><span class="line">  192.168.7.104:6379&gt; ZADD paihangbang 10 key1 20 key2 30 key3</span><br><span class="line">  (<span class="built_in">integer</span>) 3</span><br><span class="line">  192.168.7.104:6379&gt; ZREVRANGE paihangbang 0 -1 withscores</span><br><span class="line">  1) <span class="string">"key3"</span></span><br><span class="line">  2) <span class="string">"30"</span></span><br><span class="line">  3) <span class="string">"key2"</span></span><br><span class="line">  4) <span class="string">"20"</span></span><br><span class="line">  5) <span class="string">"key1"</span></span><br><span class="line">  6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">批量添加多个数值：</span><br><span class="line">  127.0.0.1:6379&gt; ZADD zset2 1 v1 2 v2 4 v3 5 v5</span><br><span class="line">  (<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">获取集合的长度数：</span><br><span class="line">  127.0.0.1:6379&gt; ZCARD zset1 </span><br><span class="line">  (<span class="built_in">integer</span>) 4</span><br><span class="line">  127.0.0.1:6379&gt; ZCARD zset2</span><br><span class="line">  (<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">基于索引返回数值：</span><br><span class="line">  127.0.0.1:6379&gt; ZRANGE zset1 1 3</span><br><span class="line">  1) <span class="string">"v2"</span></span><br><span class="line">  2) <span class="string">"v3"</span></span><br><span class="line">  3) <span class="string">"v4"</span></span><br><span class="line">  127.0.0.1:6379&gt; ZRANGE zset1 0 2</span><br><span class="line">  1) <span class="string">"v1"</span></span><br><span class="line">  2) <span class="string">"v2"</span></span><br><span class="line">  3) <span class="string">"v3"</span></span><br><span class="line"></span><br><span class="line">返回某个数值的索引：</span><br><span class="line">  127.0.0.1:6379&gt; ZRANK zset1 v2</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; ZRANK zset1 v3</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>4.哈希(hash)：</p><ul><li>hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象,Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">生成<span class="built_in">hash</span> key：</span><br><span class="line">  127.0.0.1:6379&gt; HSET hset1 name tom  age 18</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; TYPE hset1</span><br><span class="line">  <span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line">获取<span class="built_in">hash</span> key字段值：</span><br><span class="line">  127.0.0.1:6379&gt; HGET hset1 name</span><br><span class="line">  <span class="string">"tom"</span></span><br><span class="line">  127.0.0.1:6379&gt; HGET hset1  age</span><br><span class="line">  <span class="string">"18"</span></span><br><span class="line"></span><br><span class="line">删除一个<span class="built_in">hash</span> key的字段：</span><br><span class="line">  127.0.0.1:6379&gt; HDEL hset1 age</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">获取所有<span class="built_in">hash</span>表中的字段：</span><br><span class="line">  127.0.0.1:6379&gt; HSET hset1 name tom age 19</span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; HKEYS hset1</span><br><span class="line">  1) <span class="string">"name"</span></span><br><span class="line">  2) <span class="string">"age"</span></span><br><span class="line"></span><br><span class="line">设定key的过期时间</span><br><span class="line">  127.0.0.1:6379&gt;  <span class="built_in">set</span> test1 value1 ex 5   <span class="comment">#设定这个key的过期时间，43200半天时间，g根据用户需求设定</span></span><br><span class="line"></span><br><span class="line">查看key的过期时长</span><br><span class="line">  127.0.0.1:6379&gt; TTL key1</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="五：-消息队列："><a href="#五：-消息队列：" class="headerlink" title="五： 消息队列："></a>五： 消息队列：</h2><p>消息队列主要分为两种，分别是生产者消费者模式和发布者订阅者模式，这两种模式Redis都支持</p><h3 id="生产者消费者模式："><a href="#生产者消费者模式：" class="headerlink" title="生产者消费者模式："></a>生产者消费者模式：</h3><ul><li>1.在生产者消费者(Producer/Consumer)模式下，上层应用接收到的外部请求后开始处理其当前步骤的操作，在执行完成后将已经完成的操作发送至指定的频道(channel)当中，并由其下层的应用监听该频道并继续下一步的操作，如果其处理完成后没有下一步的操作就直接返回数据给外部请求，如果还有下一步的操作就再将任务发布到另外一个频道，由另外一个消费者继续监听和处理。</li><li>2.模式介绍：<ul><li>生产者消费者模式下，多个消费者同时监听一个队里，但是一个消息只能被最先抢到消息的消费者消费，即消息任务是一次性读取和处理，此模式在分布式业务架构中非常常用，比较常用的软件还有 RabbitMQ、Kafka、RocketMQ、ActiveMQ等</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/生产者消费者模式.png" alt=""></p><ul><li>3.队列介绍：<ul><li>队列当中的 消息由不同的生产者写入也会有不同的消费者取出进行消费处理，但是买一个消息一定是只能被取出一次也就是被消费一次。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/队列介绍.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">生产者发布消息：</span><br><span class="line">  [root@redis-s4 ~]<span class="comment"># redis-cli</span></span><br><span class="line">  127.0.0.1:6379&gt; AUTH 123456</span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH channel1 msg1 <span class="comment">#从管道的左侧写入</span></span><br><span class="line">  (<span class="built_in">integer</span>) 1</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH channel1 msg2</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH channel1 msg3</span><br><span class="line">  (<span class="built_in">integer</span>) 3</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH channel1 msg4</span><br><span class="line">  (<span class="built_in">integer</span>) 4</span><br><span class="line">  127.0.0.1:6379&gt; LPUSH channel1 msg5</span><br><span class="line">  (<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">切换终端模拟消费者，查看队列所有消息：<span class="comment">#（0，-1代表查看所有的消息）</span></span><br><span class="line">  127.0.0.1:6379&gt; LRANGE channel1  0  -1  <span class="comment">#切换其他客户端查看则已经看不到此条消息队列，因为已经被当前客户端取走</span></span><br><span class="line">  1) <span class="string">"msg5"</span></span><br><span class="line">  2) <span class="string">"msg4"</span></span><br><span class="line">  3) <span class="string">"msg3"</span></span><br><span class="line">  4) <span class="string">"msg2"</span></span><br><span class="line">  5) <span class="string">"msg1"</span></span><br><span class="line"></span><br><span class="line">消费者消费消息：</span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1 <span class="comment">#从管道的右侧消费</span></span><br><span class="line">  <span class="string">"msg1"</span></span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1</span><br><span class="line">  <span class="string">"msg2"</span></span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1</span><br><span class="line">  <span class="string">"msg3"</span></span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1</span><br><span class="line">  <span class="string">"msg4"</span></span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1</span><br><span class="line">  <span class="string">"msg5"</span></span><br><span class="line">  127.0.0.1:6379&gt; RPOP channel1</span><br><span class="line">  (nil)</span><br><span class="line"></span><br><span class="line">切换主机模拟消费者，再次验证队列消息：</span><br><span class="line">  127.0.0.1:6379&gt;  LRANGE channel1  0  -1 </span><br><span class="line">  (empty list or <span class="built_in">set</span>)  <span class="comment">#队列中的消息已经被已全部消费完毕</span></span><br></pre></td></tr></table></figure><h3 id="发布者订阅模式："><a href="#发布者订阅模式：" class="headerlink" title="发布者订阅模式："></a>发布者订阅模式：</h3><ul><li>1.模式简介：<ul><li>在发布者订阅者模式下，发布者将消息发布到指定的channel里面，凡是监听该channel的消费者都会收到同样的一份消息，这种模式类似于是收音机模式，即凡是收听某个频道的听众都会收到主持人发布的相同的消息内容。</li><li>此模式常用语群聊天、群通知、群公告等场景。<ul><li>Subscriber：订阅者</li><li>Publisher：发布者</li><li>Channel：频道</li></ul></li></ul></li></ul><p><img src="/2018/12/26/redis缓存/发布者订阅模式.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">订阅者监听频道：</span><br><span class="line">  [root@redis-s4 ~]<span class="comment"># redis-cli </span></span><br><span class="line">  127.0.0.1:6379&gt; AUTH 123456</span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379&gt; SUBSCRIBE channel1  <span class="comment">#订阅者订阅指定的频道,也就是客户端监听服务端的频道，此时可以模拟多个客户端监听服务端的此频道</span></span><br><span class="line">  Reading messages... (press Ctrl-C to quit)</span><br><span class="line">  1) <span class="string">"subscribe"</span></span><br><span class="line">  2) <span class="string">"channel1"</span></span><br><span class="line">  3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">发布者发布消息：<span class="comment">#服务端在此频道发布消息，此时客户端监听在服务端的此频道，都会接受到消息</span></span><br><span class="line">  127.0.0.1:6379&gt; PUBLISH channel1 test1 <span class="comment">#发布者发布消息</span></span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  127.0.0.1:6379&gt; PUBLISH channel1 test2</span><br><span class="line">  (<span class="built_in">integer</span>) 2</span><br><span class="line">  127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">订阅多个频道：</span><br><span class="line">订阅指定的多个频道</span><br><span class="line">  127.0.0.1:6379&gt;  SUBSCRIBE channel1 channel2 </span><br><span class="line"></span><br><span class="line">订阅所有频道：</span><br><span class="line">  127.0.0.1:6379&gt; PSUBSCRIBE *</span><br><span class="line"></span><br><span class="line">订阅匹配的频道：</span><br><span class="line">  127.0.0.1:6379&gt; PSUBSCRIBE chann* <span class="comment">#匹配订阅多个频道</span></span><br></pre></td></tr></table></figure><h2 id="六：-redis其他命令："><a href="#六：-redis其他命令：" class="headerlink" title="六： redis其他命令："></a>六： redis其他命令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">CONFIG：</span><br><span class="line">  config 命令用于查看当前redis配置、以及不重启更改redis配置等</span><br><span class="line">  127.0.0.1:6379&gt;config get * <span class="comment">#获取config的命令配置帮助,或当前配置</span></span><br><span class="line"></span><br><span class="line">更改最大内存：</span><br><span class="line">  127.0.0.1:6379&gt; CONFIG <span class="built_in">set</span> maxmemory 8589934592</span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379&gt; CONFIG get maxmemory <span class="comment">#获取此配置项的值</span></span><br><span class="line">  1) <span class="string">"maxmemory"</span></span><br><span class="line">  2) <span class="string">"8589934592"</span></span><br><span class="line"></span><br><span class="line">设置连接密码：(可以先修改配置文件再动态命令行设置，这样避免重启服务生效)</span><br><span class="line">  127.0.0.1:6379&gt; CONFIG SET requirepass 123456</span><br><span class="line">  OK        <span class="comment">#通过CONFIG设置密码后立即生效</span></span><br><span class="line">  重现连接测试</span><br><span class="line">  172.18.135.1:6379&gt; CONFIG SET requirepass 123456</span><br><span class="line">  OK</span><br><span class="line">  172.18.135.1:6379&gt; <span class="built_in">exit</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># redis-cli -h 172.18.135.1 -p 6379</span></span><br><span class="line">  172.18.135.1:6379&gt; keys *</span><br><span class="line">  (error) NOAUTH Authentication required.</span><br><span class="line">  172.18.135.1:6379&gt; auth 123456  <span class="comment">#auth认证连接</span></span><br><span class="line">  OK</span><br><span class="line">  172.18.135.1:6379&gt; keys *</span><br><span class="line">  1) <span class="string">"key1"</span></span><br><span class="line"></span><br><span class="line">编辑配置文件设置连接redis的密码永久生效</span><br><span class="line">  <span class="comment">#可以先在redis动态控制台设置完再在配置文件中修改这样会避免重启服务器代来不必要的损失</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># vim /usr/local/redis/etc/redis.conf </span></span><br><span class="line">  507行</span><br><span class="line">  requirepass 123456</span><br><span class="line"></span><br><span class="line">info：</span><br><span class="line">显示当前节点redis运行状态信息</span><br><span class="line">  172.18.135.1:6379&gt; info </span><br><span class="line"></span><br><span class="line">SELECT：</span><br><span class="line">切换数据库</span><br><span class="line">  172.18.135.1:6379&gt; </span><br><span class="line"></span><br><span class="line">keys:</span><br><span class="line">查看当前库下的所有key：<span class="comment">#keys * 慎用，相当于将数据库中的所有数据拿出，如果数据较多全部显示则会把机器卡死</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BGSAVE：</span><br><span class="line">手动在后台执行RDB持久化操作</span><br><span class="line">  172.18.135.1:6379&gt; BGSAVE</span><br><span class="line"></span><br><span class="line">DBSIZE：</span><br><span class="line">返回当前库下的所有key 数量</span><br><span class="line">  172.18.135.1:6379&gt; DBSIZE</span><br><span class="line"></span><br><span class="line">FLUSHDB：</span><br><span class="line">强制清空当前库中的所有key</span><br><span class="line">  172.18.135.1:6379&gt; FLUSHDB</span><br><span class="line"></span><br><span class="line">FLUSHALL：</span><br><span class="line">强制清空当前redis服务器所有数据库中的所有key，即删除所有数据</span><br><span class="line">  172.18.135.1:6379&gt; FLUSHALL</span><br></pre></td></tr></table></figure><h2 id="七：-redis高可用于集群——配置redis主从"><a href="#七：-redis高可用于集群——配置redis主从" class="headerlink" title="七： redis高可用于集群——配置redis主从"></a>七： redis高可用于集群——配置redis主从</h2><ul><li>虽然Redis可以实现单机的数据持久化，但无论是RDB也好或者AOF也好，都解决不了单点宕机问题，即一旦redis服务器本身出现系统故障、硬件故障等问题后，就会直接造成数据的丢失，因此需要使用另外的技术来解决单点问题。</li><li>配置reids 主从：<ul><li>主备模式，可以实现Redis数据的跨主机备份。</li><li>程序端连接到高可用负载的VIP，然后连接到负载服务器设置的Redis后端real server，此模式不需要在程序里面配置Redis服务器的真实IP地址，当后期Redis服务器IP地址发生变更只需要更改redis 相应的后端real server即可，可避免更改程序中的IP地址设置。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/分布式缓存.png" alt=""><br><img src="/2018/12/26/redis缓存/配置redis主从.png" alt=""></p><ul><li><code>Slave主要配置：</code><ul><li>Redis Slave 也要开启持久化（RDB\AOF）并设置和master同样的连接密码，因为后期slave会有提升为master的可能,Slave端切换master同步后会丢失之前的所有数据。（最好将slave的配置于master相同，密码相同为了master宕机提升slave为新的主，如果开始同步，从节点上的原有的值则被清空，所以最好是要当从节点的服务器为干净的redis服务系统，后期如果将从节点强制和主节点断开的话则从节点的数据不会丢失）</li><li>一旦某个Slave成为一个master的slave，Redis Slave服务会清空当前redis服务器上的所有数据并将master的数据导入到自己的内存，但是断开同步关系后不会删除当前已经同步过的数据。</li></ul></li></ul><h3 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法1：从节点命令行方式将称为主节点的slave</span><br><span class="line">  当前状态为master，需要转换为slave角色并指向master服务器的IP+PORT+Password</span><br><span class="line">  192.168.7.104:6379&gt; SLAVEOF 192.168.7.103 6379</span><br><span class="line">  OK</span><br><span class="line">  192.168.7.104:6379&gt; CONFIG SET masterauth 123456</span><br><span class="line">  OK</span><br><span class="line">  关闭从节点的从属性</span><br><span class="line">  127.0.0.1:6379&gt; SLAVEOF NO ONE </span><br><span class="line"></span><br><span class="line">在终端配置文件主从选项在重启服务后失效</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/redis缓存/同步日志.png" alt=""><br><img src="/2018/12/26/redis缓存/当前slave状态.png" alt=""></p><h3 id="保存在配置文件中"><a href="#保存在配置文件中" class="headerlink" title="保存在配置文件中"></a>保存在配置文件中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法2:</span><br><span class="line">此配置文件是编译安装的配置文件</span><br><span class="line">vim /usr/<span class="built_in">local</span>/redis/etc/redis.conf </span><br><span class="line">replicaof 192.168.7.103 6379</span><br><span class="line">masterauth 123456   <span class="comment">#master如果密码需要设置，这里设置的密码为主节点的密码</span></span><br><span class="line"></span><br><span class="line">从节点查看</span><br><span class="line">  重启服务查看</span><br><span class="line">  127.0.0.1:6379&gt; info</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/redis缓存/验证slave.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">验证slave数据：确定slave的数据是不是从主节点的数据同步来的，可以一致观察这从节点的日志</span><br><span class="line">  127.0.0.1:6379&gt; KEYS *</span><br><span class="line">  1) <span class="string">"num"</span></span><br><span class="line">  2) <span class="string">"hset1"</span></span><br><span class="line">  3) <span class="string">"key1"</span></span><br><span class="line">  4) <span class="string">"name1"</span></span><br><span class="line">  5) <span class="string">"zset2"</span></span><br><span class="line">  6) <span class="string">"key2"</span></span><br><span class="line">  7) <span class="string">"zset1"</span></span><br><span class="line">  8) <span class="string">"set2"</span></span><br><span class="line">slave 状态只读无法写入数据，</span><br></pre></td></tr></table></figure></p><h3 id="主从复制过程："><a href="#主从复制过程：" class="headerlink" title="主从复制过程："></a><code>主从复制过程：</code></h3><ul><li>Redis支持主从复制分为全量同步和增量同步，首次同步是全量同步，主从同步可以让从服务器从主服务器备份数据，而且从服务器还可与有从服务器，即另外一台redis服务器可以从一台从服务器进行数据同步，redis 的主从同步是非阻塞的，其收到从服务器的sync(2.8版本之前是PSYNC)命令会fork一个子进程在后台执行bgsave命令，并将新写入的数据写入到一个缓冲区里面，bgsave执行完成之后并生成的将RDB文件发送给客户端，客户端将收到后的RDB文件载入自己的内存，然后主redis将缓冲区的内容在全部发送给从redis，之后的同步从服务器会发送一个offset的位置(等同于MySQL的binlog的位置)给主服务器，主服务器检查后位置没有错误将此位置之后的数据包括写在缓冲区的积压数据发送给redis从服务器，从服务器将主服务器发送的挤压数据写入内存，这样一次完整的数据同步，再之后再同步的时候从服务器只要发送当前的offset位 置给主服务器，然后主服务器根据响应的位置将之后的数据发送给从服务器保存到其内存即可。</li><li>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： <ul><li>1）从服务器连接主服务器，发送SYNC命令； </li><li>2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB快照文件并使用缓冲区记录此后执行的所有写命令； </li><li>3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li><li>4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li>5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li><li>6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li><li>7）后期同步会先发送自己slave_repl_offset位置，只同步新增加的数据，不再全量同步。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/同步过程.png" alt=""></p><h3 id="主从同步优化："><a href="#主从同步优化：" class="headerlink" title="主从同步优化："></a><code>主从同步优化：</code></h3><ul><li>Redis在2.8版本之前没有提供增量部分复制的功能，当网络闪断或者slave Redis重启之后会导致主从之间的全量同步，即从2.8版本开始增加了部分复制的功能。<br>repl-diskless-sync  no #yes为支持disk，master将RDB文件先保存到磁盘在发送给slave，no为maste直接将RDB文件发送给slave，默认即为使用no，Master RDB文件不需要与磁盘交互。<ul><li>repl-diskless-sync-delay 5  #Master准备好RDB文件后等等待传输时间</li><li>repl-ping-slave-period 10 #slave端向server端发送pings的时间区间设置，默认为10秒 </li><li>repl-timeout 60 #设置超时时间</li><li>repl-disable-tcp-nodelay no #是否启用TCP_NODELAY，如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致，假如设置成no，则redis master会立即发送同步数据，没有延迟，前者关注性能，后者关注一致性</li><li>repl-backlog-size 1mb  #master的写入数据缓冲区，用于记录自上一次同步后到下一次同步过程中间的写入命令，计算公式：b repl-backlog-size = 允许从节点最大中断时长 <em> 主实例offset每秒写入量，比如master每秒最大写入64mb，最大允许60秒，那么就要设置为64mb</em>60秒=3840mb(3.8G)=</li><li>repl-backlog-ttl 3600 #如果一段时间后没有slave连接到master，则backlog size的内存将会被释放。如果值为0则表示永远不释放这部份内存。 </li><li>slave-priority 100 #slave端的优先级设置，值是一个整数，数字越小表示优先级越高。当master故障时将会按照优先级来选择slave端进行恢复，如果值设置为0，则表示该slave永远不会被选择。 </li><li>#min-slaves-to-write 0 # </li><li>#min-slaves-max-lag 10 #设置当一个master端的可用slave少于N个，延迟时间大于M秒时，不接收写操作。</li><li>\Master的重启会导致master_replid发生变化，slave之前的master_replid就和master不一致从而会引发所有slave的全量同步。</li></ul></li></ul><p>Slave同步过程日志：<br><img src="/2018/12/26/redis缓存/同步过程日志.png" alt=""><br>master同步日志：<br><img src="/2018/12/26/redis缓存/master同步日志.png" alt=""></p><h3 id="slave切换master："><a href="#slave切换master：" class="headerlink" title="slave切换master："></a><code>slave切换master：</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">当前状态：</span><br><span class="line">  从节点的状态信息</span><br><span class="line">  192.168.7.101:6379&gt; info Replication</span><br><span class="line">  <span class="comment"># Replication</span></span><br><span class="line">  role:slave</span><br><span class="line">  master_host:192.168.7.103</span><br><span class="line">  master_port:6379</span><br><span class="line">  master_link_status:up</span><br><span class="line">  master_last_io_seconds_ago:8</span><br><span class="line">  master_sync_in_progress:0</span><br><span class="line"></span><br><span class="line">停止slave同步并查看当前状态：</span><br><span class="line">  192.168.7.101:6379&gt; SLAVEOF no one</span><br><span class="line">  OK</span><br><span class="line">  192.168.7.101:6379&gt; info Replication</span><br><span class="line">  <span class="comment"># Replication</span></span><br><span class="line">  role:master</span><br><span class="line">  connected_slaves:0</span><br><span class="line">  master_replid:ac3475e5e4fae8c5f47711a643e465b9520c4182</span><br><span class="line">  master_replid2:8ee6bc1ac452fd4d2ccbaa660a219f78d218399a</span><br><span class="line">  master_repl_offset:8840</span><br><span class="line">  second_repl_offset:8841</span><br><span class="line">  repl_backlog_active:1</span><br><span class="line">  repl_backlog_size:1048576</span><br><span class="line">  repl_backlog_first_byte_offset:8547</span><br><span class="line">  repl_backlog_histlen:294</span><br><span class="line"></span><br><span class="line">测试能从节点否写入数据：</span><br><span class="line">  192.168.7.101:6379&gt; <span class="built_in">set</span> key1 value1 <span class="comment">#从节点停止主从结构时就是本机的自己的主，所以自然可以都自己的值进行写入</span></span><br><span class="line">  OK</span><br><span class="line">  192.168.7.101:6379&gt;</span><br><span class="line"></span><br><span class="line">虽然从节点脱离了主从结构，但是从节点的数据，依然保留着主节点同步时的数据。</span><br></pre></td></tr></table></figure><h3 id="Slave节点再有Slave："><a href="#Slave节点再有Slave：" class="headerlink" title="Slave节点再有Slave："></a><code>Slave节点再有Slave：</code></h3><p><img src="/2018/12/26/redis缓存/从节点再有从节点.png" alt=""></p><ul><li><code>在有slave的”master”查看状态：</code><ul><li># Replication</li><li>role:slave</li><li>master_host:192.168.7.102</li><li>master_port:6379</li><li>master_link_status:up</li><li>master_last_io_seconds_ago:9 #最近一次与master通信已经过去多少秒。</li><li>master_sync_in_progress:0  #是否正在与master通信。</li><li>slave_repl_offset:5334 #当前同步的偏移量。</li><li>slave_priority:100 #slave优先级，master故障后值越小越优先同步，一半设置相同的数值让它同时同步。</li><li>slave_read_only:1</li><li>connected_slaves:1</li><li>slave0:ip=192.168.7.104,port=6379,state=online,  </li><li>offset=5334,lag=1</li><li>master_replid:0f0318c25a022add7fd51d4438c470cf608631f9</li><li>master_replid2:0000000000000000000000000000000000000000</li><li>master_repl_offset:5334</li><li>second_repl_offset:-1</li><li>repl_backlog_active:1</li><li>repl_backlog_size:1048576</li><li>repl_backlog_first_byte_offset:1</li><li>repl_backlog_histlen:5334</li></ul></li></ul><h3 id="常见问题汇总："><a href="#常见问题汇总：" class="headerlink" title="常见问题汇总："></a><code>常见问题汇总：</code></h3><ul><li>master密码不对：<ul><li>即配置的master密码不对，导致验证不通过而无法建立主从同步关系。</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/master密码不对.png" alt=""></p><ul><li><p>Redis版本不一致：</p><ul><li>不同的redis 版本之间存在兼容性问题，因此各master和slave之间必须保持版本一致。<br><img src="/2018/12/26/redis缓存/版本不一致报错.png" alt=""></li></ul></li><li><p>无法远程连接：</p><ul><li>在开启了安全模式情况下，没有设置bind地址和密码</li></ul></li></ul><p><img src="/2018/12/26/redis缓存/远程无法连接.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis缓存及架构&quot;&gt;&lt;a href=&quot;#redis缓存及架构&quot; class=&quot;headerlink&quot; title=&quot;redis缓存及架构&quot;&gt;&lt;/a&gt;redis缓存及架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/26/redis缓存/redis标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux服务" scheme="https://9527dz.top/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="redis缓存" scheme="https://9527dz.top/tags/redis%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>KVM.virsh命令使用入门</title>
    <link href="https://9527dz.top/2018/12/25/KVM-virsh%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://9527dz.top/2018/12/25/KVM-virsh命令使用入门/</id>
    <published>2018-12-25T06:33:21.051Z</published>
    <updated>2018-12-25T13:58:20.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVM-virsh命令使用入门"><a href="#KVM-virsh命令使用入门" class="headerlink" title="KVM-virsh命令使用入门"></a>KVM-virsh命令使用入门</h1><p><img src="/2018/12/25/KVM-virsh命令使用入门/标题.png" alt=""><br><a id="more"></a></p><ul><li>虚拟化技术<ul><li>主机级虚拟化：infrastructure</li><li>容器级虚拟化（用户空间虚拟化即容器）：Container<ul><li>内核名称空间：<ul><li>NET</li><li>Mount</li><li>PID</li><li>UTS</li><li>IPC</li><li>User</li></ul></li></ul></li><li>程序级虚拟化：<ul><li>JVM</li><li>PVM</li></ul></li></ul></li><li><p>云计算环境：</p><ul><li>SaaS：软件即服务</li><li>CaaS:容器即服务</li><li>FWaaS:防火墙即服务</li><li>LBaaS:负载均衡即服务</li><li>DBaaS:数据库即服务</li><li>IaaS:基础设施即服务</li><li>PaaS:平台即服务</li></ul></li><li><p>虚拟主机通讯：  </p><ul><li>物理桥：主机过多，主机间交换报文发生瓶颈</li><li>隧道、叠加网络</li></ul></li></ul><p><img src="/2018/12/25/KVM-virsh命令使用入门/kvm管理工具.png" alt=""></p><ul><li>virsh家族的虚拟机创建后，即使物理机重启了虚拟机也还在。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 所有的虚拟机创建完成后，/etc/libvirt作为的配置文件的工作目录</span><br><span class="line"></span><br><span class="line">  [root@centos7 ~]<span class="comment"># ls /etc/libvirt/</span></span><br><span class="line">  libvirt-admin.conf  lxc.conf  qemu.conf        storage</span><br><span class="line">  libvirt.conf        nwfilter  qemu-lockd.conf  virtlockd.conf</span><br><span class="line">  libvirtd.conf       qemu      secrets          virtlogd.conf</span><br><span class="line"></span><br><span class="line">使用qemu+kvm创建虚拟服务时，配置文件保存在qemu文件中（每个创建的虚拟机都表现为一个.xml文件，立案包含了所有创建虚拟机的所有的相关配置）</span><br><span class="line">  [root@centos7 vms]<span class="comment"># ls /etc/libvirt/qemu</span></span><br><span class="line">  altlinux7.0.xml</span><br></pre></td></tr></table></figure><p><img src="/2018/12/25/KVM-virsh命令使用入门/kvm架构.png" alt=""></p><ul><li>虚拟的主机中虚拟cpu核心，仅表现为宿主机中线程</li></ul><h3 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a><code>virsh</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">列创建的虚拟机</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh list</span></span><br><span class="line">   Id    Name                           State</span><br><span class="line">  ----------------------------------------------------</span><br><span class="line">   12    altlinux7.0                    running</span><br><span class="line"></span><br><span class="line"><span class="comment">## virsh list帮助</span></span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh list --help</span></span><br><span class="line">    OPTIONS</span><br><span class="line">    --inactive       列出不活跃的域</span><br><span class="line">    --all            不活跃和活跃的域列表</span><br><span class="line">    --transient      列出临时域</span><br><span class="line">    --persistent     列出持久域</span><br><span class="line">    --with-snapshot  列出现有的快照的域</span><br><span class="line">    --without-snapshot  列出没有快照的域</span><br><span class="line">    --state-running  运行状态的域列表</span><br><span class="line">    --state-paused   列出暂停状态的域</span><br><span class="line">    --state-shutoff  列出关闭状态的域</span><br><span class="line">    --state-other    列出其他状态的域</span><br><span class="line">    --autostart      列出启用antostart的域</span><br><span class="line">    --no-autostart   列出禁用antostart的域</span><br><span class="line">    --with-managed-save  列出有管理的保存状态的域</span><br><span class="line">    --without-managed-save  列出没有管理的保存状态的域</span><br><span class="line">    --uuid           只列出 uuid</span><br><span class="line">    --name           只列出域名</span><br><span class="line">    --table          列出表格（默认）</span><br><span class="line">    --managed-save   标记有管理的保存状态的域</span><br><span class="line">    --title          show domain title</span><br><span class="line"></span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh list --all</span></span><br><span class="line">   Id    Name                           State</span><br><span class="line">  ----------------------------------------------------</span><br><span class="line">   12    altlinux7.0                    running</span><br><span class="line"></span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh list --name</span></span><br><span class="line">  altlinux7.0</span><br><span class="line"></span><br><span class="line">查看虚拟机的详细信息（实际上看的就是此虚拟机的xml的配置文件）</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh dumpxml altlinux7.0</span></span><br><span class="line"></span><br><span class="line">可以将查看虚拟机的详细信息保存在/etc/libvirt作为的配置文件的工作目录中，加以修改实现创建一台新的虚拟系统</span><br><span class="line">  [root@centos7 ~]<span class="comment"># virsh dumpxml altlinux7.0 &gt; /etc/libvirt/qemu/c1.xml</span></span><br><span class="line">  编辑c1.xml</span><br><span class="line">  必须修改项（行）：</span><br><span class="line">          2：名字</span><br><span class="line">          3：删除uuid，启动自动生成</span><br><span class="line">          38：修改本地对应镜像文件</span><br><span class="line">          71：网卡MAC</span><br><span class="line"></span><br><span class="line">创建虚拟机（此实现的前提时建立在上一章kvm虚拟机基础应用的实验的，下一执行命令是在kvm服务器上）</span><br><span class="line">      virsh <span class="built_in">help</span> create :查看创建虚拟机并且启动的帮助</span><br><span class="line">      virsh <span class="built_in">help</span> define :查看仅创建但不启动的帮助</span><br><span class="line">      virsh <span class="built_in">help</span> start :查看启动的帮助</span><br><span class="line">      virsh define &lt;xmlfile&gt; --validate : 检查xml文件格式是否有误</span><br><span class="line">  </span><br><span class="line">  启动虚拟机，并指顶xml文件</span><br><span class="line">      检查语法</span><br><span class="line">      [root@centos7 ~]<span class="comment"># virsh define /etc/libvirt/qemu/c1.xml --validate</span></span><br><span class="line">      Domain c1 defined from /etc/libvirt/qemu/c1.xml</span><br><span class="line">      创建</span><br><span class="line">      [root@centos7 ~]<span class="comment"># virsh define /etc/libvirt/qemu/c1.xml</span></span><br><span class="line">      Domain c1 defined from /etc/libvirt/qemu/c1.xml</span><br><span class="line">      查看是否创建成功</span><br><span class="line">      [root@centos7 ~]<span class="comment"># virsh list --all</span></span><br><span class="line">        Id    Name                           State</span><br><span class="line">        ----------------------------------------------------</span><br><span class="line">        12    altlinux7.0                    running</span><br><span class="line">        -     c1                             shut off</span><br><span class="line">      启动</span><br><span class="line">      [root@centos7 ~]<span class="comment"># virsh start c1</span></span><br><span class="line">      Domain c1 started</span><br><span class="line">      [root@centos7 ~]<span class="comment"># virsh list </span></span><br><span class="line">       Id    Name                           State</span><br><span class="line">      ----------------------------------------------------</span><br><span class="line">       12    altlinux7.0                    running</span><br><span class="line">       13    c1                             running</span><br><span class="line"></span><br><span class="line">  查看创建的虚拟机的地址</span><br><span class="line">    [root@centos7 ~]<span class="comment"># virsh domifaddr c1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 查看virsh控制台 virsh help console</span></span><br><span class="line"></span><br><span class="line">  使用连接控制台连接虚拟机</span><br><span class="line">  [root@centos7 ~]<span class="comment"># virsh console c1</span></span><br><span class="line">  login as <span class="string">'cirros'</span> user. default password: <span class="string">'cubswin:)'</span>. use <span class="string">'sudo'</span> <span class="keyword">for</span> root.</span><br><span class="line"></span><br><span class="line">  退出当前连接</span><br><span class="line">  ctrl + ]</span><br><span class="line"></span><br><span class="line">  kvm虚拟机的暂停：所有的占用内存，仍然在内存中，只是不响应任何请求。定在内存中，如果宿主机掉电，则虚拟机的所有数据将会丢失</span><br><span class="line"></span><br><span class="line">  kvm虚拟机的挂起:是将宿主机上的所有的虚拟机的使用内存抽取掉，保存成二进制文件，放在磁盘上，下次再次开启虚拟机可以将磁盘中的二进制文件读出来恢复至内存中</span><br><span class="line"></span><br><span class="line">  暂停kvm虚拟机c1</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh suspend c1</span></span><br><span class="line"></span><br><span class="line">  恢复kvm虚拟机c1</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh resume c1</span></span><br><span class="line"></span><br><span class="line">  挂起kvm虚拟机c1（建议挂起虚拟机的时候将虚拟机先暂停）</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh save c1 /tmp/c1.bin --paused</span></span><br><span class="line"></span><br><span class="line">  取消挂起kvm虚拟机c1</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh restore /tmp/c1.bin --running</span></span><br><span class="line"></span><br><span class="line">  重启kvm虚拟机c1（热重启）</span><br><span class="line">  virsh reboot c1</span><br><span class="line"></span><br><span class="line">  重启kvm虚拟机c1（冷重启,如同使用电源按钮重新设定目标）</span><br><span class="line">  virsh reset c1</span><br><span class="line"></span><br><span class="line">  关机</span><br><span class="line">  virsh shutdown c1 /相当于在主虚拟机内部shutdown -0</span><br><span class="line"></span><br><span class="line">  暴力拨电，销毁虚拟机的运行状态(销毁的只是虚拟机的运行状态并非是虚拟机的系统程序文件)</span><br><span class="line">  virsh destroy c1</span><br><span class="line"></span><br><span class="line">  删除虚拟机（取消定义一个域或者持久转换为临时）</span><br><span class="line">  vrish undefine c1</span><br><span class="line"></span><br><span class="line">  将虚拟机设置为随宿主机启动开启</span><br><span class="line">  [root@centos7 vms]<span class="comment"># virsh autostart c1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;KVM-virsh命令使用入门&quot;&gt;&lt;a href=&quot;#KVM-virsh命令使用入门&quot; class=&quot;headerlink&quot; title=&quot;KVM-virsh命令使用入门&quot;&gt;&lt;/a&gt;KVM-virsh命令使用入门&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/25/KVM-virsh命令使用入门/标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux服务" scheme="https://9527dz.top/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="KVM" scheme="https://9527dz.top/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>kvm虚拟机基础应用</title>
    <link href="https://9527dz.top/2018/12/25/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <id>https://9527dz.top/2018/12/25/kvm虚拟机基础应用/</id>
    <published>2018-12-25T03:28:26.046Z</published>
    <updated>2018-12-25T13:58:11.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kvm虚拟机基础应用"><a href="#kvm虚拟机基础应用" class="headerlink" title="kvm虚拟机基础应用"></a>kvm虚拟机基础应用</h1><p><img src="/2018/12/25/kvm虚拟机基础应用/kvm.png" alt=""><br><a id="more"></a></p><ul><li>kvm: Kernel-based Virtual Machine  <ul><li>Qumranet公司 –&gt; RedHat  <ul><li>(1) X86_64  </li><li>(2) HVM:   <ul><li>Intel VT  </li><li>AMD AMD-v  </li></ul></li></ul></li></ul></li></ul><p><img src="/2018/12/25/kvm虚拟机基础应用/kvm1.png" alt=""><br><img src="/2018/12/25/kvm虚拟机基础应用/kvm管理工具.png" alt="">  </p><ul><li><p>KVM的组件：</p><ul><li>两类组件：<ul><li>(kvm.ko)/dev/kvm：工作为hypervisor，在用户空间可通过系统调用ioctl()与内核中的kvm模块交互，从而完成虚拟机的创建、启动、停止、删除等各种管理功能；</li><li>qemu-kvm进程：工作于用户空间，用于实现IO设备模拟；用于实现一个虚拟机实例；</li></ul></li></ul></li><li><p>KVM模块load进内存之后，系统的运行模式：</p><ul><li>内核模式：GuestOS执行IO类的操作时，或其它的特殊指令操作时的模式；它也被称为“Guest-Kernel”模式；<pre><code>用户模式：Host OS的用户空间，用于代为GuestOS发出IO请求；来宾模式：GuestOS的用户模式；所有的非IO类请求；</code></pre></li></ul></li><li><p>运行中的一个kvm虚拟机就是一个qemu-kvm进程，运行qemu-kvm程序并传递给它合适的选项及参数即能完成虚拟机启动，终止此进程即能关闭虚拟机；</p></li></ul><h2 id="安装使用KVM"><a href="#安装使用KVM" class="headerlink" title="安装使用KVM"></a>安装使用KVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">安装kvm的主机上：</span><br><span class="line"></span><br><span class="line">判断CPU是否支持硬件虚拟化：</span><br><span class="line">[root@centos7 ~]<span class="comment"># grep -i -E '(vmx|svm|lm)' /proc/cpuinfo</span></span><br><span class="line">    cpu型号：</span><br><span class="line">    vmx：Intel VT-x</span><br><span class="line">    svm：AMD AMD-v</span><br><span class="line">    lm:64位cpu</span><br><span class="line"></span><br><span class="line">加载kvm模块使得内核支持kvm,并判断是否成功加载此模块</span><br><span class="line">  [root@centos7 ~]<span class="comment"># modprobe kvm</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># lsmod | grep kvm</span></span><br><span class="line">  kvm_intel             174841  0 </span><br><span class="line">  kvm                   578518  1 kvm_intel</span><br><span class="line">  irqbypass              13503  1 kvm</span><br><span class="line">  [root@centos7 ~]<span class="comment"># file /dev/kvm （字符设备）</span></span><br><span class="line">  /dev/kvm: character special</span><br><span class="line"></span><br><span class="line">安装qemu-kvm,使用户空间具有控制工具</span><br><span class="line">  [root@centos7 ~]<span class="comment"># yum install qemu-kvm -y</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># rpm -ql qemu-kvm</span></span><br><span class="line">  /usr/libexec/qemu-kvm   命令行工具被放在了非PATH变量中，红帽防止用户手动创建虚拟主机。此工具很底层</span><br><span class="line"></span><br><span class="line">使用virt-manager管理kvm(libvirt-daemon-kvm守护进程工具 qemu-kvm  virt-manager图形化工具 libvirt库)</span><br><span class="line">  [root@centos7 ~]<span class="comment"># yum install libvirt-daemon-kvm qemu-kvm  virt-manager libvirt -y</span></span><br><span class="line">  （因为已经安装图形化界面的管理工具，确保宿主机上已经安装图像化相关的库 yum groupinstall GNOME Desktop）</span><br><span class="line"></span><br><span class="line">如果宿主机上已经安装有图像化相关的库则启动libvirt守护进程</span><br><span class="line">  [root@centos7 ~]<span class="comment"># systemctl start libvirtd</span></span><br><span class="line"></span><br><span class="line">libvirtd安装好默认仅提供了一个net网络</span><br><span class="line">创建桥接网络</span><br><span class="line">    将物理网卡当交换及使用</span><br><span class="line">    将软交换机当物理网卡使用</span><br><span class="line">创建物理桥（交换机）</span><br><span class="line">  [root@centos7 ~]<span class="comment"># cd /etc/sysconfig/network-scripts/</span></span><br><span class="line">  [root@centos7 network-scripts]<span class="comment"># cp ifcfg-ens37 ifcfg-br0</span></span><br><span class="line"></span><br><span class="line">配置网卡的配置文件，使br0当网卡使用，将ens37当交换机使用</span><br><span class="line">  [root@centos7 network-scripts]<span class="comment"># vim ifcfg-ens37</span></span><br><span class="line">  HWADDR=00:0C:29:14:4D:6C</span><br><span class="line">  TYPE=Ethernet</span><br><span class="line">  BROWSER_ONLY=no</span><br><span class="line">  BOOTPROTO=none</span><br><span class="line">  DEFROUTE=yes</span><br><span class="line">  IPV4_FAILURE_FATAL=no</span><br><span class="line">  IPV6INIT=no</span><br><span class="line">  NAME=ens37</span><br><span class="line">  DEVICE=ens37</span><br><span class="line">  BRIDGE=br0</span><br><span class="line">  ONBOOT=yes</span><br><span class="line"></span><br><span class="line">  [root@centos7 network-scripts]<span class="comment"># vim ifcfg-br0 </span></span><br><span class="line">  NAME=br0</span><br><span class="line">  DEVICE=br0</span><br><span class="line">  TYPE=Bridge</span><br><span class="line">  PROXY_METHOD=none</span><br><span class="line">  BROWSER_ONLY=no</span><br><span class="line">  BOOTPROTO=none</span><br><span class="line">  IPADDR=172.18.135.1</span><br><span class="line">  PREFIX=24</span><br><span class="line">  GATEWAY=172.18.0.1</span><br><span class="line">  DNS1=8.8.8.8</span><br><span class="line">  DEFROUTE=yes</span><br><span class="line">  IPV4_FAILURE_FATAL=no</span><br><span class="line">  IPV6_FAILURE_FATAL=no</span><br><span class="line">  IPV6_PRIVACY=no</span><br><span class="line">  ONBOOT=yes</span><br><span class="line">  [root@centos7 network-scripts]<span class="comment"># systemctl restart network</span></span><br><span class="line"></span><br><span class="line">  此时br0已经是网卡了，ens37变成了交换机</span><br><span class="line">    [root@centos7 network-scripts]<span class="comment"># ifconfig</span></span><br><span class="line">   br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">          inet 172.18.135.1  netmask 255.255.255.0  broadcast   172.18.135.255</span><br><span class="line">          inet6 fe80::20c:29ff:fe14:4d6c  prefixlen 64  scopeid     0x20&lt;link&gt;</span><br><span class="line">          ether 00:0c:29:14:4d:6c  txqueuelen 1000  (Ethernet)</span><br><span class="line">         RX packets 590  bytes 75531 (73.7 KiB)</span><br><span class="line">         RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">         TX packets 53  bytes 8801 (8.5 KiB)</span><br><span class="line">         TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">   ens37: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">         ether 00:0c:29:14:4d:6c  txqueuelen 1000  (Ethernet)</span><br><span class="line">         RX packets 7333  bytes 809500 (790.5 KiB)</span><br><span class="line">         RX errors 0  dropped 2  overruns 0  frame 0</span><br><span class="line">         TX packets 1275  bytes 194949 (190.3 KiB)</span><br><span class="line">         TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">远程连接安装kvm的主机</span><br><span class="line">一下操作在远程连接的主机上操作</span><br><span class="line">  查看网卡已经多了一个virbr0b设备，次接口是libvirtd自动生成的net模式类型的接口</span><br><span class="line">    [root@centos7 ~]<span class="comment"># ssh -X 安装kvm的主机地址</span></span><br><span class="line">    [root@centos7 ~]<span class="comment"># systemctl start libvirtd</span></span><br><span class="line">    [root@centos7 ~]<span class="comment"># ifconfig</span></span><br><span class="line">  br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">         inet 172.18.135.1  netmask 255.255.255.0  broadcast 172.18.135.255</span><br><span class="line">         inet6 fe80::20c:29ff:fe14:4d6c  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">          ether 00:0c:29:14:4d:6c  txqueuelen 1000  (Ethernet)</span><br><span class="line">          RX packets 3006  bytes 1312927 (1.2 MiB)</span><br><span class="line">          RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">          TX packets 412  bytes 58640 (57.2 KiB)</span><br><span class="line">         TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">    ens37: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">          ether 00:0c:29:14:4d:6c  txqueuelen 1000  (Ethernet)</span><br><span class="line">          RX packets 18644  bytes 3281398 (3.1 MiB)</span><br><span class="line">          RX errors 0  dropped 28  overruns 0  frame 0</span><br><span class="line">         TX packets 1827  bytes 281257 (274.6 KiB)</span><br><span class="line">         TX errors 0  dropped 0 overruns 0   carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">          inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">         inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">         loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">         RX packets 312  bytes 32472 (31.7 KiB)</span><br><span class="line">         RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">          TX packets 312  bytes 32472 (31.7 KiB)</span><br><span class="line">          TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">  virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">          inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">         ether 52:54:00:ff:0b:1f  txqueuelen 1000  (Ethernet)</span><br><span class="line">         RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">         RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">         TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">         TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">检查libvirtd程序是否启动，级运行virt-manager图形化</span><br><span class="line">  [root@centos7 ~]<span class="comment"># systemctl status libvirtd</span></span><br><span class="line">  [root@centos7 ~]<span class="comment"># virt-manager</span></span><br></pre></td></tr></table></figure><p>以下操作在远程远程连接的主机上<br>使用pxe安装环境<br><img src="/2018/12/25/kvm虚拟机基础应用/virt-manager.png" alt=""><br><img src="/2018/12/25/kvm虚拟机基础应用/第一步.png" alt=""><br><img src="/2018/12/25/kvm虚拟机基础应用/第二步.png" alt=""></p><p><img src="/2018/12/25/kvm虚拟机基础应用/pxe.png" alt=""><br><img src="/2018/12/25/kvm虚拟机基础应用/第三步.png" alt=""><br>使用本地的镜像（导入现有磁盘映像）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># ls</span></span><br><span class="line">cirros-0.3.0-x86_64-disk.img</span><br><span class="line">[root@centos7 ~]<span class="comment"># mkdir /vms</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># mv cirros-0.3.0-x86_64-disk.img /vms/</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># cd /vms/</span></span><br><span class="line">[root@centos7 vms]<span class="comment"># ls</span></span><br><span class="line">cirros-0.3.0-x86_64-disk.img</span><br><span class="line">[root@centos7 vms]<span class="comment"># cp cirros-0.3.0-x86_64-disk.img pc1.img</span></span><br><span class="line">[root@centos7 vms]<span class="comment"># cp cirros-0.3.0-x86_64-disk.img pc2.img</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/12/25/kvm虚拟机基础应用/本地1.png" alt=""><br><img src="/2018/12/25/kvm虚拟机基础应用/本地2.png" alt=""><br>点击Browse Local本地浏览<br><img src="/2018/12/25/kvm虚拟机基础应用/本地3.png" alt=""></p><ul><li>本机客户端访问外部网络<ul><li>SNAT源地址转换适用于隐藏客户端地址<ul><li>主要原因是ipv4地址不够用，私网的地址在互联网没办法被路由。</li></ul></li></ul></li><li>本机服务端，放在互联网被客户访问。<ul><li>DNET目标地址转换，仅考虑请求报文，不考虑响应报文，适用于隐藏服务端的地址</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kvm虚拟机基础应用&quot;&gt;&lt;a href=&quot;#kvm虚拟机基础应用&quot; class=&quot;headerlink&quot; title=&quot;kvm虚拟机基础应用&quot;&gt;&lt;/a&gt;kvm虚拟机基础应用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/12/25/kvm虚拟机基础应用/kvm.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux服务" scheme="https://9527dz.top/categories/linux%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="kvm虚拟机基础应用" scheme="https://9527dz.top/tags/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络基础架构</title>
    <link href="https://9527dz.top/2018/12/22/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://9527dz.top/2018/12/22/网络基础/</id>
    <published>2018-12-22T11:35:57.600Z</published>
    <updated>2018-12-29T13:53:05.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/12/22/网络基础/标题.png" alt=""><br><a id="more"></a></p><h2 id="企业网络架构介绍"><a href="#企业网络架构介绍" class="headerlink" title="企业网络架构介绍"></a>企业网络架构介绍</h2><ul><li><p>网络:</p><ul><li>多个终端设备</li><li>网络传输介质设备实现通讯</li></ul></li><li><p>局域网：最小的网络、本地、公司</p></li><li>广域网：不通的局域网连接</li><li><p>城域网：比广域网小，例如：一个城市</p></li><li><p>无线网（AP）</p><ul><li>CCNA</li><li>CCNP</li></ul></li><li>企业网络远程互联<ul><li>企业网络组网不受地域限制，可以通过各种远程互联技术把分布在不同的地域的网络的网络连接在一起<ul><li>ipsu</li><li>mpls vpn</li><li>专线</li></ul></li></ul></li><li>广域网：逻辑的层次划分</li><li>小型企业组网：扁平</li><li>大型网络组网：层次  <ul><li>思想：<ul><li>业务</li><li>冗余</li><li>层次-安全</li></ul></li></ul></li></ul><p><img src="/2018/12/22/网络基础/企业网络基础结构.png" alt=""><br><img src="/2018/12/22/网络基础/企业网络.png" alt=""></p><h2 id="传输介质介绍"><a href="#传输介质介绍" class="headerlink" title="传输介质介绍"></a>传输介质介绍</h2><ul><li><p>通讯网络除了包含通讯设备的本身之外，还包含连接这些设备的传输介质，如同线缆、双绞线、和光纤等，不同的传输介质具有不用的特征，这些特性直接影响到通讯诸多方面，如线路编码方式、传输速度和传输距离等。</p></li><li><p>路由</p></li><li>交换机</li><li>传输介质：连接设备的线缆<ul><li>网线</li><li>光线</li></ul></li></ul><p><img src="/2018/12/22/网络基础/两台主机连接.png" alt=""></p><ul><li><p>两个终端，用一条能承载数据传输的物理介质（也成为传输介质），连接起来，组成了一个最简单的网络。</p></li><li><p>介质</p></li></ul><p><img src="/2018/12/22/网络基础/同轴电缆.png" alt=""><br><img src="/2018/12/22/网络基础/双绞线.png" alt=""><br><img src="/2018/12/22/网络基础/以太网线线序.png" alt=""><br><img src="/2018/12/22/网络基础/串口电缆.png" alt=""><br><img src="/2018/12/22/网络基础/光纤.png" alt=""></p><ul><li>光猫：光纤设置转换为网络设备进入网络</li><li>白色：单模光纤</li><li>黄色：多模光纤</li></ul><p><img src="/2018/12/22/网络基础/冲突域.png" alt=""></p><ul><li>共享式网络中可能会出现信号冲突现象</li></ul><p><img src="/2018/12/22/网络基础/共享网络冲突域解决方法.png" alt=""></p><ul><li><p>CSMA/CD: 载波侦听多路访问/冲突检测技术</p><ul><li>工作原理：先听先发，边听边发，冲突避让，等待重发。</li></ul></li><li><p>以太网的最大包长和最小包长</p><ul><li>最大包长1518byte,其中三层数据1500byte（称为MTU）只是一个规定而言</li><li>最小包长64byte<ul><li>原因：如果A主机发送的帧很小，很快完成帧的发送，而两台冲突主机相差很远，在主机A发送的帧传输到B的前一刻，B开始发送帧，这样，当A的帧到达B时，B检测到冲突，于是发送冲突信号。假如在B冲突信号传输到A之前，A的帧已经发送完毕，那么A将检测不到冲突而误认为已经发送成功，因此必须有最小包长的限制。</li></ul></li></ul></li></ul><p><img src="/2018/12/22/网络基础/双工模式.png" alt=""></p><ul><li>两种双工模式都支持双向数据传输</li><li>冲突与：半双工模式</li></ul><h2 id="分层模型及以太网帧结构"><a href="#分层模型及以太网帧结构" class="headerlink" title="分层模型及以太网帧结构"></a>分层模型及以太网帧结构</h2><p><img src="/2018/12/22/网络基础/网络通讯协议.png" alt=""></p><ul><li><p>不同的协议栈用于定义和管理不同的网络的数据转发规则</p></li><li><p>什么是协议</p><ul><li>为了使数据可以在网络上从源传递到目标地址，网络上所有设备需要“讲”相同的语言</li></ul></li><li><p>数据通讯协议的定义</p><ul><li>决定数据的格式和传输的一组规则和一组惯例</li></ul></li><li><p>网络通讯的过程很复杂</p><ul><li>数据以电子信号的形式穿越介质到达正确的计算机，然后转换为最初的形式，以便接收者可以阅读</li><li>为了降低网络设计的复杂性，将协议进行了分层设计</li></ul></li><li><p>分层设计的意义</p><ul><li>通讯服务层的模块设计可相对独立于具有的通讯路线和通讯接口的差别</li><li>而通信服务层的模块设计又可相对独立具体用户应用的要求不同</li><li>简化了相关的网络操作，提供了不不同的厂商之间的兼容性；促进了标准化工作，结构上进行了分层；易于学习和操作</li><li>各个层次独立，一层的变化不会影响到邻层</li></ul></li><li><p><code>OSI参考模型</code></p><ul><li>国际标准化组织ISO于1984年提出了OSI RM 。OSI参考模型很快成了计算机网络的基础模型</li><li>OSI参考模型具有的优点：简化了相关的网络操作，提供了不同的厂商之间的兼容性；促进了标准化工作；结构上进行了分层；易于学习和操作</li><li>OSI参考模型各个层次的功能如下：<ul><li>网络层：在设备之间传输比特流，规定了电平、速度和断缆针脚</li><li>数据链路层：将比特流组合成了字节，再将字节组合成帧，使用链路层地址（以太网使用MAC地址）来访问介质，并进行排差错检测</li><li>网络层：提供逻辑地址，供路由确定路径</li><li>传输层：提供面向连接或者非面向连接的数据传递以及进行排差错检测</li><li>会话层：负责建、管理和终止表示层实体之间的通讯会话。该层的通信由不同的设备中的应用程序之间的服务请求和响应组成（通信设备可能存在多个会话）</li><li>表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能够被另一个系统的应用层识别（数据表、加密、图片、文档、文字）</li><li>应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务</li></ul></li></ul></li></ul><p><img src="/2018/12/22/网络基础/osi参考模型.png" alt=""></p><ul><li>OSI层次设计的理念<ul><li>建立七层模型的主要目的使为解决异种网络互连时所遇到的兼容性问题</li><li>它的优点：将服务、接口和协议这三个概念明确地区分开来<ul><li>服务：某一层为上一层提供什么功能</li><li>接口：上层如何使用下层的服务</li><li>协议：如何实现本层的服务</li></ul></li><li>这样各层之间具有很强的独立性，互联网络中各尸体采用什么样的协议时没有限制的，只要向上提供形同的服务并且不改变相邻层的接口就可以了</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/12/22/网络基础/标题.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络基础架构" scheme="https://9527dz.top/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="网络基础架构" scheme="https://9527dz.top/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
